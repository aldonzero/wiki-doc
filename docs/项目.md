## 文章投票

构建一个文章投票网站，我们首先要做的就是为了这个网站设置一些数值和限制条件:

- 如果一篇文章获得了至少200 张支持票 (up vote)那么网站就认为这篇文章是一篇有趣的文章;
- 假如这个网站每天发布 1000 篇文章，而其中的50篇符合网站对有趣文章的要求，那么网站要做的就是把这 50篇文章放到文章列表前 100 位至少一天;
- 另外，这个网站暂时不提供投反对票(downvote)的功能。

为了产生一个能够随着时间流逝而不断减少的评分，程序需要根据文章的发布时间和当前时间来计算文章的评分，具体的计算方法为：将文章得到的支持票数量乘以一个常量，然后加上文章的发布时间，得出的结果就是文章的评分。

计算评分时与支持票数量相乘的常量为 432，这个常量是通过将一天的秒数(86 400)除以文章展示一天所需的支持票数量(200)得出的：文章每获得一张支持票，程序就需要将文章的评分增加432 分。

使用hash进行存储

```sh
key:article:articleId
val:title、link、poster、time、votes
```

为了防止用户对同一篇文章进行多次投票，网站需要为每篇文章记录一个已投票用户名单，为此，程序将为每篇文章创建一个集合，并使用这个集合来存储所有已投票用户的 Id

set存储每篇投票的用户Id

```java
key:article:vote:articleId
val:userId
```

为了尽量节约内存，我们规定当一篇文章发布期满一周之后，用户将不能再对它进行投票，文章的评分将被固定下来，而记录文章已投票用户名单的集合也会被删除。



## 登录与Cookie缓存

每当我们登录互联网服务(比如银行账户或者电子邮件)的时候，这些服务都会使用cookie 来记录我们的身份。cookie 由少量数据组成，网站会要求我们的浏览器存储这些数据并在每次服务发送请求时将这些数据传回给服务。对于用来登录的 cookie，有两种常见的方法可以将登录信息存储在 cookie 里面：一种是签名(signed)cookie，另一种是令牌 (token)cookie。

- **签名 cookie** 通常会存储用户名，可能还有用户ID、用户最后一次成功登录的时间，以及网站觉得有用的其他任何信息。除了用户的相关信息之外，签名 cookie 还包含一个签名，服务器可以使用这个签名来验证浏览器发送的信息是否未经改动(比如将 cookie 中的登录用户名改成另一个用户)。
  - 优点：验证cookie所需的一切信息都存储在 cookie里面。cookie可以包含额外的信息(additionalinfomation)，并且对这些信息进行签名也很容易。
  - 缺点：正确地处理签名很难。很容易忘记对数据进行签名，或者忘记验证数据的签名，从而造成安全漏洞
- **令牌 cookie** 会在 cookie 里面存储一串随机字节作为令牌，服务器可以根据令牌在数据库中查找令牌的拥有者。随着时间的推移，旧令牌会被新令牌取代。
  - 优点：添加信息非常容易。cookie 的体积非常小，因此移动终端和速度较慢的客户端可以更快地发送请求；
  - 缺点：需要在服务器中存储更多信息。如果使用的是关系数据库，那么载入和存储 cookie的代价可能会很高。



## 用户和状态

用户对象存储了用户的基本身份标识信息、用户的关注者人数、用户已发布的状态消息数量等信息。

Hash存储用户信息：

```java
key:user:userId
//-------------------------------
login   //
id      //userId?
name		//用户名
follers    //用户拥有的关注者人数
following  //用户正在关注的人的数量
posts      //发帖数
signup		//登录时间
```

登录验证

```java
1.校验提交过来的手机号，是否符合；如果不符合直接返回错误信息；
2.从redis中获取验证码，校验用户的验证码；如果不一致，直接返回错误信息；
3.验证码校验成功，从mysql中查询用户信息，校验用户是否存在；
4.如果用户不存在，创建新的用户并保存；如果存在校验账号信息不存在，返回错误信息
5.将用户信息保存在redis中
5.1生产随机token,作为登入令牌
5.2将User对象转为HashMap存储
5.3存入redis中
5.4设置key有效时间

```

发送验证码

```java
1.校验手机号；如果不符合，直接返回错误信息；
2.生成验证码；
3.保存验证码到redis中，并设置有效时间为2分钟；
4.发送验证码；
5.返回结果；
```

用户签到

```java
1.获取当前用户，当前日期；
2.拼接key，key = USER_SIGN_KEY + userId + 时间戳;
3.计算今天是当前月的第几天，dayOfMonth；
4.获取本月所有签到记录，返回十进制数字record，如果没有返回0；
5.将1左移dayOfMonth后，和签到记录record作与运算；
6.计算二进制中1的个数，记为连续签到天数。
```

## 用户关注

redis中用户关注集合使用set集合，因为只需要存储用户的Id，并且没有顺序。

用户关注Redis结构(set集合)：

```java
key: follow:userId
val: userId
```

用户关注

```java
1. 获取当前登录用户；
2. 创建关注用户的redis key，follow：userId
3. 从redis中查询当前用户的关注集合；
4. 如果存在followUserId，证明是取消关注，则将followUserId从reids和mysql中删除；
5. 如果不存在，表示是关注，则将followUserId加入到redis和mysql中；
```



项目

- Echo 的注册功能是怎么做的

- Echo 的登录认证和授权是怎么做的

- Echo 的发帖操作是怎么做的

- 帖子列表与分页是怎么做的

  帖子列表显示标题、发布时间、用户信息、前2行内容（前多少内容）

- 帖子详情

  根据帖子的Id查询帖子详情（帖子的类容，发帖人信息，帖子的点赞、评论）

  1. 先根据帖子Id查询帖子信息，其中包括了用户的id
  2. 根据用户Id再查询用户信息

- 帖子评论是如何显示的
  评论的目标是可以针对很多中类型，如，帖子、课程、话题

      1. 多级评论结果是一种树形结构，通过在表中`主键id`和`pid字段`实现树形结构的存储，pid默认为0表示一级评论，pid不为0表示对某个评论的回复；
      2. 评论人信息根据`user_id`实现查询，主要是为了避免用户信息更改，造成评论信息不一致问题；
      3. 对于点赞信息根据`like_id`实现查询

  Redis缓存评论，不缓存评论的回复，根据点赞数排行。

  key设计`comments:postId-commentid` 。

  ​

  数据库设计，评论结构是一种树形结构显示

  ```Java
  CREATE TABLE `comments_info` (
    `comment_id` varchar(32) NOT NULL COMMENT '主键id',
    `target_id` varchar(32) NOT NULL COMMENT '帖子id',
    `type` tinyint(1) NOT NULL COMMENT '评论类型：对人评论，对项目评论，对资源评论',
    `pid` varchar(32) DEFAULT '0' NOT NULL COMMENT '父评论的主键Id，默认为0，表示对帖子的评论',
    `to_id` varchar(32) NOT NULL COMMENT '被评论者id，可以是人、项目、资源',
    `from_id` varchar(32) NOT NULL COMMENT '评论者id',
    `like_id` int(11) DEFAULT '0' COMMENT '点赞的数量',
    `content` varchar(512) DEFAULT NULL COMMENT '评论内容',
    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
    PRIMARY KEY (`id`),
    KEY `comment_id` (`comment_id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评论表';
  ```






- 帖子列表

  帖子列表是一页显示10条信息（用户名、用户头像、用户等级、评论内容、点赞），只显示用户的一级评论信息，如果要查看评论的回复，需要再进行查询

- 点赞功能

  需求：

  1. 同一个用户只能点赞一次，在此点赞则取消；
  2. 如果但钱用户已经点赞，则点赞按钮表示已经点赞。

  实现方案：

  1. 给帖子添加isLike字段，表示是否被当前用户点赞；
  2. 修改该点赞功能，利用redis的set集合判断是否被点赞过，未点则加1，已点则减一；
  3. 修改根据Id查询Blog业务，判断当前登录用户是否被点赞过；
  4. 修改分页查询Blog业务，判断当前登录用户是否点赞过

  redis中点赞key设计：key为`post：liked：id`，value为用户id

  点赞`redisTemplate,opsForZSet().add(key,userId.toString(), s,System.currentTimeMillis())`

  查询是否点赞时`score = RedisTemplate.opsForZset().score(key,value)`

  ​

- Echo 的发布评论是怎么做的

- Echo 的私信列表与详情页是怎么做的

- Echo 的发送私信是怎么做的

- Echo 的点赞模块是怎么做的

- Echo 的关注模块是怎么做的

- Echo 的系统通知模块是怎么做的

- Echo 的置顶、加精、删除帖子是怎么做的

- Echo 是如何统计网站数据的

- Echo 的搜索模块是怎么做的

- Echo 是如何支持 MarkDown 的
  ```

  ```