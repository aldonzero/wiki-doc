## 动态规划

### [完全平方数](https://leetcode.cn/problems/perfect-squares)

给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



**思考：**

> 一道比较标准的完全背包题目，背包大小是n，物品是$（1，4，9，16，...,i^2)，其中i^2  \leq n $。

###  [lc 309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

> 定义$dp$数组，表示第$i$天还剩多少现金。
>
> 股票当天的操作状态有：
>
> - 持有股票$dp[i][0]$
> - 卖出股票$dp[i][1]$
> - 保持卖出股票$dp[i][2]$，其中包含了冷冻期
>
> 地推公式：
>
> ```Java
>             //持有股票状态
>             dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
>             //卖出股票状态
>             dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
>             //冷冻期
>             dp[i][2] = dp[i - 1][1];
> ```
>



### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

>与前几道股票相关的题相比主要是限制了交易次数，但是股票的状态还是可以定义：持有股票状态、卖出股票状态两种。
>
>定义dp数组$d[i][j][0] and dp[i][j][1]$表示第$i$天第$j$次在两种操作下还剩多少现金。
>
>状态转移：
>
>- 持有股票状态：
>  - 今天没有买入，由前面持有股票状态转入$dp[i - 1][j][0]$
>  - 今天买入，是由昨天卖出后的状态转入，买入次数加1，$dp[i - 1][j - 1][1] - prices[i]$
>- 卖出股票状态：
>  - 今天没有卖出，由前面卖出状态转入$dp[i - 1][j][1]$
>  - 今天卖出，由于今天的买入状态（包括了前面的买入状态）转入$dp[i ][j][0] + prices[i]$
>
>转移方程：
>
>```java
>        for (int i = 1; i < len; i++) {
>            for (int j = 1; j <= k; j++) {
>                //保持股票状态
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j - 1][1] - prices[i]);
>                //保持卖出状态
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i][j][0] + prices[i]);
>            }
>        }
>```



#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数 **的 **非空 **数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思考：**

>题目中是说分割成两个等和的子集，那么元素和必定是偶数，因此首先判断和是否为偶数。
>
>然后转化为01背包问题(装满背包最大价值是否为target)， 背包大小为$target = sum >> 1$, 物品为数组$nums$，价值数组$nums$，01背包中装满背包容量的最大价值。
>
>```java
>        for (int num : nums) {
>            for (int j = target; j >= num; j--) {
>                dp[j] = Math.max(dp[j], dp[j - num] + num);
>            }
>        }
>```
>
>





## 字符串操作

### 判断字符串类型

- 判断是否是数字

  ```Java
  Character.isDigit(char ch)

  ```

- 判断是否是字母（大小写）

  ```Java 
  Character.isAlphabetic(char ch)
  ```

  ​

