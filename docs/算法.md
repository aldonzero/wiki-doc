## 动态规划

### 背包问题

#### 01背包

有N件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**每种物品仅有一件，可以选择放或不放。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java
for (int i = 0; i < c.length; i++) {
	for (int j = v; j >= c[i]; j--) {
		dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
    }
}

```



#### 完全背包

有N件物品和一个容量为$V$的背包，每种物品都有无限件可用。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**完全背包和01背包的区别是完全背包中的物品可以无限制使用。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = c[i]; j <= v; j++) {
    dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
  }
}
```



>01背包和完全背包的转移方程是相同的，区别在于：
>
>- 01背包是背包内嵌由大到小遍历
>- 完全背包是背包内嵌由小到大遍历



#### 多重背包问题

有$N$种物品和一个容量为$V$的背包。第$i$种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

**基本思路：**和完全背包的区别是，多重背包的物品可以有多个选择但是数量有限制，但是可以降至转换为01背包，将所有的物品全部转换为数量为1的数组。

**核心代码：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = v; j >= c[i]; j--) {
    for (int k = 1; k <= n[i] && j - k * c[i] >= 0; k++) {
      dp[j] = max{dp[j], dp[j - k * c[i]] + k * w[i]};
    }
  }
}
```











### [完全平方数](https://leetcode.cn/problems/perfect-squares)

给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



**思考：**

> 一道比较标准的完全背包题目，背包大小是n，物品是$（1，4，9，16，...,i^2)，其中i^2  \leq n $。

###  [lc 309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

> 定义$dp$数组，表示第$i$天还剩多少现金。
>
> 股票当天的操作状态有：
>
> - 持有股票$dp[i][0]$
> - 卖出股票$dp[i][1]$
> - 保持卖出股票$dp[i][2]$，其中包含了冷冻期
>
> 地推公式：
>
> ```Java
>             //持有股票状态
>             dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
>             //卖出股票状态
>             dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
>             //冷冻期
>             dp[i][2] = dp[i - 1][1];
> ```
>



### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

>与前几道股票相关的题相比主要是限制了交易次数，但是股票的状态还是可以定义：持有股票状态、卖出股票状态两种。
>
>定义dp数组$d[i][j][0] and dp[i][j][1]$表示第$i$天第$j$次在两种操作下还剩多少现金。
>
>状态转移：
>
>- 持有股票状态：
>  - 今天没有买入，由前面持有股票状态转入$dp[i - 1][j][0]$
>  - 今天买入，是由昨天卖出后的状态转入，买入次数加1，$dp[i - 1][j - 1][1] - prices[i]$
>- 卖出股票状态：
>  - 今天没有卖出，由前面卖出状态转入$dp[i - 1][j][1]$
>  - 今天卖出，由于今天的买入状态（包括了前面的买入状态）转入$dp[i ][j][0] + prices[i]$
>
>转移方程：
>
>```java
>        for (int i = 1; i < len; i++) {
>            for (int j = 1; j <= k; j++) {
>                //保持股票状态
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j - 1][1] - prices[i]);
>                //保持卖出状态
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i][j][0] + prices[i]);
>            }
>        }
>```



#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数 **的 **非空 **数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思考：**

>题目中是说分割成两个等和的子集，那么元素和必定是偶数，因此首先判断和是否为偶数。
>
>然后转化为01背包问题(装满背包最大价值是否为target)， 背包大小为$target = sum >> 1$, 物品为数组$nums$，价值数组$nums$，01背包中装满背包容量的最大价值。
>
>```java
>        for (int num : nums) {
>            for (int j = target; j >= num; j--) {
>                dp[j] = Math.max(dp[j], dp[j - num] + num);
>            }
>        }
>```
>
>



## 贪心



#### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

**基本思路：**

判断三个值是否符合差值异号，此题中异号包括正负和零的异号。在用位运算判断异号时，要注意值为零时不能用位运算参与判断。



#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组 **是数组中的一个连续部分。

**基本思路：**

判断$sum + num$和$num$ 的大小，即$sum = max\{sum + num, num\}$



#### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

**基本思路：**

题目换种说法就是要找，非交叠区间的最大数

## 字符串操作

### 判断字符串类型

- 判断是否是数字

  ```Java
  Character.isDigit(char ch)

  ```

- 判断是否是字母（大小写）

  ```Java 
  Character.isAlphabetic(char ch)
  ```

  ​


## 小技巧

### 位运算

#### 判断是否异号

```java 
if ((a ^ b) < 0) //只能判断正负异号，如果有一个值是0判断是不准确的
```



将一个int数组转为数组

```java
char[] chars = String.valueOf(num).toCharArray();
```

将一个char数组转为int

```java
int num = Integer.parseInt(String.valueOf(chars));
```

