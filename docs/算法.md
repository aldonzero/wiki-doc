## 排序算法

### 堆排序

```java

class Solution {
    public int[] sortArray(int[] nums) {
        buildHeap(nums);
        for (int i = nums.length - 1; i > 0; i--) {
            swap(nums, 0, i);
            heapfy(nums, 0, i);
        }
        return nums;
    }
    private void buildHeap(int[] nums) {
        for (int i = nums.length / 2 - 1; i >= 0; i--) {
            heapfy(nums, i, nums.length);
        }
    }
    private void heapfy(int[] nums, int i, int len) {
        int l = i * 2 + 1, r = i * 2 + 2;
        int max = i;
        if (l < len && nums[l] > nums[max]) max = l; 
        if (r < len && nums[r] > nums[max]) max = r;
        if (max != i) {
            swap(nums, i, max);
            heapfy(nums, max, len);
        }
    }
    private void swap(int[] nums, int a, int b) {
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }
}

```

### 归并排序

```java
class Solution {
    int[] tmp;
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        tmp = new int[len];
        mergeSort(nums, 0, len - 1);
        return nums;
    }
    private void mergeSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int mid = l + (r - l) / 2;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        merge(nums, l, r);
    }
    private void merge(int[] nums, int l, int r) {
        int i = l, mid = l + (r - l) / 2, j = mid + 1;
        int k = 0;
        while (i <= mid && j <= r) {
            tmp[k++] = nums[i] < nums[j] ? nums[i++] : nums[j++];
        }
        while (i <= mid) tmp[k++] = nums[i++];
        while (j <= r) tmp[k++] = nums[j++];
        for (i = 0; i < r - l + 1; i++) {
            nums[l + i] = tmp[i];
        }
    }
}
```

### 快速排序

```java
private void quickSort(int[] nums, int l, int r) {
    if (l > r) return;
    int t = nums[l];
    int i = l, j = r;
    while (i < j) {
        //必须先左移右指针
        while (i < j && nums[j] >= t) j--;
        while (i < j && nums[i] <= t) i++;
        if (i < j) swap(nums, i, j);
    }
    //
    nums[l] = nums[i];
    nums[i] = t;
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}

class Solution {
    public int[] sortArray(int[] nums) {
        randomizedQuicksort(nums, 0, nums.length - 1);
        return nums;
    }

    public void randomizedQuicksort(int[] nums, int l, int r) {
        if (l < r) {
            int pos = randomizedPartition(nums, l, r);
            randomizedQuicksort(nums, l, pos - 1);
            randomizedQuicksort(nums, pos + 1, r);
        }
    }

    public int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    public int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 动态规划

### 背包问题

#### 01背包

有N件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**每种物品仅有一件，可以选择放或不放。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java
for (int i = 0; i < c.length; i++) {
	for (int j = v; j >= c[i]; j--) {
		dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
    }
}

```



#### 完全背包

有N件物品和一个容量为$V$的背包，每种物品都有无限件可用。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**完全背包和01背包的区别是完全背包中的物品可以无限制使用。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = c[i]; j <= v; j++) {
    dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
  }
}
```



>01背包和完全背包的转移方程是相同的，区别在于：
>
>- 01背包是背包内嵌由大到小遍历
>- 完全背包是背包内嵌由小到大遍历



#### 多重背包问题

有$N$种物品和一个容量为$V$的背包。第$i$种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

**基本思路：**和完全背包的区别是，多重背包的物品可以有多个选择但是数量有限制，但是可以降至转换为01背包，将所有的物品全部转换为数量为1的数组。

**核心代码：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = v; j >= c[i]; j--) {
    for (int k = 1; k <= n[i] && j - k * c[i] >= 0; k++) {
      dp[j] = max{dp[j], dp[j - k * c[i]] + k * w[i]};
    }
  }
}
```











### [279.完全平方数](https://leetcode.cn/problems/perfect-squares)

给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



**思考：**

> 一道比较标准的完全背包题目，背包大小是n，物品是$（1，4，9，16，...,i^2)，其中i^2  \leq n $。

**代码：**

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int j = 1; j <= n; ++j) { //遍历背包
            for (int i = 1; i * i <= j; ++i) { //遍历物品
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```



### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**基本思路：**

本质是斐波拉契数列 `f(n) = f(n - 1) + f(n - 2)`；

**代码：**

```java
class Solution {
    public int climbStairs(int n) {
        if (n < 3) return n;
        int n1 = 1, n2 = 2, sum = 0;
        for (int i = 3; i <= n; i++) {
            sum = n1 + n2;
            n1 = n2;
            n2 = sum;
        }
        return sum;
    }
}
```



### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

样例：

```sh
# 样例1
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

# 样例2
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

**基本思路：**

题目中一次能爬1个阶梯，或者是2个阶梯，则爬到当前阶梯i的费用 `dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`;

**代码：**

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        if (len < 2) return Math.min(cost[0], cost[1]);
        int[] dp = new int[len + 1];
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[len];
    }
}
```

> 注意：按照样例，这里的i要遍历到len。
>
> ```sh
>                               ____
>                               │ o │
>                       __20____|___|
>                __15__│
>         __10__│
> __起点__│
> ```



###  [lc 309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

> 定义$dp$数组，表示第$i$天还剩多少现金。
>
> 股票当天的操作状态有：
>
> - 持有股票$dp[i][0]$
> - 卖出股票$dp[i][1]$
> - 保持卖出股票$dp[i][2]$，其中包含了冷冻期
>
> 地推公式：
>
> ```Java
>             //持有股票状态
>             dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
>             //卖出股票状态
>             dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
>             //冷冻期
>             dp[i][2] = dp[i - 1][1];
> ```
>



### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

>与前几道股票相关的题相比主要是限制了交易次数，但是股票的状态还是可以定义：持有股票状态、卖出股票状态两种。
>
>定义dp数组$d[i][j][0] and dp[i][j][1]$表示第$i$天第$j$次在两种操作下还剩多少现金。
>
>状态转移：
>
>- 持有股票状态：
>  - 今天没有买入，由前面持有股票状态转入$dp[i - 1][j][0]$
>  - 今天买入，是由昨天卖出后的状态转入，买入次数加1，$dp[i - 1][j - 1][1] - prices[i]$
>- 卖出股票状态：
>  - 今天没有卖出，由前面卖出状态转入$dp[i - 1][j][1]$
>  - 今天卖出，由于今天的买入状态（包括了前面的买入状态）转入$dp[i ][j][0] + prices[i]$
>
>转移方程：
>
>```java
>        for (int i = 1; i < len; i++) {
>            for (int j = 1; j <= k; j++) {
>                //保持股票状态
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j - 1][1] - prices[i]);
>                //保持卖出状态
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i][j][0] + prices[i]);
>            }
>        }
>```



### [ 740. 打家劫舍IV（删除并获得点数）](https://leetcode.cn/problems/delete-and-earn/)

给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

**样例：**

```sh
# 示例 1：
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

# 示例 2：
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
 

# 提示：
1 <= nums.length <= 2 * 104
1 <= nums[i] <= 104
```



**基本思路：**

在选择了元素 x 后，该元素以及所有等于 x −1 或 x + 1 的元素会从数组中删去。若还有多个值为 x 的元素，由于所有等于 x - 1 或x + 1 的元素已经被删除，我们可以直接删除 x 并获得其点数。因此若选择了 x，所有等于 x 的元素也应一同被选择，以尽可能多地获得点数。

记元素 x 在数组中出现的次数为 cx ，我们可以用一个数组 sum 记录数组 nums 中所有相同元素之和，即 sum[x]=x⋅cx 。若选择了 x，则可以获取 sum[x] 的点数，且无法再选择 x - 1 和x+1。

**代码：**

```java
public int deleteAndEarn(int[] nums) {
    int[] arr = new int[10001];
    for (int i = 0; i < nums.length; i++) {
        arr[nums[i]] += nums[i];
    }
    int[] dp = new int[10001];
    dp[0] = 0;
    dp[1] = arr[1];
    for (int i = 2; i < 10001; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + arr[i]);
    }
    return dp[arr.length - 1];
}
```





### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数 **的 **非空 **数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思考：**

>题目中是说分割成两个等和的子集，那么元素和必定是偶数，因此首先判断和是否为偶数。
>
>然后转化为01背包问题(装满背包最大价值是否为target)， 背包大小为$target = sum >> 1$, 物品为数组$nums$，价值数组$nums$，01背包中装满背包容量的最大价值。
>
>```java
>        for (int num : nums) {
>            for (int j = target; j >= num; j--) {
>                dp[j] = Math.max(dp[j], dp[j - num] + num);
>            }
>        }
>```
>
>

### [926. 将字符串翻转到单调递增](https://leetcode.cn/problems/flip-string-to-monotone-increasing/)

给定一个字符串，只由0和1组成，可以将任何 `0` 翻转为 `1` 或者将 `1` 翻转为 `0` 。

求需要操作多少次可以将字符串变成递增序列。

**基本思路：**

题目中说有两种字符，0和1：

- 当前字符为1时，对操作次数没有影响；

- 当前字符为0时，从[0, i]范围的最小操作次数为`min(oneCnt, ans + 1)` 

  oneCnt表示前i- 1个字符有多少个字符为1，ans表示前i - 1个字符需要翻转多少次，那么从ans+1表示将当前字符变为1，ontCnt表示将前面所有字符为1的字符变为0需要操作的次数。

代码：

```java
class Solution {
  public int minFlipsMonoIncr(String s) {
      int ans = 0, cnt = 0;
      for (int i = 0; i < s.length(); i++) {
          if (s.charAt(i) == '1') {
              cnt++;
          } else {
              ans = Math.min(ans + 1, cnt);
          }
      }
      return ans;
  }
}
```



### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**样例：**

```bash
# 示例 1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

# 示例 2：
输入：s = "cbbd"
输出："bb"
 
# 提示：
1 <= s.length <= 1000
s 仅由数字和英文字母组成
```

**基本思路：**

判断一个字符是否是回文字符串：

1. 最外层字母相等$s[i] == s[j]$
2. $j - i < 3$，例如aa, aba等
3. 字符串$s[i + 1, j - 1]$是回文字符串

**代码：**

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int maxLen = 0, l = 0, r = 0;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i < 3 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        if (j - i + 1 > maxLen) {
                            maxLen = j - i + 1;
                            l = i;
                            r = j;
                        }
                    }
                }
            }
        }
        return s.substring(l, r + 1);
    }
}
```



### [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。

返回符合要求的 **最少分割次数** 。

**样例：**

```sh
# 示例 1：
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。

# 示例 2：
输入：s = "a"
输出：0

# 示例 3：
输入：s = "ab"
输出：1

# 提示：
1 <= s.length <= 2000
s 仅由小写英文字母组成
```



**基本思路：**

题目中要求分割字符串，要求字串全是回文字符串，而且要求次数最小。

定义$f[r]$表示字符串$[0, r]$按照要求分割字符串的最小次数，那么有转移方程：

- 当字符串$[0, r]$是回文字符串时，$f[r] = 0$ ;
- 当字符串$[0, r]$不是回文字符串时，则找一个点使得字符串$[0, l - 1]和[l, r]$都是回文字符串并且字符串$[0, l - 1]$的分割次数最小，$f[r] = min \{f[r], f[l - 1] + 1 \}$。 

**代码：**

```java
class Solution {
    public int minCut(String s) {
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i < 3 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                    }
                }
            }
        }

        int[] f = new int[len];
        for (int r = 0; r < len; r++) {
            if (dp[0][r]) {
                f[r] = 0;
            } else {
                f[r] = r;
                for (int l = 0; l <= r; l++) {
                    if (dp[l][r]) {
                        f[r] = Math.min(f[r], f[l - 1] + 1);
                    }
                }
            }
        }
        return f[len - 1];
    }
}
```



### [1278. 分割回文串 III](https://leetcode.cn/problems/palindrome-partitioning-iii/)

给你一个由小写字母组成的字符串 s，和一个整数 k。

请你按下面的要求分割字符串：

首先，你可以将 s 中的部分字符修改为其他的小写英文字母。
接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。
请返回以这种方式分割字符串所需修改的最少字符数。

```sh
# 示例 1：
输入：s = "abc", k = 2
输出：1
解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。

# 示例 2：
输入：s = "aabbc", k = 3
输出：0
解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。

# 示例 3：
输入：s = "leetcode", k = 8
输出：0

# 提示：
1 <= k <= s.length <= 100
s 中只含有小写英文字母。
```



**基本思路：**

将题目简单转换，将i个字符串分割成k个字串的最小代价。

则可以用`dp[i][k]`表示字符串[0,i]的字符分割成k个回文，需要修改的最小次数，可以将字符串分为`[0, j - 1]`和`[j, i]`两个部分，则字符串`[0, j - 1]`分割为k - 1个回文子串加上字符串`[j, i]`变为回文的最小修改次数，结果就是符串[0,i]的字符分割成k个回文的最小修改次数。

相应的转移方程：`dp[i][k] = min{dp[i][k], dp[j - 1][k - 1] + cost[j][i]}` ，其中`cost[j][i]`表示字符串`[j, i]`变为回文字符串的最小修改次数。

**代码：**

```java
class Solution {
    public int palindromePartition(String s, int k) {
        int len = s.length();

        //cost[i][j]：表示字符串[i, j]变为回文字符串，需要修改的最小次数。
        int[][] cost = new int[len][len];
        for (int j = 1; j < len; j++) {
            for (int i = j - 1; i >= 0; i--) {
                cost[i][j] = cost[i + 1][j - 1] + (s.charAt(i) == s.charAt(j) ? 0 : 1);
            }
        }

        int[][] dp = new int[len][k];
        for (int i = 0; i < len; i++) {
            dp[i][0] = cost[0][i];
        }

        //dp[i][K]：表示字符串[0,i]的字符分割成K个回文，需要修改的最小次数
        for (int i = 0; i < len; i++) {
            for (int K = 1; K < k; K++) {
                dp[i][K] = Integer.MAX_VALUE;
                for (int j = i; j >= K; j--) {
                    //dp[j - 1][K - 1]：表示字符串[0, j - 1]的字符分割成K- 1个回文的最小次数
                    //cost[j][i]：表示字符串[j, i]变成回文需要修改的最小次数。
                    dp[i][K] = Math.min(dp[i][K], dp[j - 1][K - 1] + cost[j][i]);
                }
            }
        }
        return dp[len - 1][k - 1];
    }
}
```





### [1745. 回文串分割 IV](https://leetcode.cn/problems/palindrome-partitioning-iv/)

给你一个字符串 s ，如果可以将它分割成三个 非空 回文子字符串，那么返回 true ，否则返回 false 。

当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。

样例：

```sh
# 示例 1：
输入：s = "abcbdd"
输出：true
解释："abcbdd" = "a" + "bcb" + "dd"，三个子字符串都是回文的。

# 示例 2：
输入：s = "bcbddxy"
输出：false
解释：s 没办法被分割成 3 个回文子字符串。
 

提示：
3 <= s.length <= 2000
s只包含小写英文字母。


```

**基本思路：**

要将字符串分割成3个回文字符串则结果为：回文字符串[0, i - 1]，回文字符串[i, j]，回文字符串[j + 1, n - 1]。

- 先用$dp[i ][j]$记录字符串$[i, j]$是否是回文字符串；
- 遍历位置$[i, j]$直到$dp[0, i - 1] 、dp[i, j]、dp[j + 1, n - 1]$均为回文字符串。

**代码：**

```java
class Solution {
    public boolean checkPartitioning(String s) {
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i < 3 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                    }
                }
            }
        }

        for (int i = 1; i < len - 1; i++) {
            for (int j = i; j < len - 1; j++) {
                if (dp[0][i - 1] && dp[i][j] && dp[j + 1][len - 1]) {
                    return true;
                }
            }
        }
        return false;
    }
}
```



### [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

**样例**

```sh
# 示例 1：
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

# 示例 2：
输入：triangle = [[-10]]
输出：-10
 
提示：
1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104
 

# 进阶：
你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？
```

**基本思路：**

题目中第j行的第i的位置可以由第j + 1行的第i和第i + 1位置得到，求最小路径和。和二叉树的最小路径和，只是节点没有表示出左右自节点，因此需要存储叶子节点到当前位置的最小路径和。

**代码：**

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) return 0;
      //每层加1，第一层一个元素，因此层数和每层包含元素数量相同。
        int[] dp = new int[triangle.size() + 1];

        for (int i = triangle.size() - 1; i >= 0; i--) {
            List<Integer> list = triangle.get(i);
            for (int j = 0; j < list.size(); j++) {
                dp[j] = Math.min(dp[j], dp[j+1]) + list.get(j);
            }
        }
        return dp[0];
    }
}
```

## 滑动窗口

### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回 *数组中连续 1 的最大个数* 。

```sh
# 示例 1：
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。

# 示例 2：
输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。

# 提示：
1 <= nums.length <= 105
nums[i] 不是 0 就是 1
0 <= k <= nums.length
```

**基本思路：**

遇见0便将它翻转为1，但是此时可能会超过k，因此当翻转的0超过了k，需要将左边收缩。收缩的时候会出现2种情况：

1. 左边nums[l]的值为1，则直接将l向右边移动1位，相当于用一个1抵消一个0；
2. 左边nums[l]的值为0，则将l向右边移动1位，此时会减少一个翻转的0；

总之，遇见0便翻转，维持一个最大翻转窗口k。

**代码：**

```java
class Solution {
public int longestOnes(int[] nums, int k) {
    int len = nums.length, l = 0, r = 0, cnt = 0;
    while (r < len) {
        if (nums[r] == 0) cnt++;
        r++;
        if (cnt > k) {
            if (nums[l] == 0) cnt--;
            l++;
        }
    }
    return r - l;
}
}
```





## 二分

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

样例：

```sh
# 示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

# 示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

# 示例 3：
输入：nums = [], target = 0
输出：[-1,-1]
 
# 提示：
0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109
```

**代码：**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l = binnarySearch(nums, target);
        if (l >= nums.length || nums[l] != target) {
            return new int[]{-1, -1};
        }
        return new int[]{l, binnarySearch(nums, target + 1) - 1};
    }
    private int binnarySearch(int[] nums, int target) {
        int len = nums.length;
        int l = 0, r = len, mid = l + (r - l) / 2;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (target > nums[mid]) l = mid + 1;
            else r = mid;
        }
        return l;
    }
}
```



## 回溯

**去重：**

1. 如果是要找出每个数字在每个组合种只能使用一次，则需要先进行排序。（注：子集问题）

   ```java
   if(start < i &&  vis[i] == vis[i - 1]){
     continue;
   }

   ```

2. 排列不重复。

   ```java
   if( i > 0 && vis[i - 1] == false && nums[i] == nums[i - 1]){
     continue;
   }
   ```

#### [18. 四数之和](https://leetcode.cn/problems/4sum/)



给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

 

**样例：**

```sh
# 示例 1：
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

# 示例 2：
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
 
# 提示：
1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109
```



**基本思路：**

可以看作是从数组中选择有限数据，但是要去重（可以看作是有数量限制全排列，去重）。

**代码：**

```java
class Solution {
    //无重复的有数量限制的排列
    List<List<Integer>> ans = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    boolean[] vis;
    public List<List<Integer>> fourSum(int[] nums, int target) {
        if (nums.length < 4) return ans;
        vis = new boolean[nums.length];
        Arrays.sort(nums);
        backTrack(nums, 0, 0L, target);
        return ans;
    }

    private void backTrack(int[] nums, int start,  long sum, int target) {
      //此处不能写成path.size() == 4 && sum == target，因为当path个数达到4的时候，后面不能再添加数据了。
        if (path.size() == 4) {
            if (sum == target){
                ans.add(new ArrayList<Integer>(path));
            }
            return;
        }
        for (int i = start; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && vis[i - 1] == false) continue;
            if (nums[i] > 0 && sum + nums[i] > target) return;
            path.add(nums[i]);
            vis[i] = true;
            backTrack(nums, i + 1, sum + nums[i], target);
            vis[i] = false;
            path.remove(path.size() - 1);
        }
    }

}
```





## 贪心



### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

**基本思路：**

判断三个值是否符合差值异号，此题中异号包括正负和零的异号。在用位运算判断异号时，要注意值为零时不能用位运算参与判断。



### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组 **是数组中的一个连续部分。

**基本思路：**

判断$sum + num$和$num$ 的大小，即$sum = max\{sum + num, num\}$



### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

**基本思路：**

题目换种说法就是要找，非交叠区间的最大数





## 字符串操作

### 字符串操作1(贪心)

给定一个只包含小写字母字符串，每次可以选择两个相同的字符删除，并在字符串结尾新增任意一个小写字母。
请问最少多少次操作后，所有的字母都不相同？

> 输入例子：
>
> ```
> "abab"
> ```
>
> 输出例子：
>
> ```
> 2
>
> ```
>
> 例子说明：
>
> ```
> 第一次操作将两个'a'变成一个'f'，字符串变成"bbf"。
> 第二次操作将两个'b'变成一个'b'，字符串变成"fb"。
> 操作方式不是唯一的，但可以证明，最少操作次数为2。
> ```

**思路：**

- 只要存在字母相同，就将之变为其他一个不相同的字母，操作次数`cnt`加一；
- 对操作次数`cnt`判断
  - 字符串长度`len- cnt > 26` ,表明需要的相异字符超过了26，那么超过的字符每一个便要进行一次变换操作，最终结果为 `len - 26`
  - `len- cnt <= 26` ,表明需要的相异字符小于26个，一轮变换就能成功，最终结果 `cnt`

**关键代码：**

```java
public int minOperations (String str) {
        // write code here
        int[] chars = new int[26];
        int len = str.length();
        int cnt = 0;
        for (char ch : str.toCharArray()) {
            if (chars[ch - 'a'] == 1) {
                cnt++;
                chars[ch - 'a'] = 0;
            } else chars[ch - 'a'] = 1;
        }
        return len - cnt > 26 ? len - 26 : cnt;
}
```

## 链表

### [剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/)

给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

样例：

```sh
# 示例1
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]

# 示例2：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[8,0,7]

# 示例3：
输入：l1 = [0], l2 = [0]
输出：[0]
```

**基本思路：**

模拟加法，用一个常量表示加法进位。但是链表是从头遍历到尾，而加法是从右对齐加到左，所以需要将链表倒序或者用栈的方式从右取到左。

**代码：**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
        ListNode dummy = new ListNode(), p = dummy;
        int sum = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 == null ? 0 : l1.val;
            int n2 = l2 == null ? 0 : l2.val;
            sum += n1 + n2;
            p.next = new ListNode(sum % 10);
            p = p.next;
            sum /= 10;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (sum != 0) p.next = new ListNode(sum);
        return reverse(dummy.next);
    }

    //翻转链表
    private ListNode reverse(ListNode root) {
        ListNode curr = root, pre = null;
        while (curr != null) {
            ListNode tmp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = tmp;
            
        }
        return pre;
    }
}
```

使用栈的方式：

```java
class Solution {
    ListNode ans = new ListNode(0);
    int model = 0;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> stack1 = new Stack<Integer>();
        Stack<Integer> stack2 = new Stack<Integer>();
        while (l1 != null) {
            stack1.push(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            stack2.push(l2.val);
            l2 = l2.next;
        }
        while (!stack1.isEmpty() || !stack2.isEmpty() || model != 0) {
            int sum = model;
            if (!stack1.isEmpty()) sum += stack1.pop();
            if (!stack2.isEmpty()) sum += stack2.pop();
            ListNode curr = new ListNode(sum % 10,ans.next);
            model = sum / 10;
            ans.next = curr;
        }
        return ans.next;
    }
}
```





## 树

### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

关键在于，找到删除节点t后：

1. 若`t.right == null`,则用`t.left`顶替t
2. 若`t.left == null`，则用`t.right`顶替t
3. t的左右节点均不为`null`，将`t.left`连接到`t.right`的最左叶子节点，用`t.right`顶替t

**1. 递归方法**

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right =  deleteNode(root.right, key);
        else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode tmp = root.right;
            while (tmp.left != null) tmp = tmp.left;
            tmp.left = root.left;
            return root.right;
        }
        return root;
    }
}
```

**2. 迭代的方法：**

迭代的方法相对于递归，要注意删除是左节点还是右节点，需要使用`pre.left`和`pre.right`指向下一个要删除的节点，和链表删除类似。

```java 
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode dummy = new TreeNode(1), pre = dummy;
        pre.right = root;
        //找到目标节点
        while (root != null){
            if (pre.left != null && pre.left.val == key) {
                pre.left = getNext(pre.left);
                return dummy.right;
            }
            if (pre.right != null && pre.right.val == key) {
                pre.right = getNext(pre.right);
                return dummy.right;
            }
            if (key < root.val) {
                pre = root;
                root = root.left;
                
            } else if (key > root.val) {
                pre = root;
                root = root.right;
            } 
        }
        return dummy.right;
    }

    private TreeNode getNext(TreeNode root) {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        
        TreeNode tmp = root.right;
        while (tmp.left != null) tmp = tmp.left;
        tmp.left = root.left;
        return root.right;
    }

}
```

### 二叉树前中后遍历

前序遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        TreeNode cur = root, p = null;
        Stack<TreeNode> st = new Stack<>();
        while (!st.isEmpty() || cur != null) {
            while(cur != null) {
                ans.add(cur.val);
                st.push(cur);
                cur = cur.left;
            }
            cur = st.pop();
            cur = cur.right;
        }
        return ans;
    }
}
```



中序非递归遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> st = new Stack<>();
        TreeNode cur = root, p = null;
        while (!st.isEmpty() || cur != null) {
            while (cur != null) {
                st.push(cur);
                cur = cur.left;
            }
            cur = st.pop();
            ans.add(cur.val);
            cur = cur.right;
        }
        return ans;
    }
}
```



后序非递归遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> st = new Stack<>();
      //cur表示当前节点，p表示前一个节点
        TreeNode cur = root, p = null;

        while(!st.isEmpty() || cur != null) {
            while (cur != null) {
                st.push(cur);
                cur = cur.left;
            }
            cur = st.peek();
            //如果是未访问过的最左节点，或者是
            if (cur.right == null || cur.right == p) {
                ans.add(cur.val);
                st.pop();
                p = cur;
                cur = null;
            } else {
                cur = cur.right;
            }
        }
        return ans;
    }
}
```



## 区间

### 区间交集个数

#### [2409. 统计共同度过的日子数](https://leetcode.cn/problems/count-days-spent-together/)

计算区间[a,b]和区间[c,d]相交的个数。

```java
int cnt = min(b, d) - max(a, c);
int ans = max(cnt, 0);
```

## 前缀和&差分

**差分数组**的主要适用场景是频繁对原始数组的某个**区间**的元素进行**相同的增减**。

差分数组`d[i]`表示的是数组相邻元素之间的差值，即`d[i] = arr[i] - arr[i - 1]`。

针对数组的某一区间进行相同的加减，可以用区间的端点进行记录，如。

| 数组下标      | 0    | 1    | 1    | 2    | 4    | 5    | 6    | 7    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 原始数组      | 5    | 2    | 5    | 4    | 9    | 7    | 10   | 0    |
| 原始d[i]    | 5    | -3   | 3    | -1   | 5    | -2   | 3    | -10  |
| 区间[1,4]+3 | 5    | 0    | 3    | -1   | 5    | -5   | 3    | 0    |
| ans[i]    | 5    | 5    | 8    | 7    | 12   | 7    | 10   | 0    |

对区间[1，4]之间的元素加3，则将`d[1] += 3，d[4 + 1]  -= 3` 。

对某个左闭右闭区间`[i, j]`加m， 即`d[i] += m, d[j + 1] -= m` 。

对某个左闭右闭区间`[i, j)`加m， 即`d[i] += m, d[j] -= m` 。

#### [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

样例：

```sh
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```

**思路：**

直接使用差分模板记录区间要加减的值，再使用前缀和对差分数组计算值。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] d = new int[n];
        for(int[] b : bookings) {
            d[b[0] - 1] += b[2];
            if (b[1] < n) {
                d[b[1]] -= b[2];
            }
        }
        for (int i = 1; i < n; i++) {
            d[i] += d[i - 1];
        }
        return d;
    }
}
```



#### [1094. 拼车](https://leetcode.cn/problems/car-pooling/)

车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）

给定整数 capacity 和一个数组 trips ,  trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。

样例：

```sh
## 样例1
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
## 样例2
输入：trips = [[2,1,5],[3,5,7]], capacity = 4
输出：true
```

**思路：**

和[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)几乎一样，只是下标和区间有所不同，此题的区间是左闭右开的，因为再同一站点可以先下后上。

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] d = new int[1001];
        for (int[] trip : trips) {
            d[trip[1]] += trip[0];
            d[trip[2]] -= trip[0];
        }
        long sum = 0;
        for (int i = 0; i < 1001; i++) {
            sum += d[i];
            if (sum > capacity) return false;
        }
        return true;
    }
}
```

#### [798. 得分最高的最小轮调](https://leetcode.cn/problems/smallest-rotation-with-highest-score/)

给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 > 0 [不计分]、3 > 1 [不计分]、0 <= 2 [计 1 分]、2 <= 3 [计 1 分]，4 <= 4 [计 1 分]。
在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 

```sh
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
```



**思路：**

索引为i时, nums[i] 在k为 `[(i + 1) mod length, (length - nums[i] + i) mod length]` 时当前值可以获得得分, length为数组长度。

```java
class Solution {
    public int bestRotation(int[] nums) {
        int n = nums.length;
        int[] d = new int[n];
        for (int i = 0; i < n; i++) {
            int l = (i + 1) % n;
            int r = (i - nums[i] + n + 1) % n;
            d[l] += 1;
            d[r] -= 1;
            //若[l, r]跨越右边界，则[0, l - 1]要加1
            if (l >= r) d[0] += 1;
        }
        int maxScore = d[0], selI = 0;;
        for (int i = 1; i < n; i++) {
            d[i] += d[i - 1];
            if (d[i] > maxScore) {
                selI = i;
                maxScore = d[i];
            }
        }
        return selI;
    }
}
```



## 哈希

### [720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)

给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。

若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

样例：

```sh
# 示例 1：
输入：words = ["w","wo","wor","worl", "world"]
输出："world"
解释： 单词"world"可由"w", "wo", "wor", 和 "worl"逐步添加一个字母组成。

# 示例 2：
输入：words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出："apple"
解释："apply" 和 "apple" 都能由词典中的单词组成。但是 "apple" 的字典序小于 "apply" 
```

**基本思路：**

题目中右两点要求：

1. 每个单词的前[0, i - 1]部分都在数组重出现；
2. 存在多个答案时，返回答案中字典序最小的单词。

因此，将单词数组进行排序，排序规则为：

1. 长度由小到大；
2. 当单词长度相同时，将单词按照字典序由大到小排序。

将单词数组排好序后，若是hash中存在单词的前[0, i - 1]的单词，则将当前单词s加入到hash中，单词s就是当前最佳答案。

**代码：**

```java
class Solution {
    public String longestWord(String[] words) {
        Arrays.sort(words, (o1, o2) -> {
            if (o1.length() != o2.length()) {
                return o1.length() - o2.length();
            } else {
                return o2.compareTo(o1);
            }
        });
        String ans = "";
        HashSet<String> set = new HashSet<>();
        set.add("");
        for (String s : words) {
            if (set.contains(s.substring(0, s.length() - 1))) {
                set.add(s);
                ans = s;
            }
        }
        return ans;
    }
}
```



## 二分

### 查找第一个大于等于target的元素的位置

```java
private int binarySearch(int[] nums, int r, int target) {
    int l = 0, mid = 0;
    while (l < r) {
        mid = l + (r - l) / 2;
        if (target <= nums[mid]) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

### 

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```bash
# 示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

# 示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

# 示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1

# 提示：
1 <= nums.length <= 2500

-104 <= nums[i] <= 104

```



**思路一：**

1. 定义数组$dp[i]$表示，数组$[0, i]$中递增子序列最长长度；
2. 要寻找递增子序列最长长度，需要判断当前$num[i]$的值是否大于子序列$[0,j]，j < i$中$nums[j]$的值：
   - 如果$nums[i]$大于子序列$nums[j]$，则$dp[i] = dp[j] + 1$；
   - 否则，$dp[i] = dp[i]$

**代码：**

```jav
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len];
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < len; i++) {
            dp[i] = 1;
            for(int j = 0; j < i; j++) {
                if (nums[i] > nums[j] && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }

}
```



**思路二：**

1. 由于只是寻找子序列的最长长度，因此可以用一个数组$arr$暂存当前的最长子序列；
2. 如果当前$nums[i]$大于$arr[tail]$，表明当前值可以和前面的最长子序列构成新的最长递增子序列；
3. 否则，需要在$arr$数组中找到第一个大于等于$nums[i]$的值，并替换$arr$数组中的值；

> 注意：替换虽然不会影响递增子序列的最长长度，当时会影响子序列的内容，数组arr中存储的并不是递增最长子序列

例，nums = [5,6,7,1,2,3,4,5]，在前3个数构成的递增最长子序列为$arr=[5,6,7]$，所有数构成的递增最长子序列为$[1,2,3,4,5]$。

当$i = 3$时， $arr=[1,6,7]$

当$i = 4$时， $arr=[1,2,7]$

当$i = 5$时， $arr=[1,2,3]$

当$i = 6$时， $arr=[1,2,3,4]$

当$i = 6$时， $arr=[1,2,3,4,5]$

**代码：**

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int[] arr = new int[len];
        int tail = 0;
        arr[tail] = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] > arr[tail]) {
                arr[++tail] = nums[i];
            } else {
                int index = first(arr, tail, nums[i]);
                arr[index] = nums[i];
            }
        }
        return tail + 1;
    }
    /**
    寻找第一个大于等于target的位置
     */
    private int first(int[] nums, int r, int target) {
        int l = 0, mid = 0;
        while (l < r) {
            mid = (l + r) >>> 1;
            if (target <= nums[mid]) r = mid;
            else l = mid + 1;
        }
        return l;
    }
}
```



## 数学

### 质数

#### 判断质数

```java
private boolean isPrime(int num) {
    int max = (int)Math.sqrt(num);
    for (int i = 2; i <= max; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}
```

#### 计算整数n前有多少个非负素数

**思路：**

埃氏筛法：

1. 初始化长度 O(n) 的标记数组，表示这个数组是否为质数。数组初始化所有的数都是质数.
2. 从 2 开始将当前数字的倍数全都标记为合数。标记到$\sqrt{n}$时停止即可。

**代码：**

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int i = 2; i * i <= n; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= n; j+=i) {
                    prime[j] = false;
                }
            }
        }

        int ans = 0;
        for (int i = 2; i < n; i++) {
            if (prime[i]) ans++;
        }
        return ans;
    }
}
```



### 摩尔投票

找出数组中的众数

```java
private int (int[] nums) {
  int m = 0, cnt = 0;
  for (int num : nums) {
    if (cnt == 0) {
      m = num;
    }
    cnt = num == m ? cnt++ : cnt--;
  }
  return m;
}
```



## 小技巧

### 位运算

#### 判断是否异号

```java 
if ((a ^ b) < 0) //只能判断正负异号，如果有一个值是0判断是不准确的
```



将一个int数组转为数组

```java
char[] chars = String.valueOf(num).toCharArray();
```

将一个char数组转为int

```java
int num = Integer.parseInt(String.valueOf(chars));
```

#### 大小写转换

- `c = c | 32`利用**或运算**将这个字母转化为小写字母
- `c = c & ~32` 利用**与运算**将这个字母转化为大写字母
- `c = c ^ 32` 利用**异或运算**将字母大小写互换，即大写转小写，小写转大写

> **注意：**大小写转换只是针对字母，在转换前首先要对符判断是否是字母。
>
> ```java
> Character.isAlphabetic(ch)
> ```

### 快速幂

二分思路
$$
a^n =   \begin{cases}
               a^{n - 1} * a , & \text{if $n$ is odd} \\[2ex]
                a^{\frac{n}{2}} * a^{\frac{n}{2}},        & \text{if $n$ is even but not 0}  \\
                1, &\text{if n is  0}
       	 \end{cases}
$$
Java代码：

```java
private int qpow(int a, int n) {
    int ans = 1;
    while (n != 0) {
        if ((n & 1) == 1) {
            ans = ans * a;
        }
        a = a* a;
      //无符号右移动，排除n是负数的情况
        n >>>= 1;
    }
    return ans;
}
```



### 快速位运算

```java
int bitCnt(int n) {
  int cnt = 0;
  while (n > 0) {
    n = n & (n - 1); //消除低位1
    cnt++;
  }
  return cnt;
}
```

### int[]数组排序

```java
Arrays.stream(nums).boxed().sorted(new Comparator<Integer>()) {
  public int compare(Integer o1, Integer o2) {
    int cnt1 = bitCnt(o1);
    int cnt2 = bitCnt(o2);
    return (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);
  }.mapToInt(Integer::intValue).toArray();
}
```

List<Integer>转换成int[] 数组

```java
List<Integer> ans = new ArrayList<Integer>();
int[] nums = ans.stream().mapToInt(Integer::intValue).toArray();
```

