## 排序算法

### 快速排序

```java
private void quickSort(int[] nums, int l, int r) {
    if (l > r) return;
    int t = nums[l];
    int i = l, j = r;
    while (i < j) {
        //必须先左移右指针
        while (i < j && nums[j] >= t) j--;
        while (i < j && nums[i] <= t) i++;
        if (i < j) swap(nums, i, j);
    }
    //
    nums[l] = nums[i];
    nums[i] = t;
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}

class Solution {
    public int[] sortArray(int[] nums) {
        randomizedQuicksort(nums, 0, nums.length - 1);
        return nums;
    }

    public void randomizedQuicksort(int[] nums, int l, int r) {
        if (l < r) {
            int pos = randomizedPartition(nums, l, r);
            randomizedQuicksort(nums, l, pos - 1);
            randomizedQuicksort(nums, pos + 1, r);
        }
    }

    public int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    public int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 动态规划

### 背包问题

#### 01背包

有N件物品和一个容量为$V$的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**每种物品仅有一件，可以选择放或不放。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java
for (int i = 0; i < c.length; i++) {
	for (int j = v; j >= c[i]; j--) {
		dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
    }
}

```



#### 完全背包

有N件物品和一个容量为$V$的背包，每种物品都有无限件可用。第$i$件物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使价值总和最大。

**基本思路：**完全背包和01背包的区别是完全背包中的物品可以无限制使用。

定义$dp$数组，$dp[j]$表示前$i$种物品放入背包容量为$j$的背包中，获得的最大价值。

**转移方程：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = c[i]; j <= v; j++) {
    dp[j] = max{dp[j], dp[j - c[i]] + w[i]}
  }
}
```



>01背包和完全背包的转移方程是相同的，区别在于：
>
>- 01背包是背包内嵌由大到小遍历
>- 完全背包是背包内嵌由小到大遍历



#### 多重背包问题

有$N$种物品和一个容量为$V$的背包。第$i$种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

**基本思路：**和完全背包的区别是，多重背包的物品可以有多个选择但是数量有限制，但是可以降至转换为01背包，将所有的物品全部转换为数量为1的数组。

**核心代码：**

```java 
for (int i = 0; i < c.length; i++) {
  for (int j = v; j >= c[i]; j--) {
    for (int k = 1; k <= n[i] && j - k * c[i] >= 0; k++) {
      dp[j] = max{dp[j], dp[j - k * c[i]] + k * w[i]};
    }
  }
}
```











### [完全平方数](https://leetcode.cn/problems/perfect-squares)

给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



**思考：**

> 一道比较标准的完全背包题目，背包大小是n，物品是$（1，4，9，16，...,i^2)，其中i^2  \leq n $。

###  [lc 309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

> 定义$dp$数组，表示第$i$天还剩多少现金。
>
> 股票当天的操作状态有：
>
> - 持有股票$dp[i][0]$
> - 卖出股票$dp[i][1]$
> - 保持卖出股票$dp[i][2]$，其中包含了冷冻期
>
> 地推公式：
>
> ```Java
>             //持有股票状态
>             dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
>             //卖出股票状态
>             dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
>             //冷冻期
>             dp[i][2] = dp[i - 1][1];
> ```
>



### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思考：**

>与前几道股票相关的题相比主要是限制了交易次数，但是股票的状态还是可以定义：持有股票状态、卖出股票状态两种。
>
>定义dp数组$d[i][j][0] and dp[i][j][1]$表示第$i$天第$j$次在两种操作下还剩多少现金。
>
>状态转移：
>
>- 持有股票状态：
>  - 今天没有买入，由前面持有股票状态转入$dp[i - 1][j][0]$
>  - 今天买入，是由昨天卖出后的状态转入，买入次数加1，$dp[i - 1][j - 1][1] - prices[i]$
>- 卖出股票状态：
>  - 今天没有卖出，由前面卖出状态转入$dp[i - 1][j][1]$
>  - 今天卖出，由于今天的买入状态（包括了前面的买入状态）转入$dp[i ][j][0] + prices[i]$
>
>转移方程：
>
>```java
>        for (int i = 1; i < len; i++) {
>            for (int j = 1; j <= k; j++) {
>                //保持股票状态
>                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j - 1][1] - prices[i]);
>                //保持卖出状态
>                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i][j][0] + prices[i]);
>            }
>        }
>```



#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数 **的 **非空 **数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思考：**

>题目中是说分割成两个等和的子集，那么元素和必定是偶数，因此首先判断和是否为偶数。
>
>然后转化为01背包问题(装满背包最大价值是否为target)， 背包大小为$target = sum >> 1$, 物品为数组$nums$，价值数组$nums$，01背包中装满背包容量的最大价值。
>
>```java
>        for (int num : nums) {
>            for (int j = target; j >= num; j--) {
>                dp[j] = Math.max(dp[j], dp[j - num] + num);
>            }
>        }
>```
>
>



## 贪心



#### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

**基本思路：**

判断三个值是否符合差值异号，此题中异号包括正负和零的异号。在用位运算判断异号时，要注意值为零时不能用位运算参与判断。



#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组 **是数组中的一个连续部分。

**基本思路：**

判断$sum + num$和$num$ 的大小，即$sum = max\{sum + num, num\}$



#### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

**基本思路：**

题目换种说法就是要找，非交叠区间的最大数

## 字符串操作

### 字符串操作1(贪心)

给定一个只包含小写字母字符串，每次可以选择两个相同的字符删除，并在字符串结尾新增任意一个小写字母。
请问最少多少次操作后，所有的字母都不相同？

> 输入例子：
>
> ```
> "abab"
> ```
>
> 输出例子：
>
> ```
> 2
>
> ```
>
> 例子说明：
>
> ```
> 第一次操作将两个'a'变成一个'f'，字符串变成"bbf"。
> 第二次操作将两个'b'变成一个'b'，字符串变成"fb"。
> 操作方式不是唯一的，但可以证明，最少操作次数为2。
> ```

**思路：**

- 只要存在字母相同，就将之变为其他一个不相同的字母，操作次数`cnt`加一；
- 对操作次数`cnt`判断
  - 字符串长度`len- cnt > 26` ,表明需要的相异字符超过了26，那么超过的字符每一个便要进行一次变换操作，最终结果为 `len - 26`
  - `len- cnt <= 26` ,表明需要的相异字符小于26个，一轮变换就能成功，最终结果 `cnt`

**关键代码：**

```java
public int minOperations (String str) {
        // write code here
        int[] chars = new int[26];
        int len = str.length();
        int cnt = 0;
        for (char ch : str.toCharArray()) {
            if (chars[ch - 'a'] == 1) {
                cnt++;
                chars[ch - 'a'] = 0;
            } else chars[ch - 'a'] = 1;
        }
        return len - cnt > 26 ? len - 26 : cnt;
}
```



## 树

#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

关键在于，找到删除节点t后：

1. 若`t.right == null`,则用`t.left`顶替t
2. 若`t.left == null`，则用`t.right`顶替t
3. t的左右节点均不为`null`，将`t.left`连接到`t.right`的最左叶子节点，用`t.right`顶替t

**1. 递归方法**

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right =  deleteNode(root.right, key);
        else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            TreeNode tmp = root.right;
            while (tmp.left != null) tmp = tmp.left;
            tmp.left = root.left;
            return root.right;
        }
        return root;
    }
}
```

**2. 迭代的方法：**

迭代的方法相对于递归，要注意删除是左节点还是右节点，需要使用`pre.left`和`pre.right`指向下一个要删除的节点，和链表删除类似。

```java 
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode dummy = new TreeNode(1), pre = dummy;
        pre.right = root;
        //找到目标节点
        while (root != null){
            if (pre.left != null && pre.left.val == key) {
                pre.left = getNext(pre.left);
                return dummy.right;
            }
            if (pre.right != null && pre.right.val == key) {
                pre.right = getNext(pre.right);
                return dummy.right;
            }
            if (key < root.val) {
                pre = root;
                root = root.left;
                
            } else if (key > root.val) {
                pre = root;
                root = root.right;
            } 
        }
        return dummy.right;
    }

    private TreeNode getNext(TreeNode root) {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        
        TreeNode tmp = root.right;
        while (tmp.left != null) tmp = tmp.left;
        tmp.left = root.left;
        return root.right;
    }

}
```



## 区间

### 区间交集个数

#### [2409. 统计共同度过的日子数](https://leetcode.cn/problems/count-days-spent-together/)

计算区间[a,b]和区间[c,d]相交的个数。

```java
int cnt = min(b, d) - max(a, c);
int ans = max(cnt, 0);
```

## 前缀和&差分

**差分数组**的主要适用场景是频繁对原始数组的某个**区间**的元素进行**相同的增减**。

差分数组`d[i]`表示的是数组相邻元素之间的差值，即`d[i] = arr[i] - arr[i - 1]`。

针对数组的某一区间进行相同的加减，可以用区间的端点进行记录，如。

| 数组下标      | 0    | 1    | 1    | 2    | 4    | 5    | 6    | 7    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 原始数组      | 5    | 2    | 5    | 4    | 9    | 7    | 10   | 0    |
| 原始d[i]    | 5    | -3   | 3    | -1   | 5    | -2   | 3    | -10  |
| 区间[1,4]+3 | 5    | 0    | 3    | -1   | 5    | -5   | 3    | 0    |
| ans[i]    | 5    | 5    | 8    | 7    | 12   | 7    | 10   | 0    |

对区间[1，4]之间的元素加3，则将`d[1] += 3，d[4 + 1]  -= 3` 。

对某个左闭右闭区间`[i, j]`加m， 即`d[i] += m, d[j + 1] -= m` 。

对某个左闭右闭区间`[i, j)`加m， 即`d[i] += m, d[j] -= m` 。

#### [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

样例：

```sh
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```

**思路：**

直接使用差分模板记录区间要加减的值，再使用前缀和对差分数组计算值。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] d = new int[n];
        for(int[] b : bookings) {
            d[b[0] - 1] += b[2];
            if (b[1] < n) {
                d[b[1]] -= b[2];
            }
        }
        for (int i = 1; i < n; i++) {
            d[i] += d[i - 1];
        }
        return d;
    }
}
```



#### [1094. 拼车](https://leetcode.cn/problems/car-pooling/)

车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）

给定整数 capacity 和一个数组 trips ,  trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。

样例：

```sh
## 样例1
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
## 样例2
输入：trips = [[2,1,5],[3,5,7]], capacity = 4
输出：true
```

**思路：**

和[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)几乎一样，只是下标和区间有所不同，此题的区间是左闭右开的，因为再同一站点可以先下后上。

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] d = new int[1001];
        for (int[] trip : trips) {
            d[trip[1]] += trip[0];
            d[trip[2]] -= trip[0];
        }
        long sum = 0;
        for (int i = 0; i < 1001; i++) {
            sum += d[i];
            if (sum > capacity) return false;
        }
        return true;
    }
}
```

#### [798. 得分最高的最小轮调](https://leetcode.cn/problems/smallest-rotation-with-highest-score/)

给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 > 0 [不计分]、3 > 1 [不计分]、0 <= 2 [计 1 分]、2 <= 3 [计 1 分]，4 <= 4 [计 1 分]。
在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 

```sh
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
```



**思路：**

索引为i时, nums[i] 在k为 `[(i + 1) mod length, (length - nums[i] + i) mod length]` 时当前值可以获得得分, length为数组长度。

```java
class Solution {
    public int bestRotation(int[] nums) {
        int n = nums.length;
        int[] d = new int[n];
        for (int i = 0; i < n; i++) {
            int l = (i + 1) % n;
            int r = (i - nums[i] + n + 1) % n;
            d[l] += 1;
            d[r] -= 1;
            //若[l, r]跨越右边界，则[0, l - 1]要加1
            if (l >= r) d[0] += 1;
        }
        int maxScore = d[0], selI = 0;;
        for (int i = 1; i < n; i++) {
            d[i] += d[i - 1];
            if (d[i] > maxScore) {
                selI = i;
                maxScore = d[i];
            }
        }
        return selI;
    }
}
```



## 小技巧

### 位运算

#### 判断是否异号

```java 
if ((a ^ b) < 0) //只能判断正负异号，如果有一个值是0判断是不准确的
```



将一个int数组转为数组

```java
char[] chars = String.valueOf(num).toCharArray();
```

将一个char数组转为int

```java
int num = Integer.parseInt(String.valueOf(chars));
```

#### 大小写转换

- `c = c | 32`利用**或运算**将这个字母转化为小写字母
- `c = c & ~32` 利用**与运算**将这个字母转化为大写字母
- `c = c ^ 32` 利用**异或运算**将字母大小写互换，即大写转小写，小写转大写

> **注意：**大小写转换只是针对字母，在转换前首先要对符判断是否是字母。
>
> ```java
> Character.isAlphabetic(ch)
> ```

### 快速幂

二分思路
$$
a^n =   \begin{cases}
               a^{n - 1} * a , & \text{if $n$ is odd} \\[2ex]
                a^{\frac{n}{2}} * a^{\frac{n}{2}},        & \text{if $n$ is even but not 0}  \\
                1, &\text{if n is  0}
       	 \end{cases}
$$
Java代码：

```java
private int qpow(int a, int n) {
    int ans = 1;
    while (n != 0) {
        if ((n & 1) == 1) {
            ans = ans * a;
        }
        a = a* a;
        n >>= 1;
    }
    return ans;
}
```



### 快速位运算

```java
int bitCnt(int n) {
  int cnt = 0;
  while (n > 0) {
    n = n & (n - 1); //消除低位1
    cnt++;
  }
  return cnt;
}
```

### int[]数组排序

```java
Arrays.stream(nums).boxed().sorted(new Comparator<Integer>()) {
  public int compare(Integer o1, Integer o2) {
    int cnt1 = bitCnt(o1);
    int cnt2 = bitCnt(o2);
    return (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);
  }.mapToInt(Integer::intValue).toArray();
}
```

