## 1、http概念

HTTP是一种在应用层传输的超文本传输协议，客户端向服务器发送HTTP请求，服务器则向客户端返回HTTP响应。通常使用80端口，HTTP协议是无状态协议，这意味着服务器不会保存客户端的任何信息，每个请求都是独立的。

## 2、http常见状态码

### 状态码及解释

- `1xx`：信息 - 未使用，但保留供将来使用 
- `2xx`：成功 - 已成功接收、理解和接受操作。
- `3xx`：重定向 - 必须采取进一步操作才能完成请求 
- `4xx`：客户端错误 - 请求包含错误的语法或无法完成 
- `5xx`：服务器错误 - 服务器无法满足明显有效的请求

常用状态码：

```bash
| "200"   ; OK；服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
| "201"   ; Created
| "202"   ; Accepted
| "204"   ; No Content
| "301"   ; Moved Permanently； (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
| "302"   ; Moved Temporarily；(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
| "304"   ; Not Modified
| "400"   ; Bad Request；客户端请求有语法错误，不能被服务器所理解。
| "401"   ; Unauthorized
| "403"   ; Forbidden；服务器收到请求，但是拒绝提供服务。
| "404"   ; Not Found；(未找到) 服务器找不到请求的网页。
| "500"   ; Internal Server Error； (服务器内部错误) 服务器遇到错误，无法完成请求。
| "501"   ; Not Implemented
| "502"   ; Bad Gateway
| "503"   ; Service Unavailable
```

HTTP状态代码是可扩展的，但上述代码是当前实践中唯一普遍认可的代码。

## 3、状态码301和302的区别是什么？

**共同点：**301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。

**不同点：**301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。
**重定向原因：**

1. 网站调整（如改变网页目录结构）；
2. 网页被移到一个新地址；
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

## 4、HTTP常用请求方式

#### GET

 `GET` 方法请求指定的资源。使用 `GET` 的请求应该只用于获取数据。安全、幂等、可缓存。

#### HEAD

`HEAD`方法和`GET`方法类似，都是用于从服务器请求资源，但是`HEAD`方法不返回正文题，只返回响应头部信息，如状态码、响应头字段等。通常用于查询服务器资源数据，如文件大小、类型、最后修改时间等。

#### POST

`POST`方法通常是将数据发送给服务器，并将处理结果返回。非安全、非幂等、一般不可缓存。

## 5、GET请求和POST请求的区别？

用法上区别：

1. 一般GET使用URL或Cookie传参，而POST将数据放在body中，这个只是一般约定；
2. GET方式提交的数据有长度限制，而POST的数据则可以非常大，这是因为浏览器地址栏长度的限制；
3. GET只能发送ASCII字符，post支持更多的类型；
4. POST在发送数据之前会将请求头发送给服务器验证，GET不会进行验证（GET比POST请求更快）；
5. GET会缓存数据（IE中全部缓存，chrome和firefox只会缓存静态资源），POST不会。

本质区别：

安全：在HTTP中的安全是指请请求不会破坏服务器上的资源；

幂等：在HTTP中幂等是指执行多次操作的结果是相同的。

从HTTP的角度来说GET是安全和幂等的，而POST不是。

## 6、HTTP长连接和短连接？

在**HTTP/1.0**中，默认使用的是**短连接**。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

**HTTP/1.1**起，默认使用**长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： `Connection:keep-alive` 。

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。**实现长连接要客户端和服务端都支持长连接。**

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

## 7、HTTP请求报文和响应报文的格式？

请求报文格式：

1. 请求行（请求方法+URI协议+版本）
2. 请求头部
3. 空行
4. 请求主体

```sh
GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
username=jinqiao&password=1234 请求主体
```

响应报文：

1. 状态行（版本+状态码+原因短语）
2. 响应首部
3. 空行
4. 响应主体

```sh
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112
<html>
  <head>
      <title>HTTP响应示例<title>
  </head>
  <body>
      Hello HTTP!
  </body>
</html>

```



## 8、HTTP1.0 、HTTP1.1和HTTP2.0的区别?

- HTTP/1.0：
  - 最初的HTTP协议版本，它使用明文传输数据，并且每个请求/响应需要打开和关闭一个新的连接（短连接方式）。这种方式效率低下，且存在安全风险；
  - 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准；

- HTTP/1.1：
  - **长连接：**HTTP 1.1支持长连接（Persistent Connection）和请求的流水线Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 `Connection： keep-alive` ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
  - **缓存处理：**HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略；
  - **错误处理：**在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
  - **Host头处理：**在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

- HTTP2.0：
  - **新的二进制格式**：**HTTP1.1**的解析是**基于文本**。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
  - **多路复用**：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里。
  - **头部压缩**：HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
  - **服务端推送**：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。

- HTTP/3：

  HTTP/3 是基于QUIC（快速UDP互联网连接）协议的HTTP协议版本。QUIC是一个基于UDP的协议，可以减少延迟和阻塞等问题，因此HTTP/3在性能方面有了很大的提升。它使用TLS 1.3进行加密，同时支持多路复用和流量控制等特性。

## 9、 HTTP 与 HTTPS 的区别？

- **端口**：HTTP使用80端口；HTTPS使用443端口；
- **协议&安全性**：HTTP使用TPC没有加密，安全性较差；HTTPS使用TCP+SSL协议，有加密机制，安全性较高；
- **资源消耗**：HTTP没有加密机制，消耗较少；HTTPS由于有加密机制，资源消耗更多；
- **证书**：HTTP不需要证书；HTTPS需要证书提供公钥等信息，因此需要证书。

## 10、HTTPS 的优缺点

优点：

- **安全性：**
  - 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
  - HTTPS协议是由TCP+SSL协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；虽然不是绝对安全，但是大幅增加了中间人攻击的成本。
- **SEO方面：**谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

缺点：

- 在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是能耗都有大幅度上升；
- HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用；
- HTTPS 需要更多的服务器资源，也会导致成本的升高。

## 11、HTTPS原理

![输入图片说明](https://foruda.gitee.com/images/1682591803318631331/36ee6f3d_8616658.png "屏幕截图")

握手流程：

```ba
 1.浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。
 2.服务器接收到，立即返回 server_random，确认好双方都支持的加密套件以及数字证书 (证书中附带公钥 Public key certificate)。
 3.浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法RSA算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
 4.服务器用私钥解密这个被加密后的 pre_random，此时客户端和服务端都有了相同的client_random、server_random、pre_random（前两个是明文传输、pre_random是加密传输），三个数通过加密算法计算得到一个协商密钥。
 5. 客户端发送2个请求：告知服务端以后通信使用协商密钥；将之前通信参数的hash值使用协商密钥加密发送给服务端验证，并等待ACK确认。
 6. 服务端验证后，对客户端通知使用协商密钥请求进行ACK确认；将之前通信参数的hash值使用协商密钥加密发送给客户端验证。

```



加密流程按图中的序号分为：

1. 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。
2. 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
5. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
7. 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
8. 双方使用对称加密愉快地传输所有数据。

##  12、在浏览器中输入www.baidu.com后执行的全部过程？

1. 域名解析（域名 www.baidu.com 变为 ip 地址）。
  - **浏览器**搜索自己的DNS缓存（维护一张域名与IP的对应表）；
  - 若没有，则搜索**操作系统**的DNS缓存（维护一张域名与IP的对应表）；
  - 若没有，则搜索操作系统的**hosts文件**（维护一张域名与IP的对应表）。
  - 若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即**本地 dns 服务器**（递归查询），本地域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。
2. 发起 tcp 的三次握手，**建立 tcp 连接**。浏览器会以一个随机端口（1024-65535）向服务端的 web程序 80 端口发起 tcp 的连接。
3. 建立 tcp 连接后发起 http 请求。
4. 服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。
5. 浏览器解析 html 代码，并请求 html 中的资源。
6. 浏览器对页面进行渲染，并呈现给用户。

## 13、什么是 Cookie 和 Session ?

**什么是 Cookie？**

HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

**什么是 Session？**

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

## 14、Cookie和Session的区别？

1. 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
2. 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。
3. 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
4. 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
5. 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

## 15、如何考虑分布式 Session 问题？

在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

1. 客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息；
2. Nginx ip_hash 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
3. Session 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
4. 共享 Session：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。

建议采用共享 Session的方案。

## 16、什么是XSS攻击？

XSS也称 cross-site scripting，跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有＜script＞标签的代码，导致恶意代码的执行。
预防措施有：

- 前端：过滤。
- 后端：转义，比如go自带的处理器就具有转义功能。

## 17、SQL注入是什么，如何避免SQL注入？

SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

SQL注入的原理主要有以下 4 点

- 恶意拼接查询
- 利用注释执行非法命令
- 传入非法参数
- 添加额外条件

避免SQL注入的一些方法：

- 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。
- 对进入数据库的特殊字符（’”\尖括号&*;等）转义处理。
- 提供参数化查询接口，不要直接使用原生SQL。

## 18、负载均衡算法有哪些？

多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

- 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。
- 随机法：随机获取一台，和轮询类似。
- 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。
- 加权轮询：根据服务器性能不同加权。

## 19、HTTPS握手过程

1. 客户端发送一个ClientHello消息，其中包含支持的TLS协议版本、加密算法、压缩算法等信息。还包括一个随机数，该随机数用于生成后续的密钥。此时客户端进入HELLO_SENT状态，等待服务器响应状态。
2. 服务器收到ClientHello消息后，发送一个ServerHello消息，其中包含使用的TLS协议版本、加密算法、压缩算法等信息。还包括一个随机数，该随机数用于生成后续的密钥。HELLO_RECEIVED状态，表示收到客户端ClientHello消息后的状态。
3. 服务器发送一个Certificate消息，其中包含服务器证书。证书用于验证服务器的身份和公钥。如果使用了双向认证，则客户端也会发送一个Certificate消息，其中包含客户端证书。
4. 服务器发送一个ServerKeyExchange消息，该消息仅在某些情况下发送。例如，在Diffie-Hellman密钥交换期间，服务器需要向客户端发送其公共参数，以便客户端可以计算共享密钥。
5. 服务器发送一个ServerHelloDone消息，表示服务器已经完成握手阶段的所有消息。
6. 客户端接收服务器发送的消息，并验证服务器的证书。如果证书有效，则使用服务器的公钥加密一个随机数，并将其发送给服务器。
7. 客户端发送一个ClientKeyExchange消息，该消息包含使用服务器公钥加密的随机数。服务器使用其私钥解密该随机数，并使用该随机数生成共享密钥。
8. 客户端发送一个ChangeCipherSpec消息，该消息通知服务器从现在开始使用协商的加密算法进行通信。
9. 客户端发送一个Finished消息，其中包含使用共享密钥计算出的摘要。服务器也会发送一个Finished消息，客户端接收并验证服务器发送的摘要。
10. TLS握手完成后，双方使用协商的加密算法和密钥进行通信。

## 20、加密于安全

### 对称加密

对称加密使用相同的密钥来加密和解密数据。这意味着，加密方和解密方都知道相同的密钥。对称加密算法通常具有较高的加密速度，但需要确保密钥的安全性，因为如果密钥泄露，数据就会暴露。

常见的对称加密算法包括AES（高级加密标准）、DES（数据加密标准）和3DES（Triple DES）等。

### 非对称加密—公开密钥加密

非对称加密使用一对密钥，一个是公钥，一个是私钥。公钥可以向任何人公开，用于加密数据，而私钥只有密钥所有者才能访问，用于解密数据。非对称加密算法通常比对称加密算法更安全，因为即使公钥泄露，也不会影响数据的保密性。

常见的非对称加密算法包括RSA（Rivest–Shamir–Adleman）、DSA（数字签名算法）和ECC（椭圆曲线加密）等。

总的来说，对称加密速度快但要求密钥安全，非对称加密更安全但速度较慢。在实际应用中，通常会使用两者结合的方式，即使用非对称加密算法来协商对称加密的密钥，然后使用对称加密算法进行加密和解密。这样可以同时保证安全性和效率。

## 21、什么是DDos攻击？

DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：

1. 客户端向服务端发送请求链接数据包；
2. 服务端向客户端发送确认数据包；
3. 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。

DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。

DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：

- 减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。
- 限制同时打开的SYN半连接数目。