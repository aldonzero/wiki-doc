## 1、TCP概念

tcp是一个面**向连接的**、**可靠的**、**基于字节流**的传输层通信协议。

### 一个服务端的最大TCP连接数是多少？

服务端通常固定在某个本地端口上监听，等待客户端的连接请求。

因此，客户端 IP 和端口是可变的，其理论值计算公式如下:
$$
最大连接数 = 客户端的IP数 \times 客户端的端口数
$$


对 IPv4，客户端的 IP 数最多为 `2` 的 `32` 次方，客户端的端口数最多为 `2` 的 `16` 次方，也就是服务端单机最大 TCP 连接数，约为 `2` 的 `48` 次方。

## 2、UDP 和 TCP 有什么区别呢？分别的应用场景是？

TCP是面向连接的、可靠的、传输层协议，在传输数据之前会先建立连接，一对一之间进行传输，拥有拥塞控制和流量控制。

UDP是面向无连接的、不保证可靠性，也没有拥塞控制和流量控制，可以进行一对多和多对多的交互通信。

> - TCP用于在传输层有必要实现可靠传输的情况；
> - UDP用于对高速传输和实时性有较高要求的通信。
>
> TCP和UDP应该根据应用目的按需使用。

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

## 3、TCP三次握手过程

![输入图片说明](https://foruda.gitee.com/images/1681890780384029687/d22a343e_8616658.png "屏幕截图")

1. 第一次握手，客户端处于`closed状态`，向服务端发送`SYN=1,seq=x`的连接请求，发送后客户端变成`SYN-SENT`状态，等待服务端的确认；

2. 第二次握手，服务端处于`listen状态`，收到客户端的请求后，向客户端发送`SYN=1,ACK=1,seq=y,ack=y+1`，确认第一次握手请求并向客户端请求建立连接，服务端确认后进入`SYN-RCVD状态`，等待客户端的确认；

3. 第三次握手，客户端收到服务端的确认后，向服务端发送`ACK=1,seq=x+1,ack=y+1`的确认连接，客户端进入`Established连接建立状态`，服务端收到确认连接也进入到`Established连接建立状态`，至此双方通信连接建立成功，可以进行数据传输。

   > 理想状态下，TCP一旦建立，在通信双方的任何一方主动关闭连接前，TCP连接都将一直保持下去。

## 4、为什么是三次握手？

1. 三次握手才可以阻止重复历史连接的初始化（主要）；

   - 当客户端先发送了一个SYN报文，由于网络阻塞，服务端没有收到，而客户端宕机重启重新发送SYN请求，这时服务端收到之前的SYN请求；


   - 服务端收到旧SYN请求，向客户端发送确认请求;
   - 客户端收到服务端的确认后，由于序号不符，会发送一个RST报文；
   - 服务端收到RST报文后，会释放半连接队列中的连接请求。

2. 三次握手才可以同步双方的初始序列号；TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：
   - 接收方可以去除重复的数据；
   - 接收方可以根据数据包的序列号按序接收；
   - 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

3. 三次握手才可以避免资源浪费；如果只有「两次握手」，当客户端发生的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接** 。

## 5、什么是 SYN 攻击？如何避免 SYN 攻击？

TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。

**解决办法：**

1. 调大 netdev_max_backlog；当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。
2. 增大 TCP 半连接队列；
3. 开启 tcp_syncookies；开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。
   - 当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 `cookie` 值；
   - 将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；
   - 服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。
   - 最后应用程序通过调用 `accpet()` 接口，从「 Accept 队列」取出的连接。

- 减少 SYN+ACK 重传次数；当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接；默认值是5次。

## 6、三次握手连接阶段，最后一次ACK包丢失，会发生什么？

服务端：

- 第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。
- 如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。

客户端：

- 客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。

## 7、四次挥手过程

![输入图片说明](https://foruda.gitee.com/images/1681891640399032514/b24f3a21_8616658.png "屏幕截图")

1. 客户端和服务端处于连接建立状态，当客户端调用`close()函数`后会向服务端发送`FIN=1,seq=u`的请求断开报文，客户端发送后进入到 `FIN_WAIT_1` 状态，等待服务端的确认；
2. 第二次挥手，当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态，客户端收到对FIN请求的确认后进入到`FIN_WAIT2` 状态，等待服务的数据传输和FIN请求；
3. 第三次挥手，当服务端对客户端的FIN请求进行ACK确认后，会继续发送数据，数据发送完后，会向客户端发送一个`FIN=1,ACL=1,seq=w,ack=u+1`的连接断开请求，之后服务进入`LAST-ACK状态`，等待客户端的确认；
4. 第四次挥手，客户端收到服务端的FIN请求后，发送`ACK=1,seq=u+1，ack=w+1`进行确认，之后进入`TIME-WAIT状态等待2MSL`后关闭连接；服务端在收到对FIN请求的确认后关闭连接。

##### 8、为什么 TIME_WAIT 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

主要有两个原因：

1. 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。

  - 第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。
  - MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。
  - 如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。
2. 防止已失效的连接请求报文段出现在之后的连接中。

  TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。

## 9、如果已经建立了连接，但是客户端出现故障了怎么办？

通过**定时器 + 超时重试机制**，尝试获取确认，直到最后会自动断开连接。

具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断 开了。

## 10、TIME-WAIT 状态过多会产生什么后果？怎样处理？

从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。

从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。

**解决办法：**

- **重用端口**，服务器可以设置 `SO_REUSEADDR 套接字`选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于TIME_WAIT状态），也请继续并重用它。

- 调整系统内核参数，修改/etc/sysctl.conf文件，即修改 net.ipv4.tcp_tw_reuse 和tcp_timestamps

  ```sh
  net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
  net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  ```

- **强制关闭**，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。

对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

## 11、TCP协议如何保证可靠性？

TCP主要提供了**检验和**、**序列号/确认应答**、**超时重传**、**滑动窗口**、**拥塞控制**和**流量控制**等方法实现了可靠性传输。

- 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。

- 序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。

  TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

- 滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。

- 超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。

- 拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。

- 流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，**主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量**。流量控制与TCP协议报头中的窗口大小有关。

## 12、详细讲一下TCP的滑动窗口？

在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。

为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。

![输入图片说明](https://foruda.gitee.com/images/1682497183016071607/0a319e66_8616658.png "屏幕截图")

滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。

可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

## 13、详细讲一下拥塞控制？

TCP 一共使用了四种算法来实现拥塞控制：

- 慢开始 (slow-start)；
- 拥塞避免 (congestion avoidance)；
- 快速重传 (fast retransmit)；
- 快速恢复 (fast recovery)。

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。

- 慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。

- 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。

- 快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

  ![输入图片说明](https://foruda.gitee.com/images/1682498339145504230/7e0f259a_8616658.png "屏幕截图")

- 快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

![tcp拥塞控制](https://foruda.gitee.com/images/1682498436666010365/e9eaee79_8616658.png "屏幕截图")

## 