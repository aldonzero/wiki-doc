## Redis 为何这么快？

1. 基于内存，查询和写操作不会进行磁盘IO操作
2. 单线程减少上下文切换，同时保证原子性；
3. IO多路复用；
4. 针对不同场景支持有多种数据结构（SDS，Hash、跳表等）

## 为何使用单线程？

Redis是基于内存的的操作，CPU不会称为Redis瓶颈，而最有可能的瓶颈是机器内存的大小或者网络带宽。而且单线程的实现相较于多线程更容易，可维护性更高。

1. 不需要各种锁的性能消耗

   Redis存在多种数据结构（SDS、LIst、dict、跳表等），这些结构可能会进行很细粒度的操作，比如对元素的增删改操作，这些操作如果要保证数据的正确性，需要加入锁的操作，导致同步开销增大。

2. 单线程多进程方案

   在今天的计算机环境中，单机多线程的上限也不能满足需要，而多服务集群化的方案中，单线程的效率也非常高，能够满足需要。

## Redis 6 之前是单线程吗？

Redis在处理客户端请求时，包括读取（socket read）、解析、执行、内容返回（socket write）都由一个顺序穿行的主线程处理，这就是所谓的单线程。

## Redis 6 之后为何引入多线程？

随着业务场景越来越复杂，需要更大的QPS，常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但是该方案有缺点：

1. 要管理的Redis服务器太多，维护代价大；
2. 某些适用于单个Redis服务器的命令不适用于数据分区；
3. 数据分区无法解决热点读/写问题；
4. 数据偏科，重新分配和放大/缩小变得更加复杂。

从Redis自身角度来说，因为网络IO占用了Redis执行期间的大部分CPU时间，瓶颈主要在于网络IO的消耗，优化主要有两个方向：

1. 提高网络IO性能，典型的实现如使用DPDK来代替内核网络栈的方式；
2. 使用多线程充分利用多核，典型实现如Memcached。

协议栈优化方向和Redis关系不大，支持多线程是一种最有效最便捷的操作方式。所以Redis支持多线主要原因是：

1. 可以充分利用服务器CPU多核资源；
2. 多线程任务可以分摊Redis同步IO读写负荷。

## Redis 多线程的实现机制？

1. 主线程负责接收建立连接请求，获取socket放入全局等待读处理队列；
2. 主线处理完读事件之后，通过RR（Round Robin）将这些连接分配给IO线程；
3. 主线程阻塞等待IO线程读取socket；
4. 主线通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行；
5. 主线程阻塞等待IO线程将数据回写socket完毕；
6. 解除绑定，清空等待队列。

特点：

1. IO线程要么同时在读socket，要么同时在写，不会同时读或同时写。
2. IO线程只负责读写socket解析命令，不负责命令处理。

## 多线程是否会导致线程安全问题？

Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。

## Redis 和 Memcached 多线程区别？

相同点：都采用了master线程 - worker线程的模型。

不同点：Memcached执行主逻辑在work线程里，模型更加简单，实现了真正线程隔离，符合我们对线程隔离的常规理解。而Redis把处理逻辑还给master线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。

## 缓存三大问题及解决方案？

### 缓存穿透

缓存穿透是指在缓存中查询不到数据而直接对磁盘（MySQL）进行数据查询。

解决方案：

1. 缓存空值
2. Key值校验，如使用布隆过滤器

### 缓存击穿

缓存击穿是指缓存过期，伴随大量对改key的请求

解决方案：

1. 互斥锁
2. 热点数据永不过期
3. 熔断降级

### 缓存雪崩

缓存雪崩是指同一时间大批量的key过期

解决方案：

1. 热点数据不过期
2. 随机分散过期时间

## Redis与MySQL一致性

### 先删除缓存后写DB

产生脏数据的概率比较大（若出现脏数据，则在不更新的情况下，查询到的数据均为旧的数据）本质是更新操作存在多个过程并且整个更新操作不具有原子性。

两个并发操作，更新操作和查询操作，查询操作在更新操作的过程中执行，比如查询操作在更新操作删除缓存并且尚未更新数据库的过程中查询数据，则查询操作会将数据库中的数据查询放到缓存中，更新操作继续更新数据库，最终导致缓存中的数据和数据库中的数据不一致。



![输入图片说明](https://foruda.gitee.com/images/1680485628047542416/9848b287_8616658.png "屏幕截图")

### 先写在删除缓存

虽然产生脏数据概率比较小，但还是会出现一致性问题。

两个并发操作，更新操作和查询操作，更新操作更新数据库后，查询操作命中缓存，得到的结果是旧数据，更新操作删除缓存。之前读取的数据是藏数据。

如果查询操作没有命中，先查询数据库，更新操作更新数据库并删除缓存，此时查询操作将之前查询的数据更新到缓存，则缓存中的数据就是脏数据。

**解决方案：**

1. 缓存设置过期时间；
2. 使用Cannel等中间件监听binlog进行异步更新；
3. 通过2PC或Paxos协议保证一致性。

## Redis如何实现高并发？

Redis通过主从加集群架构实现读写分离，主节点负责写，并将数据同步给其他从节点，从节点负责读，从而实现高并发。

## Redis如何保证原子性？

Redis的命令操作是单线程的，因此提供的API操作具有原子性。

虽然Rdis的操作是具有原子性，但是并发同一个业务中含有多个Redis写操作（get、set），在并发情况下可能会导致数据不一致的情况。

**解决方案：**

1. 使用incr、decr、setnx等原子操作；
2. 客户端加锁；
3. 使用Lua脚本实现CAS操作。

## Redis应用场景？

1. String：缓存、限流、分布式锁、计数器、分布式Session等。
2. Hash：用户信息、用户主页访问量、组合查询等。
3. List：简单队列、关注列表时间轴。
4. Set：点赞、标签等。
5. ZSet：排行榜、好友关系链表等。

## Redis数据结构

### SDS好处

1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符串的内存重新分配次数
4. 二进制安全
5. 兼容C字符串函数

### 链表特性

1. 双端：链表具有头节点和尾节点，是双向链表
2. 带长度计数器：通过len属性获取链表长度
3. 多态：链表节点使用指针保存节点，可以保存各种不同类型的值

### Dict相关

1. Dict的实现：hash+链表
2. rehash
3. 扩容

### 跳表

1. #### 具体实现

2. #### 为什么不是用红黑树等平衡树

1）跳表范围查询比平衡树更简单。平衡树在查询到最小值时，还需要采用中序遍历查询最大值，而跳表只需要在找到最小值后，对第一层遍历。

2）平衡树的删除和插入需要对子树进行相应的调整，而跳表只需要修改相邻节点。

3）从整体上看跳表算法实现的难度要低于平衡树。

### intset

1. 集合升级过程
2. 集合是否降级

### 压缩列表

### 什么是RedisObject

Redis并没有使用Redis的数据结构直接实现键值对数据库，而是在这些数据结构上又包装一层RedisObject（对象）。

**好处：**

1. 通过不同类型的对象，Redis可以在执行命令之前，根据对象的烈性来判断一个对象是否可以执行该命令。
2. 可以针对不同的使用场景，为对象设置不同的实现，从而优化内存或查询速度。

## Redis过期策略

设置过期时间：

```bash
expire key time(以秒为单位)
setex（String key， int seconds，String value）//字符串独有方式
```

**过期策略**

1. 定时删除：

   在设置key过期时间同时，为改key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。

2. 惰性删除

   - 在进行get或setnx等操作是，先检查key是否过期；
   - 若过期，删除key，然后执行相关操作；
   - 若没有过期，直接执行相关操作。

   **特点：**

   - 删除目标仅限于当前处理的键，不会在删除其他无关键上花费任何CPU时间；
   - 内存压力大，会存在长期占用内存的数据，如果过期永远不被范文，这种情况相当于内存泄露。

3. 定期删除

   每隔一段时间执行一次删除过期键操作，并通过限制删除操作的时长和频率来减少删除操作对CPU时间的影响。

   定期删除是周期轮询Reids库中的时效性数据，从过期字典中随机抽取一部分键检查，利用过期数据占比控制删除频度。如果超过25%，继续重复此过程直到比率下降到25%以下，或者这次任务耗时超过了25毫秒。

   **特点：**

   - CPU占用设置有峰值，检测频度可以自定义设置
   - 内存压力不是很大，长期占用内存的冷数据会被持续清理
   - 周期性抽查存储空间（随机抽查，重点抽查）

   ### 持久化文件对过期策略的处理

   过期 key 是不会写入 RDB 和 AOF 文件，同时数据恢复时也会做过期验证。

## 淘汰策略

Redis作为一个内存数据库，在内存空间不足的时候，为了保证命中率，会选择一定的数据淘汰策略。

数据淘汰策略：当新数据进入Redis时，在执行每一个命令前，会调用`freeMemoryIFNeed()`检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis要临时删除一些数据为当前指令清理存储空间，清理数据的策略称为逐出**算法**。

逐出数据的过程不是 100% 能够清理出足够的可使用的内存空间，如果不成功则反复执行，当对所有数据尝试完毕，如不能达到内存清理的要求，**出现 Redis 内存已满无法分配内存的错误。**

**策略配置：**

1. 检测易失数据（可能会过期的数据 server.db[i].expires）

   ```sh
     volatile-lru	# 对设置了过期时间的 key 选择最近最久未使用使用的数据淘汰
     volatile-lfu	# 对设置了过期时间的 key 选择最近使用次数最少的数据淘汰
     volatile-ttl	# 对设置了过期时间的 key 选择将要过期的数据淘汰
     volatile-random	# 对设置了过期时间的 key 选择任意数据淘汰
   ```

2. 检测全库数据（所有数据集 server.db[i].dict）

   ```sh
     allkeys-lru		# 对所有 key 选择最近最少使用的数据淘汰
     allkeLyRs-lfu	# 对所有 key 选择最近使用次数最少的数据淘汰
     allkeys-random	# 对所有 key 选择任意数据淘汰，相当于随机
   ```

3. 放弃数据驱逐

     ```sh
     no-enviction	#禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)
     ```

## Redis持久化机制

RDB和AOF

## 什么是Redis的Pipeline？

在Pipeline之前，客户端执行一条命令的步骤：

```mermaid
graph LR
A1["发送命令"] --> A2["命令排队"]
A2 --> A3["命令执行"]
A3 --> A4["返回结果"]
```

这个过程称为Round trip time（RTT，往返时间），mgget和mset有效节约了RTT，但大部分命令（如，hgetall并没有mgetall）不支持批量操作，需要消耗N次RTT，这时需要Pipeline。

Redis管道Pipeline机制可以一次处理多条命令。

* Pipeline 中的多条命令非原子性，因为在向管道内添加命令时，其他客户端的发送的命令仍然在执行
* 原生批命令（MSET 等）是服务端实现，而 Pipeline 需要服务端与客户端共同完成
* 使用 Pipeline 封装的命令数量不能太多，数据量过大会增加客户端的等待时间，造成网络阻塞

集群下模式下，批处理命令的多个 key 必须落在一个插槽中，否则就会导致执行失败，N 条批处理命令的优化方式：

* 串行命令：for 循环遍历，依次执行每个命令
* 串行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，串行执行各组命令
* 并行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，**并行执行各组命令**
* hash_tag：将所有 key 设置相同的 hash_tag，则所有 key 的 slot 一定相同

### 原生批命令 (mset, mget) 与 Pipeline 区别?

1. 原生批命令是原子性的，而pipeline是非原子性的。
2. 原生批命令一命令多个key；但pipeline支持多命令（存在事务），非原子性
3. 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成。



## 集群

***

### Redis集群搭建集中模式？

1. 主从模式

   Redis随让读写速度非常快，到那时也会产生性能瓶颈，特别是在读压力上，为了分担压力，Redis支持主从复制。Redis的主从结构是主服务器负责写数据，从服务器负责读数据。

2. 哨兵模式

   在主从复制实现后，如果想对master进行监控，Redis提供一宗哨兵机制，监控Redis系统的运行状态。

3. cluster集群模式

### 主从复制的实现

主从复制可以根据需要分为全量同步和增量同步（命令传播）两种。

1. **全量同步**

   Redis全量复制一般发生在slave初始阶段，将从服务器状态更新为主服务当前相同的状态。

   1）从服务器向主服务器发送 SYNC 命令来进行同步

   2）收到 SYNC 的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个**缓冲区**记录从现在开始执行的所有**写命令**

   3）当 BGSAVE 命令执行完毕时，主服务器会将 RDB 文件发送给从服务器

   4）从服务接收并载入 RDB 文件（从服务器会**清空原有数据**）

   5）缓冲区记录了 RDB 文件所在状态后的所有写命令，主服务器将在缓冲区的所有命令发送给从服务器，从服务器执行这些写命令

2. **增量同步（命令传播）**

   增量同步用于在主服务器的数据库状态被修改，导致主从数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态。主服务器每执行一个写命令就向从服务器发送相同的命令，slave接收并执行写命令，从而保持主从一致。

### 哨兵模式的原理

哨兵主要用于监控管理多个Redis服务器，主要是：监控、提醒以及故障转移。

每个哨兵都会向其他哨兵、master、slave定时发送消息，以确保对方是否还存活。如果发现对方在配置的指定时间内未回应，则暂时认为对方已挂。若多数哨兵认为master节点已经挂了，则系统认为该master彻底死亡，通过vote算法从剩下的slave选择一个slave升级为master。

### 哨兵模式故障迁移流程？

当一个从节点发现所属的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，执行步骤：

1. 下属的从节点通过选举产生一个节点
2. 被选中的从节点会执行 `SLAVEOF no one` 命令，成为新的主节点
3. 新的主节点会**撤销所有对已下线主节点的槽指派**，并将这些槽全部指派给自己
4. 新的主节点向集群广播一条 PONG 消息，让集群中的其他节点知道当前节点变成了主节点，并且接管了下线节点负责处理的槽
5. 新的主节点开始接收有关的命令请求，故障转移完成

缺点：

- 主从服务器要经常进行主从复制，这样会造成性能下降
- 当主服务器宕机后，从服务器变成主服务器那段时间，服务是不可用的

### Cluster 模式的原理？

Redis Cluster中有一个长度为16384的槽，Redis中的每一个Master节点都会负责一部分槽，当有某个key映射到Master负责的槽，那么这个Master负责为这个key提供服务。

### Cluster 的分片机制

### Cluster集群的扩容流程？

### Cluster集群收缩流程？

### 客户端如何路由

### 为什么是163834槽位

### 集群故障发现与迁移

## 如何实现分布式锁

## 如何实现排行榜功能

## 优化key

### 为什么要优化大key

### 如何优化热点key





