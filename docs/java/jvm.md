
## 1. JVM概述

### 基本介绍

JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作

特点：

* Java 虚拟机基于**二进制字节码**执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成
* JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的**跨平台性**

Java 代码执行流程：`Java 程序 --（编译）--> 字节码文件 --（解释执行）--> 操作系统（Win，Linux）`

JVM 结构：

![输入图片说明](https://foruda.gitee.com/images/1680661431049269530/9797d09b_8616658.png "屏幕截图")

JVM、JRE、JDK 对比：

* JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源
* JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件

<img src="https://foruda.gitee.com/images/1685092083266947052/3e227303_8616658.png" style="zoom: 80%;" />





***



### 架构模型

Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构

* 基于栈式架构的特点：
  * 设计和实现简单，适用于资源受限的系统
  * 使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现
    * 零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器
    * 一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数
  * 不需要硬件的支持，可移植性更好，更好实现跨平台
* 基于寄存器架构的特点：
  * 需要硬件的支持，可移植性差
  * 性能更好，执行更高效，寄存器比内存快
  * 以一地址指令、二地址指令、三地址指令为主


***



### 生命周期

JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡

- **启动**：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点
- **运行**：

  - main() 方法是一个程序的初始起点，任何线程均可由在此处启动
  - 在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，**JVM 使用的是守护线程，main() 和其他线程使用的是用户线程**，守护线程会随着用户线程的结束而结束
  - 执行一个 Java 程序时，真真正正在执行的是一个 **Java 虚拟机的进程**
  - JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多

    Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机
- **死亡**：

  - 当程序中的用户线程都中止，JVM 才会退出
  - 程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止
  - 线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作




## 2. 类加载子系统

每个编写出的`.java`文件都存储着需执行的程序逻辑，经过Java编译器编译后，会为每个`.java`文件生成对应的`.class`字节码文件，`.class`文件中则记录着Java代码转换之后的虚拟机指令，每个`.class`文件开头都有特定的标识、魔数版本等信息。

当JVM需要用到某个类时，虚拟机会加载它的`.class`文件，加载了相关的字节码信息后，会为它创建对应的`Class`对象，而这个过程就被称为类加载。但需额外注意的是：**类加载机制只负责`class`文件的加载，至于是否可以执行，则是由执行引擎决定**。



### 2.1 类加载过程

类是在运行期间**第一次使用时动态加载**的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间。

![输入图片说明](https://foruda.gitee.com/images/1680746577485342162/7a3bcfdb_8616658.png "屏幕截图")

#### 2.1.1 加载阶段

加载阶段是指通过完全限定名查找Class文件二进制数据并将其加载进内存的过程。加载过程完成以下三件事：

- 通过类的全限定名称获取定义该类的二进制字节流（**二进制字节码**）；

- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构（**Java 类模型**）；

- 在堆中间中为其创建一个`Class`对象，作为程序访问这些数据的入口

  ​

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础；
- 从网络中获取，最典型的应用是 Applet；
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类；
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码；

方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：

- `_java_mirror` 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用
- `_super` 即父类、`_fields` 即成员变量、`_methods` 即方法、`_constants` 即常量池、`_class_loader` 即类加载器、`_vtable` **虚方法表**、`_itable` 接口方法表

加载过程：

- 如果这个类还有父类没有加载，先加载父类；
- **加载和链接可能是交替运行的** ；
- Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互。

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类的生命周期-加载.png" style="zoom:80%;" />

创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：

- 如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型；
- JVM 使用指定的元素类型和数组维度来创建新的数组类；
- **基本数据类型由启动类加载器加载** 。

------

#### 2.1.2 链接阶段

连接步骤包含了验证、准备、解析三个阶段。这三个阶段中，前两个执行顺序是确定的，但解析阶段不一定，可能会发生在初始化之后。

##### 2.1.2.1 验证

验证阶段主要用于确保被加载的`Class`正确性，检测`Class`字节流中的数据是否符合虚拟机的要求，确保不会危害虚拟机自身安全。验证阶段主要包括四种验证：文件格式验证、元数据验证、字节码验证以及符号引用验证。

主要包括**四种验证**：

- **文件格式验证**；验证字节流是否符合`Class`文件格式的规范
  - `CA/FE/BA/BE`魔数验证
  - 主次版本号验证
  - 常量池中常量类型是否存在不被支持的类型验证
  - 指向常量池中的索引是否有指定不存在或不符合类型的常量

- **元数据验证**，对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；
  - 类是否有父类，除了`Object`之外，所有的类都应该有父类
  - 类的父类是否继承了不允许被继承的类（被`final`修饰的类）
  - 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
  - 类的字段/方法是否与父类的存在冲突。例如方法参数都一样，返回值却不同

- **字节码验证**，通过数据流和控制流分析，确定程序语义合法且符合逻辑；

  - 对类的方法体进行校验分析，保证在运行时不会做出危害虚拟机的行为

  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放了一个`int`类型的数据，读取时却按照`long`类型加载到本地变量表中的情况

  - 保障任何跳转指令都不会跳转到方法体之外的字节码指令上

    ​

- **符号引用验证**，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法，确保后续的解析动作能正确执行

  - 通过字符串描述的全限定名是否能找到对应的类
  - 符号引用中的类、字段、方法的可访问性是否可被当前类访问

  ​

##### 2.1.2.2 准备

准备阶段主要是为类中声明的**静态变量分配内存空间，并将其初始化成默认值（零值）**，使用的是方法区的内存。jdk1.7之后使用的是堆内存。

在这里进行的内存分配**仅包括类成员(`static`成员)**，同时也不包含使用`final`修饰的`static`成员，因为`final`在编译的时候就会分配了，准备阶段会显示初始化。

类变量分配空间都在准备阶段完成：

- 如果 static 变量是 **final 的基本类型以及字符串常量**，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化；
- 如果 static 变量是 **final引用类型**，赋值在初始化阶段完成。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

实例：

```java
// 仅static修饰的常量，初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123；
public static int value = 123;

// final修饰的static常量 value 被初始化为 123 而不是 0；
public static final int value = 123;

```

> Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故 boolean 的默认值就是 false。



##### 2.1.2.3 解析

将常量池中类、接口、字段、方法的**符号引用替换为直接引用**（内存地址）的过程；

- 符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和**方法描述符**（因为类还没有加载完，很多方法是找不到的）；
- 直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中；

例如：在 `com.demo.Solution` 类中引用了 `com.test.Quest`，把 `com.test.Quest` 作为符号引用存进类常量池，在类加载完后，**用这个符号引用去方法区找这个类的内存地址**

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等；

- 在类加载阶段解析的是非虚方法，静态绑定；
- 也可以在初始化阶段之后再开始解析，这是为了支持 Java 的**动态绑定** ；
- 通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用。

```java
public class Load2 {
    public static void main(String[] args) throws Exception{
    ClassLoader classloader = Load2.class.getClassLoader();
    // cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D
    Class<?> c = classloader.loadClass("cn.jvm.t3.load.C");
        
    // new C();会导致类的解析和初始化，从而解析初始化D
    System.in.read();
    }
}
class C {
	D d = new D();
}
class D {
}
```



#### 2.1.3 初始化

初始化步骤中，**静态类变量显示赋值并执行静态代码块**，本质上是执行类构造器方法`<clinit>()`的过程。

在**准备阶段**，类变量已经赋过一次系统要求的**默认初始值**；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行  `<clinit>` 。

在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init 。

类构造器  `<clinit>()`  与实例构造器  `<init>()` 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机**调用一次**，而实例构造器则会被虚拟机调用多次，只要程序员创建对象。

类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类。



类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。

**主动引用**：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：

1. 当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）
2. 当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化
   - getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）
   - putstatic：程序给类的静态变量赋值
   - invokestatic ：调用一个类的静态方法
3. 使用 java.lang.reflect 包的方法**对类进行反射调用**时，如果类没有进行初始化，则需要先触发其初始化
4. 当初始化一个类的时候，如果发现其**父类还没有进行过初始化，则需要先触发其父类的初始化**，但这条规则并**不适用于接口**
5. 当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类
6. MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类
7. 补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

**被动引用**：所有引用类的方式都不会触发初始化，称为被动引用

- 通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化
- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法
- 常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
- 调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化



###### 2.1.3.1 clinit 和 init

 `<clinit>()`：类构造器，由编译器自动收集类中**所有类变量的赋值动作和静态语句块**中的语句合并产生的，初始化阶段会先执行`<clint>()`方法，会为静态类变量显示赋值并执行静态代码块。

作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块；

- 如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成；
- clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法；
- static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定；
- static 不加 final 的变量都在初始化环节赋值。



`init` 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括**成员变量**初始化和**代码块**的执行

实例化即调用 `<init>()` ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行

类实例化过程：**父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员变量和实例代码块 -> 子类的构造函数**

new 关键字会创建对象并复制 dup 一个对象引用，一个调用 <init> 方法，另一个用来赋值给接收者



线程安全问题：

- 虚拟机会保证一个类的  `<clinit>()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的  `<clinit>()` 方法，其它线程都阻塞等待，直到活动线程执行  `<clinit>()` 方法完毕；
- 如果在一个类的  `<clinit>()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问 。

```java
public class Test {
    static {
        //i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  	// 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成  `<clinit>()` 方法，两者不同的是：

- 在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的  `<clinit>()` 方法不需要先执行父接口的     `<clinit>()` 方法；
- 在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的  `<clinit>()` 方法；
- 只有当父接口中定义的变量使用时，父接口才会初始化。



#### 2.1.4 卸载阶段

当一个Class对象不再被任何一处位置引用，即不可触及时，Class就会结束生命周期，该类加载的数据也会被卸载。

执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java 虚拟机进程终止

卸载类即该类的 **Class 对象被 GC**，卸载类需要满足3个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成

>  在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的



### 2.2 类加载器

类加载器的任务是，根据一个类的全限定名读取它的二进制字节流数据后，将其加载到内存中并转换为一个与该类对应的Class对象。

对于任意一个类，都必须有加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名空间。即比较两个类是否是同一个类（“相等”），必须是由同一个类加载器加载的前提下才有意义。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true



#### 2.2.1 启动类加载器

启动类加载器是使用C++语言实现的，是JVM自身的一部分，主要负责将`<JAVA_HOME>\lib`路径下的核心类库或`-Xbootclasspath`参数指定的路径下的jar包加载到内存中。

处于安全考虑，Bootstrap 启动类加载器**只加载包名为 java、javax、sun 等开头的类**，仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载；

**启动类加载器无法被 Java 程序直接引用**，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替。

#### 2.2.2 扩展类加载器

这由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap。它主要负责加载`<JAVA_HOME>\lib\ext`目录下或者由系统变量`-D java.ext.dir`指定位路径中的类库。开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载。

#### 2.2.3 应用程序类加载器

由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension；负责加载环境变量 classpath 或系统属性 `-D java.class.path` 指定路径下的类库；

这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器；可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器。



#### 2.2.4 自定义类加载器

由开发人员自定义的类加载器，上级是 Application

```java
public static void main(String[] args) {
    //获取系统类加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

    //获取其上层  扩展类加载器
    ClassLoader extClassLoader = systemClassLoader.getParent();
    System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@610455d6

    //获取其上层 获取不到引导类加载器
    ClassLoader bootStrapClassLoader = extClassLoader.getParent();
    System.out.println(bootStrapClassLoader);//null

    //对于用户自定义类来说：使用系统类加载器进行加载
    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
    System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

    //String 类使用引导类加载器进行加载的 --> java核心类库都是使用启动类加载器加载的
    ClassLoader classLoader1 = String.class.getClassLoader();
    System.out.println(classLoader1);//null

}
```

补充两个类加载器：

- SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联
- ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁



#### 2.2.5 加载机制

在 JVM 中，对于类加载模型提供了三种，分别为**全盘加载**、**双亲委派**、**缓存机制**。

- **全盘加载：**当一个类加载器负责加载某个 Class 时，该 Class 所**依赖和引用**的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入；
- **双亲委派：**某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，**依次递归**，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载；
- **缓存机制：**会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中。
  - 这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因。



#### 2.2.6 双亲委派

双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过**组合关系**（Composition）来实现，而不是继承关系（Inheritance）。

工作过程：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

双亲委派机制的优点：

Java类随着它的类加载器存在了一种优先级的层次关系，这样做的优势在于，可以避免一个类在不同层级的类加载器中重复加载，如果父类加载器已经加载过该类了，那么就不需要子类加载器再加载一次，保证全局唯一性。

可以保障Java核心类的安全性问题，比如通过网络传输过来一个`java.lang.String`类，需要被加载时，通过这种双亲委派的方式，最终找到`Bootstrap`加载器后，发现该类已经被加载，从而就不会再加载传输过来的`java.lang.String`类，而是直接返回`Bootstrap`加载的`String.class`。这样可以有效防止Java的核心API类在运行时被篡改，从而保证所有子类共享同一基础类，减少性能开销和安全隐患问题。



双亲委派机制的缺点：

检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但**顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类**（可见性）。

<img src="https://foruda.gitee.com/images/1680776931151593718/18d5c635_8616658.png" style="zoom: 50%;" />



------



##### 2.2.6.1 源码分析

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
       // 1. 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类
        Class c = findLoadedClass(name);
        
        // 2. 当前类加载器如果没有加载过
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 3. 判断当前类加载器是否有父类加载器
                if (parent != null) {
                    // 4. 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)
         			// 5. 父类加载器的 loadClass 方法，又会检查自己是否已经加载过
                    c = parent.loadClass(name, false);
                } else {
                    // 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader
          			// 则调用 BootStrap ClassLoader 的方法加载类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) { }

            if (c == null) {
                // 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载
                // 可以自定义 findClass() 方法
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            // 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析
            resolveClass(c);
        }
        return c;
    }
}
```



------



##### 2.2.6.2 破坏委派

双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式。

破坏双亲委派模型的方式：

- 自定义 ClassLoader

  - 如果不想破坏双亲委派模型，只需要重写 `findClass` 方法；
  - 如果想要去破坏双亲委派模型，需要去**重写 loadClass **方法。

- 引入**线程上下文类加载器**

  Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：

  - SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；
  - SPI 的实现类是由系统类（程序类）加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类；

  JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型。

- 实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）。

  IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构

  当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:

  1. 将以 java.* 开头的类，委派给父类加载器加载
  2. 否则，将委派列表名单内的类，委派给父类加载器加载
  3. 否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载
  4. 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载
  5. 否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载
  6. 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载
  7. 否则，类查找失败

  热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，**热替换的关键需求在于服务不能中断**，修改必须立即表现正在运行的系统之中

<img src="https://foruda.gitee.com/images/1680777486535354363/e9f4ffe9_8616658.png" style="zoom: 33%;" />



------







------



#### 2.2.7 自定义加载器

如果需要自定义类加载器，那么只需要继承`ClassLoader`类即可，但继承`ClassLoader`需要自己重写`findClass()`方法并编写加载逻辑。所以如果一般没有太过复杂的需求，可以直接继承`URLClassLoader`类，可以省略自己编写`findClass`方法以及文件加载转换成字节码流的步骤，使自定义类加载器编写更加简洁。

作用：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏

那什么情况下时，我们需要自定义类加载器呢？

1. 当`class`文件不在`classpath`路径下时，需要自定义类加载器加载特定路径下的`class`
2. 当一个class文件是通过网络传输过来的并经过了加密处理，需要首先对class文件做了对应的解密处理后再加载到内存中时，需要自定义类加载器
   - 案例：运维子平台有个需求需要一个编写Java代码的终端，那对于这种情况就需要将运维平台中编写的`class`文件经过网络传输过来，然后对其类进行加载
3. 线上环境不能停机时，要动态更改某块代码，这种情况下需要自定义类加载器
   - 比如：当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)



```java
//自定义类加载器，读取指定的类路径classPath下的class文件
public class MyClassLoader extends ClassLoader{
    private String classPath;

    public MyClassLoader(String classPath) {
        this.classPath = classPath;
    }
    
     public MyClassLoader(ClassLoader parent, String byteCodePath) {
        super(parent);
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
       BufferedInputStream bis = null;
        ByteArrayOutputStream baos = null;
        try {
            // 获取字节码文件的完整路径
            String fileName = classPath + className + ".class";
            // 获取一个输入流
            bis = new BufferedInputStream(new FileInputStream(fileName));
            // 获取一个输出流
            baos = new ByteArrayOutputStream();
            // 具体读入数据并写出的过程
            int len;
            byte[] data = new byte[1024];
            while ((len = bis.read(data)) != -1) {
                baos.write(data, 0, len);
            }
            // 获取内存中的完整的字节数组的数据
            byte[] byteCodes = baos.toByteArray();
            // 调用 defineClass()，将字节数组的数据转换为 Class 的实例。
            Class clazz = defineClass(null, byteCodes, 0, byteCodes.length);
            return clazz;
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (baos != null)
                    baos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (bis != null)
                    bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }
}
```

```java
public static void main(String[] args) {
    MyClassLoader loader = new MyClassLoader("D:\Workspace\Project\JVM_study\src\java1\");

    try {
        Class clazz = loader.loadClass("Demo1");
        System.out.println("加载此类的类的加载器为：" + clazz.getClassLoader().getClass().getName());//MyClassLoader

        System.out.println("加载当前类的类的加载器的父类加载器为：" + clazz.getClassLoader().getParent().getClass().getName());//sun.misc.Launcher$AppClassLoader
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
```



#### 2.2.7 热部署原理

全限定名相同的一个类被加载过之后，第二次需要用到该类时，会直接在类加载器的命名空间（可以理解为缓存）中进行查找，而不会二次加载此类，而强制指定同一个类加载器二次加载同一个类时，会抛出异常。所以一般类被加载一次之后，就算某个类的`class`文件发生了改变，JVM也不会再次加载它。

热部署机制就是通过利用不同的类加载器，去加载更改后的`class`文件，从而在内存中创建出两个不同的`Class`对象。从而达到类文件更改后可以生效的目的。

#### 沙箱机制

沙箱机制（Sandbox）：将 Java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，来保证对代码的有效隔离，防止对本地系统造成破坏

沙箱**限制系统资源访问**，包括 CPU、内存、文件系统、网络，不同级别的沙箱对资源访问的限制也不一样

- JDK1.0：Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码不可以访问本地资源，其实依赖于沙箱机制。如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现
- JDK1.1：针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限
- JDK1.2：改进了安全机制，增加了代码签名，不论本地代码或是远程代码都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制
- JDK1.6：当前最新的安全机制，引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，不同的保护域对应不一样的权限。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问

<img src="https://foruda.gitee.com/images/1680779146000794457/d28231a4_8616658.png" style="zoom:67%;" />



#### JDK9

为了保证兼容性，JDK9 没有改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行做了一些变动：

- 扩展机制被移除，扩展类加载器由于**向后兼容性**的原因被保留，不过被重命名为平台类加载器（platform classloader），可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取
- JDK9 基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数个 JMOD 文件），其中 Java 类库就满足了可扩展的需求，那就无须再保留 `<JAVA_HOME>\lib\ext` 目录，此前使用这个目录或者 `java.ext.dirs` 系统变量来扩展 JDK 功能的机制就不需要再存在
- 启动类加载器、平台类加载器、应用程序类加载器全都继承于 `jdk.internal.loader.BuiltinClassLoader`

------

## 



#### 2.2.5 常用API

ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）

获取 ClassLoader 的途径：

- 获取当前类的 ClassLoader：`clazz.getClassLoader()`
- 获取当前线程上下文的 ClassLoader：`Thread.currentThread.getContextClassLoader()`
- 获取系统的 ClassLoader：`ClassLoader.getSystemClassLoader()`
- 获取调用者的 ClassLoader：`DriverManager.getCallerClassLoader()`

ClassLoader 类常用方法：

- `getParent()`：返回该类加载器的超类加载器  
- `loadclass(String name)`：加载名为 name 的类，返回结果为 Class 类的实例，**该方法就是双亲委派模式**
- `findclass(String name)`：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用
- `findLoadedClass(String name)`：查找名称为 name 的已经被加载过的类，final 修饰无法重写
- `defineClass(String name, byte[] b, int off, int len)`：将**字节流**解析成 JVM 能够识别的类对象
- `resolveclass(Class<?> c)`：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析
- `InputStream getResourceAsStream(String name)`：指定资源名称获取输入流




## 3 执行引擎

Java的执行引擎子系统的主要任务是将字节码指令解释/编译成对应平台上的本地机器指令

目前主要的执行技术有：解释执行、静态编译、即时编译、自适应优化、芯片级直接执行，释义如下：

- 解释执行：程序在运行过程中，只有当每次用到某处代码时，才会将某处代码转换为机器码交给计算机执行。
- 静态编译：所谓的静态编译是指程序在启动前，先根据对应的硬件/平台，将所有代码全部编译成对应平台的机器码。
- 即时编译：程序运行过程中，通过相关技术（如HotSpot中的热点探测）动态的探测出运行比较频繁的代码，然后在运行过程中，将这些执行比较频繁的代码转换机械码并存储下来，下次执行时则直接执行机器码。
- 自适应优化：开始对所有的代码都采取解释执行的方式，并监视代码执行情况，然后对那些经常调用的方法启动一个后台线程，将其编译为本地代码，并进行仔细优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。
- 芯片级直接执行：也就是直接编写机器码的方式，编写出的代码可以直接被CPU识别，读取后可以直接执行。

### 3.1 执行引擎工作过程

在执行Java方法过程中，执行引擎可能会根据栈帧中操作数栈的引用信息，直接去访问存储在堆中的Java对象实例数据，也有可能会通过实例对象的对象头中记录的元数据指针（KlassWord）去定位对象的类型信息，也就是会通过元数据指针去访问元数据空间（方法区）中的数据。

#### 3.1.1 Java源码编译过程

编译是指将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范（编程语言）转化成机器容易理解的语言规范（由二进制序列组成的机械码）

javac作为Java语言的源码编译器，它编译的目的却不是为了针对于某个硬件平台进行编译的，而是为JVM进行编译，javac的任务就是将Java源代码转换为JVM可识别的字节码，也就是`.java`文件到`.class`文件的过程。

javac编译过程具体释义如下：

- ①词法分析：先读取源代码的字节流数据，然后根据源码语言的语法规则找出源代码中的定义的语言关键字，如if、else、while、for等，然后判断这些关键字的定义是否合法，对于合法的关键字生成用于语法分析的记号序列，同时创建符号表，将所有的标识符记录在符号表中，这个过程就被称为词法分析。
  - 符号表的作用：记录源代码中使用的标识符，收集每个表示符的各种属性信息。
  - 词法分析的结果：从源代码中找出一些合法的`Token`流，生成记号序列。
- ②语法分析：对词法分析后得到的Token流进行语法分析，就是依据源程序的语法规则，检查这些关键词组合在一起是否符合Java语言规范，比如if的后面是不是紧跟着一个布尔型判断表达式、else是否写在if后面等。对于符合规范的，组织上一步产生的记号序列生成语法树。
  - 语法分析的结果：形成一颗符合Java语言规定的抽象语法树。抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起，这棵语法树可以被后面按照新的规则再重新组织。
- ③语义分析：经过语法分析后就不存在语法错误这些问题了，语义分析主要任务有两个，一个是对上步产生的语法树进行检查，其中包括类型检查、控制流检查、唯一性检查等，第二个则是将一些复杂的语法转换为更简单的语法，相当于把一些文言文、古诗、成语翻译成大白话的意思。比如将foreach转化为for循环、循环标志位替换为break等。
  - 语义分析的结果：简化语法后会生成一棵语法树，这棵语法树也就更接近目标语言的语法规则。
- ④字节码生成：将简化后的语法树转换为Class文件的格式，也就是在该阶段会根据简化后的语法树生成字节码。
  - 字节码生成的结果：生成符合虚拟机规范的字节码数据。

#### 3.1.2 执行引擎执行过程

被加载进内存的字节码最终执行是由执行引擎来负责的，但JVM的执行引擎并不能真正的执行字节码指令，而是将字节码指令翻译成本地机械指令交由物理机的执行引擎来真正的执行的

HotSpot虚拟机是基于栈式的，也就代表着执行引擎在执行方法时，执行的是一个个的栈帧，栈帧中包含局部变量表、操作数栈、动态链接以及方法返回地址等描述方法的相关信息。但执行引擎在虚拟机运行时，只会执行最顶层的栈帧，因为最顶层的栈帧是当前需要执行的方法，执行完当前方法后会弹出顶部的栈帧，然后将下一个栈帧（新的顶部栈帧）拿出继续执行。

刚刚提到了方法的相关信息被存储在栈帧中，而栈帧的方法信息是从`class`字节码文件中读出来的，每个方法通过结构体`method_info`来描述，如下：

```c++
struct method_info
{
    u2 access_flags;         //方法修饰符掩码
    u2 name_index;           //方法名在常数表内的索引
    u2 descriptor_index;     //方法描述符，其值是常数表内的索引
    u2 attributes_count;     //方法的属性个数
    attribute_info **attributes;    //方法的属性表(局部变量表)
};

```

在`method_info`中存在一个`attribute_info`类型的成员`attributes`，该成员就是平时所说的局部变量表，其内也存放着方法参数和方法内的局部变量，当方法是实例方法时，局部变量表的第0位会被用来传递方法所属对象的引用，即`this`。Java虚拟机执行引擎是基于栈式的，栈就是操作数栈，操作数栈的深度也是记录在方法属性集合的`Code`属性中，同时`attributes`成员中也记录着局部变量表所需的空间大小。

### 3.2 执行引擎子系统

Java虚拟机的执行引擎子系统中包含两种执行器，分别为解释器和即时编译器。当执行引擎获取到由javac编译后的`.class`字节码文件后，在运行时是通过解释器(Interpreter)转换成最终的机械码执行。另外为了提升效率，JVM加入了一种名为 **JIT即时编译** 的技术，即时编译器的目的是为了避免一些经常执行的代码被解释执行，JIT会将整个函数编译为平台本地的机械码，从而在很大程度上提升了执行的效率。

#### 3.2.1 解释器

当Java程序运行时，在执行一个方法或某处代码时，会找到`.class`文件中对应的字节码，然后会根据定义的规范，对每条需执行的字节码指令逐行解释，将其翻译成平台对应对应的本地机械码执行。当一条字节码指令被解释执行完成后，紧接着会再根据PC寄存器（程序计数器）中记录的下一条需被执行指令，读取并再次进行解释执行操作。

#### 3.2.2 JIT即时编译器

解释器实现简单，并且具备非常优异的跨平台性，所以现在的很多高级语言都采用解释器的方式执行，比如`Python、Ruby、JavaScript`等，但对于编译型语言，如`C/C++、Go`等语言来说，执行的性能肯定是差一筹的，而前面不止一次提到过：Java为了解决性能问题，所以采用了一种叫做JIT即时编译的技术，也就是直接将执行比较频繁的整个方法或代码块直接编译成本地机器码，然后以后执行这些方法或代码时，直接执行生成的机器码即可。

####  3.2.3 热点探测技术

HotSpot VM的名字就可以看出这是一款具备热点代码探测能力的虚拟机，所谓的热点代码也就是指调用次数比较多、执行比较频繁的代码，当某个方法的执行次数在一定时间内达到了规定的阈值，那么JIT则会对于该代码进行深度优化并将该方法直接编译成当前平台对应的机器码，以此提升Java程序执行时的性能。

一个被多次调用执行的方法或一处代码中循环次数比较多的循环体都可以被称为 **热点代码** ，因此都可以通过JIT编译为本地机器指令。

##### 3.2.3.1 栈上替换

类似于`C/C++、GO`等编译型语言，都属于静态编译型，也就是指在程序启动时就会将所有源代码编译为平台对应的机器码，但JVM中的JIT却属于动态编译器，因为对于热点代码的编译是发生在运行过程中的，所以这种方式也被称之为 **栈上替换（On Stack Replacement）**，在有的地方也被称为OSR替换。

##### 3.2.3.2 方法调用计数器和回边计数器

在HotSpotVM中，热点代码探测技术主要是基于计数器实现的。HotSpot中会为每个方法创建两个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter），方法调用计数器主要用于统计方法被调用的次数，回边计数器主要用于统计一个方法体中循环体的循环次数。

**方法调用计数器**的阈值在`Client`模式下默认是1500次，在`Server`模式下默认是10000次，当一段代码的执行次数达到这个阈值则会触发JIT即时编译。当然，如果你对这些缺省（默认）的数值不满意，也可以通过JVM参数`-XX ：CompileThreshold`来自己指定。

当一个方法被调用执行时，会首先检查该方法是否已经被JIT编译过了，如果是的话，则直接执行上次编译后生成的本地机器码。反之，如果还没有编译，则先对方法调用计数器+1，然后判断计数器是否达到了规定的阈值，如果还未达到阈值标准则采用解释器的模式执行代码。如果达到了规定阈值则提交编译请求，由JIT负责后台编译，后台线程编译完成后会生成本地的机器码指令，这些指令会被放入`Code Cache`中缓存起来（热点代码缓存，存放在方法区/元数据空间中），当下次执行该方法时，直接从缓存中读取对应的机械码执行即可。



**回边计数器**的作用是统计一个**方法中循环体的执行次数**，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）。与方法调用计数器一样，当执行次数达到某个阈值后，也会触发OSR编译。



#### 3.2.3.3 热度衰减

一般而言，如果以缺省参数启动Java程序，那么方法调用计数器统计的执行次数并不是绝对次数，而是一个相对的执行频率，也代表是指方法在一段时间内被执行的次数。当超过一定的时间，但计数器还是未达到编译阈值无法提交给JIT即时编译器编译时，那此时就会对计数器进行减半，这个过程被称为方法调用计数器的热度衰减（Counter Decay），而这段时间则被称为方法调用计数器的半衰周期（Counter Half Life Time）。

而发生热度衰减的动作是在虚拟机GC进行垃圾回收时顺带进行的，可以通过参数`-XX：-UseCounterDecay`关闭热度衰减，这样可以使得方法调用计数器的判断基准变为绝对调用次数，而不是以相对执行频率作为阈值判断的标准。不过如果关闭了热度衰减，就会导致一个Java程序只要在线上运行的时间足够长，程序中的方法必然绝大部分都会被编译为本地机器码。

> 同时也可以通过`-XX：CounterHalfLifeTime`参数调整半衰周期的时间，单位为秒。

一般而言，如果项目规模不大，并且上线后很长一段时间不需要进行版本迭代的产品，都可以尝试把热度衰减关闭掉，这样可以使得Java程序在线上运行的时间越久，执行性能会更佳。









## 4 内存结构

内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫**运行时数据区**，其中包括线程共享的区域：**方法区（常量池）**、**堆**，以及线程私有的区域：**虚拟机栈**、**本地方法栈**、**程序计数器**。

JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行

* Java1.8 以前的内存结构图：

  <img src="https://foruda.gitee.com/images/1685092131354998066/e7b5d91d_8616658.png" style="zoom: 57%;" />

  ​

* Java1.8 之后的内存结果图：

  ![输入图片说明](https://foruda.gitee.com/images/1680661431049269530/9797d09b_8616658.png "屏幕截图")

jdk1.8之后，方法区变成了**元空间**，放在直接内存中，存储**CodeCache（即时编译代码）**、**运行时常量池**、**class文件本身（类元信息、属性方法、常量等）**；**静态变量**和**字符串常量池**放在堆中。



***

### 4.1 线程私有区

线程私有区的含义是指：对于每条线程而言，在创建它们时，JVM都会为它们分配的区域，这些内存区域的生命周期会随着线程的启动、死亡而创建和销毁。这些区域创建后，其他线程是不可见的，只有当前线程自身可以访问。

运行时数据区中的线程私有区域主要包含：**程序计数器、虚拟机栈、本地方法栈**。

#### 4.1.2 程序计数器

程序计数器是JVM为每条线程开辟的一块较小的区域，每条线程都有且只有一个程序计数器，线程之间不相互干扰。生命周期与线程一致，随线程启动而生，线程销毁而亡。同时也**是JVM所有内存区域中唯一不会发生OOM（`OutOfMemoryError`/内存溢出）的区域**，GC机制不会触及的区域。

主要是作为当前线程执行时的字节码行号指示器来使用的，当线程执行一个Java方法时，**记录线程正在执行的字节码指令地址**，当执行引擎处理完某个指令后，程序计数器需要进行对应更新，将指针改向下一条要执行的指令地址，执行引擎会根据PC计数器中记录的地址进行对应的指令执行。分支、循环、跳转、异常处理、线程恢复等基础功能都需要以来这几计数器来完成。

当线程在执行一些由`C/C++`编写的`Native`方法时，PC计数器中则为空（`Undefined`）。

除此作用之外，也可以保证线程发生CPU时间片切换后能恢复到正确的位置执行。由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

Java 反编译指令：`javap -v Test.class`

```java
// #20：代表去 Constant pool 查看该地址的指令
0: getstatic #20 		// PrintStream out = System.out;
3: astore_1 			// --
4: aload_1 				// out.println(1);
5: iconst_1 			// --
6: invokevirtual #26 	// --
9: aload_1 				// out.println(2);
10: iconst_2 			// --
11: invokevirtual #26 	// --
```



#### 4.1.3 虚拟机栈（Stack）

虚拟机栈也被称为Java栈，在JVM的内存区域中，栈主要是作为运行时执行的单位，栈的作用是负责程序运行时具体如何执行、如何处理数据等工作。生命周期与线程一致，**每个线程创建时都会为之创建一个虚拟机栈**。

当线程在执行一个Java方法时，都会为执行的方法生产一个**栈帧（Stack Frame）**，每个Java方法的调用到执行结束，对应着虚拟机栈中的一个栈帧的从入栈到出栈的过程，一个栈帧需要分配多大的内存空间，在编译器就已经确定了，不会受到运行时变量数据的大小影响。对于执行引擎而言，它只会对位于栈顶的栈帧元素（被称为**当前栈帧**）进行操作，与当前栈帧关联的方法被称为当前方法。

一个栈帧中主要包含**局部变量表、操作数栈、动态链接、方法出口**等信息。

![输入图片说明](https://foruda.gitee.com/images/1680661835615294963/d00d9929_8616658.png "屏幕截图")

##### 4.1.3.1 局部变量表

局部变量表是一个由**槽（`slot`）组成的数组**，用于存放当前实例**对象的引用信息、方法参数以及方法体内定义的基本数据类型变量、对象引用以及返回地址等信息**，在`Class`文件的方法表的`Code`属性的`max_locals`指定了该方法所需局部变量表的最大容量。

> 槽（`Slot`）：槽是局部变量表中的最小单位，规定大小为32bit，对于32bit大小的数据，如`int`类型的变量、指针压缩后的对象引用信息等，都会使用一个槽来存储。而对于64位的数据，如`long、double`类型的变量、未开启指针压缩的对象引用等数据，JVM会为其分配两个连续的槽空间进行存储。
> 局部变量表中每个槽位都会有个固定的索引下标值，在执行方法时，执行引擎会根据索引值去访问局部变量表的指定槽位，然后将数据加载到操作数栈中进行执行。

局部变量表中存储的数据只对于当前方法中有效，虚拟机在执行时，依靠于操作数栈与局部变量表中存储的数据完成执行操作。方法执行结束后，局部变量表会随着栈帧的的出栈/销毁而随之销毁。一般而言，如果当前方法属于构造方法或实例方法，那么这些方法的局部变量表中下标为`0`的槽位必然存储的是`this`引用，也就是局部变量表中的第一个位置会被用来放当前方法所属的对象引用，其他的局部变量会按照顺序在局部变量表中进行存储。



##### 4.1.3.2 操作数栈（Operand Stack）

操作数栈是一个遵循FILO先进后出模式的栈结构，在`Class`文件的结构定义中的`Code`属性的`max_stacks`定义了执行过程中最大的栈深度(会在编译器就确定一个方法的最大栈深度)。Java虚拟机是基于栈式的虚拟机，执行引擎中的解释器也是基于栈的工作模式，这个栈则是指操作数栈。

在执行一个方法时，首先会先创建一个与该方法对于的栈帧，该栈帧中的操作数栈最初是空的，在执行过程中，会根据字节码指令往栈中写入（入栈）和提取（出栈）数据。**操作数栈的主要目的是用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**。

> 与前面的局部变量表一样，操作数栈也是一个由`32bit`为单位的字节数组构成的，操作数栈中可支持存储的数据类型主要有：`int、long、float、double、reference、returnType`等类型，对于`byte、short、char`类型的数据会在入栈前被转为`int`类型放入栈中存储。
> 但与局部变量表不同的是：局部变量表是通过下标索引去访问存储的数据，而操作数栈中则是通过标准的压栈、出栈的方式完成数据访问。

同时因为操作数栈在运行时是位于内存中的，频繁的去对内存进行读写操作会影响执行速度，所以实际在执行过程中，**虚拟机会将栈顶元素全部缓存到物理CPU的寄存器或高速缓存（L1/L2/L3）中，以此降低对内存的读写次数**，从而提升执行引擎的执行效率。



##### 4.1.3.3 动态链接（Dynamic Linking）

虚拟机栈中的**每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用**，持有这个引用是为了支持方法调用过程中的动态链接（比如`invokedynamic`指令的调用）。

在Java源文件被编译成Class文件时，类中所有的变量、方法调用都会化为符号引用，然后保存在`class`文件的常量池中，在`class`文件中描述一个方法调用另一个方法时，就使用常量池中指向方法的符号引用来表示的。**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。

> 常量池：位于编译后生成的`class`字节码文件中。
> 运行时常量池：位于运行期间的元数据空间/方法区中。



##### 4.1.3.4 方法出口（Return Address）

一个方法当开始被执行引擎执行时，只有两种情况会导致方法退出，一种是在执行过程中遇到了正常返回的字节码指令，如：`ireturn、lreturn、dreturn、areturn、return`，释义如下：

- `ireturn`：返回值为`int、byte、char、short、boolean`类型时使用该指令返回
- `lreturn`：返回值为`long`类型时使用该指令返回
- `dreturn`：返回值为`double`类型时使用该指令返回
- `areturn`：返回值为引用类型时使用该指令返回
- `return`：无返回`void`、类或接口初始化方法时使用该指令返回

方法正常执行完成后退出的情况被称为**正常完成出口**，一般执行返回的字节码指令时，调用者的程序计数器会被作为返回的地址。

除开正常执行完成后退出的情况外，还有一种情况也会导致方法的退出，那就是方法执行过程中出现了异常，并且在方法体中没有处理该异常（没有`try/catch`），此时也会导致方法退出，这种情况下被称为**异常完成出口**，返回地址则需要通过异常处理器表来确定。

当一个方法执行结束退出时，会执行如下步骤：

- ①复原上层方法的局部变量表以及操作数栈。
- ②如果当前方法有返回值的情况下，把返回值压入调用者方法栈帧的操作数栈中。
- ③将PC计数器的地址指向改为方法下一条指令的位置，从而使得调用者正常工作。
- PS：异常退出的情况下，是不会给上层调用者返回任何值的。



##### 4.1.3.5 虚拟机栈的特点

采用数组这种快捷有效的存储方式，同时在运行时也被放在内存中，并且也会将操作数栈的栈顶数据放入高速缓存或寄存器中，所以从访问速度上来看，仅次于PC寄存器。

**虚拟机栈这块内存区域不存在垃圾回收，但是存在`OOM`**，在《Java虚拟机规范》中，对这个区域规定了两种异常：

- `StackOverflowError`：当前线程请求的栈深度大于虚拟机栈所允许的深度时抛出该异常。
- `OutOfMemoryError`：如果扩展时无法申请到足够的内存空间会抛出`OOM`异常。

> 对于每条线程的虚拟机栈大小可以通过`-Xss`参数进行调整，默认单位为字节，默认大小为`1MB/1024KB/1048576字节`。
>
> 设置栈内存大小：`-Xss size`   `-Xss 1024k`  ，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M



方法内的局部变量是否**线程安全**：

- 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全



#### 4.1.4 本地方法栈

本地方法栈和虚拟机栈差不多是类似的，区别在于虚拟机栈是用于执行Java方法的，而本地方法栈则是用于执行C所编写的`Native`本地方法。在程序运行之初，首先会在本地方法栈中登记`Native`本地方法，在执行引擎执行时，保存本地方法的相关数据（参数、局部变量等）。

因为是c编写的本地方法，所以本地方法库中的`Native`方法会被编译为基于本机硬件和操作系统的程序。本地方法执行是在os中执行的，并非在JVM中执行的，所以使用的是os的程序计数器而非JVM的程序计数器，当开始执行一个本地方法时，就会进入不再受虚拟机限制的环境，级别与虚拟机一样，可以直接访问JVM的任何内存区域，也可以直接使用CPU处理器的寄存器和本地内存等。而本地方法栈只是存储了线程要运行这个方法的必要信息，比如出口，入口，动态链接，局部变量表，操作数栈等。

> 不过在HotSpot虚拟机中，它将本地方法栈和虚拟机栈两者合二为一了。



原理：将本地的 C 函数（如 foo）编译到一个共享库（foo.so）中，当正在运行的 Java 程序调用 foo 时，Java 解释器利用 dlopen 接口动态链接和加载 foo.so 后再调用该函数

* dlopen 函数：Linux 系统加载和链接共享库
* dlclose 函数：卸载共享库

<img src="https://foruda.gitee.com/images/1685092297169372866/4b82b5d1_8616658.png" style="zoom:67%;" />



图片来源：https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md



****

### 4.2 线程共享区域

线程共享的含义是指：在运行时，这些区域对于程序中的所有线程而言都是可见的，这些区域的状态不会因为某一条线程的死亡而发生改变，这些区域创建后是与JVM同级别的，伴随JVM的生命周期共生共死。

运行时数据区中的线程共享去主要包含：堆空间、元数据空间（方法区）以及直接内存这三大块。



#### 4.2.1 堆

Java堆的作用与前面分析的Java栈不同，栈主要是作为运行时的单位，用于临时存储运行时需要以及产生的数据，而Java堆是存储的单位，主要解决的问题是数据存储问题，重点关注的领域是数据怎么存，放哪里，怎么放等。

堆空间会在JVM启动时被创建出来，对于JVM来说，堆空间是唯一的，每个JVM只会存在一个堆空间，同时容量大小会在创建时就被确定，当然，我们可以通过参数`-Xms `和`-Xmx`指定堆的起始内存大小和最大内存大小，当超过`-Xmx`参数指定的大小时则会抛出`OOM`。

> 默认情况下，如果不通过参数强制指定堆空间大小，那么JVM会根据当前所在的平台进行自适应调整，起始大小默认为当前物理机器内存的1/64，最大大小默认为当前物理机器内存的1/4。

在Java程序运行时，系统运行过程中产生的大部分实例对象以及数组对象都会被放到堆中存储。

> 创建Java堆时，本质上并不是直接在内存中划分了一块完整的空间给JVM，因为在《Java虚拟机规范》中提及到：堆空间在物理上可以是不连续的，只需要逻辑上视为连续即可。所以一个JVM的堆空间在实际的机器内存上，可能是由机器内存中多个不同位置的空间组成的



##### 4.2.1.1 分代堆空间

分代的含义是指在JVM运行过程中，堆空间是否会被分为不同的区域分别用于存储不同生命周期的对象实例.

JDK1.8之前的堆结构是完全分代的，也就是指逻辑+物理上都分代，在运行时物理内存会被划为几块不同的区域，也就是一个`Eden`区、两个`Survivor `区（`Form/To`区）以及一个`Old`区，从物理内存上来说各个区域都是完整且连续的内存，每块区域都用于存储不同周期的对象实例，相互之间并不干扰。

##### 4.2.1.2 不分代堆空间

到了JDK1.9时，G1正式出道，成为了JVM内嵌的默认GC器，Java堆空间从此出现了不分代的概念，但不分代也分为两种情况，一种是逻辑分代，物理不分代，另一种则是逻辑+物理都不分代。

> 逻辑分代，物理不分代（G1）：对象分配的逻辑上还是存在分代的思想，但是物理内存上不会再分为几块完整的分代空间。
> 逻辑+物理都不分代（ZGC、ShenandoahGC）：无论从对象分配的逻辑上还是物理内存上，都不存在分代的概念。



##### 4.1.2.3 JDK7及之前的堆空间内存划分

在JDK1.7及之前的JVM中，所有的GC器都是物理+逻辑都分代的，包括内嵌的默认GC器`Parallel Scavenge（新生代）+ Parallel Old（老年代）`也分代，所以一般堆空间会被划分为三个区域：新生代、年老代以及永久代：

- 新生代：一个`Eden`区、两个`Survivor`区（`Form/To`区），比例：`8:1:1`
- 年老代：一个`Old`区
- 永久代：方法区

![输入图片说明](https://foruda.gitee.com/images/1693796197331619867/7603ef82_8616658.png "JDK7及之前的堆构成")

新生代主要用于存储未达到年老代分配条件的对象，**其中`Eden`区是专门用来存储刚创建出来的对象实例**，两个`Survivor`区主要用于垃圾回收时给存活对象“避难”。

年老代主要用于存储达到符合分配条件的对象实例，比如达到“年龄”的对象以及过大“体积”的大对象等。
方法区/永久代主要用于存储类的元数据信息，如类描述信息、字段信息、方法信息、静态变量信息、异常表、方法表等。

> 默认情况下新生代和年老代的空间比例为`1:2`，新生代占`1/3`，年老代占`2/3`，当然也可以通过参数：`-XX:NewRatio=x`来指定比例，也可以通过`-Xmn`参数强制指定新生代的内存最大大小，如果和前面的`Ratio`参数冲突了则以后者为准。
> 新生代中，一个`Eden`区、两个`Survivor`区（`Form/To`区），默认比例为`8:1:1`，当然也可以通过参数`-XX:SurvivorRatio`调整这个空间比例。但实际上初始情况下是`6:1:1`，因为JVM存在自适应机制，当然也可以通过`-XX:-UseAdaptiveSizePolicy`参数关闭JVM的自适应机制（不推荐）。



##### 4.2.1.4、JDK8堆空间内存划分

到了JDK1.8的时候，JVM将永久代，也就是方法区整合成了元数据空间，并且将其移出了堆，将其放在堆空间外的本地内存中。
![输入图片说明](https://foruda.gitee.com/images/1693796306700482089/d7f5be5d_8616658.png "JDK8的堆构成")

JDK1.8的时和1.7差距不大，最大区别在于移除了方法区，在本地内存中加入了元数据空间来存储之前方法区中的大部分数据（原方法区中的数据并不是所有都被迁移到了元空间存储，有些数据被分散到了JVM各个区域）。除此之外，常量池在1.8的时候也被移到了堆外。



##### 4.2.1.5、JDK9堆空间内存划分

到了JDK1.9时，堆空间慢慢的开始了划时代的改变，在此之前，堆空间的布局都是采用分代存储的方式，无论从逻辑上还是从物理内存上，都是分代的。但是到了Java9的时候，因为默认GC器改为了G1，所以堆中的内存区域被划为了一个个的`Region`区。
![输入图片说明](https://foruda.gitee.com/images/1693796443968160488/f53b5530_8616658.png "JDK9的内存布局")

在JDK1.9时，G1将Java堆划分为多个大小相等的独立的`Region`区域，不过在`HotSpot`的源码`TARGET_REGION_NUMBER`定义了`Region`区的数量限制为`2048`个（实际上允许超过这个值，但是超过这个数量后，堆空间会变的难以管理）。

> 一般`Region`区的大小等于堆空间的总大小除以2048，比如目前的堆空间总大小为8GB，就是`8192MB/2048=4MB`，那么最终每个`Region`区的大小为`4MB`，当然也可以用参数`-XX:G1HeapRegionSize`强制指定每个`Region`区的大小，但是不推荐，毕竟默认的计算方式计算出的大小是最适合管理堆空间的。
> G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是可以不连续物理内存来组成的`Region`的集合。

默认新生代对堆内存的初始占比是5%，如果堆大小为8GB，那么年轻代占据`400MB`左右的内存，对应大概是`100`个`Region`区，可以通过`-XX:G1NewSizePercent`设置新生代初始占比。

在Java程序运行中，JVM会不停的给新生代增加更多的`Region`区，但是最多**新生代的占比不会超过堆空间总大小的60%**，可以通过`-XX:G1MaxNewSizePercent`调整（也不推荐，如果超过这个比例，年老代的空间会变的很小，容易触发全局GC）。新生代中的`Eden`区和`Survivor`区对应的`Region`区比例也跟之前一样，默认8:1:1，假设新生代现在有400个`Region`，那么整个新生代的占比则为`Eden=320,S0/From=40,S1/To=40`。

G1中的年老代晋升条件和之前的无差，达到年龄阈值的对象会被转入年老代的`Region`区中，不同的是对于大对象的分配，在G1中不会让大对象进入年老代，在G1中由专门存放大对象的`Region`区叫做`Humongous`区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入`Humongous`区存储。

> 在G1中，判定一个对象是否为大对象的方式为：对象大小是否超过单个普通`Region`区的50%，如果超过则代表当前对象为大对象，那么该对象会被直接放入`Humongous`区。比如：目前是8GB的堆空间，每个`Region`区的大小为`4MB`，当一个对象大小超过`2MB`时则会被判定为属于大对象。

`Humongous`区存在的意义：可以避免一些“短命”的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的GC开销。

当堆空间发生全局GC(`FullGC`)时，除开回收新生代和年老代之外，也会对`Humongous`区进行回收。

##### 4.2.1.6、JDK11堆空间内存划分

在JDK11的时候，Java又推出了一款新的垃圾回收器`ZGC`，它也是一款基于`Region`区内存布局的GC器，这款GC器是真正意义上的不分代，无论是从逻辑上还是物理上都不分代。
![输入图片说明](https://foruda.gitee.com/images/1693796563205942805/46308bb2_8616658.png "JDK11的堆结构")
在ZGC中，也会把堆空间划分为一个个的`Region`区域，但ZGC中的`Region`区不存在分代的概念，它仅仅只是简单的将所有`Region`区分为了大、中、小三个等级：

- 小型`Region`区(`Small`)：固定大小为`2MB`，用于分配小于`256KB`的对象。
- 中型`Region`区(`Medium`)：固定大小为`32MB`，用于分配`>=256KB ~ <=4MB`的对象。
- 大型`Region`区(`Large`)：没有固定大小，容量可以动态变化，但是大小必须为`2MB`的整数倍，专门用于存放`>4MB`的巨型对象。但值得一提的是：每个`Large`区只能存放一个大对象，也就代表着你的这个大对象多大，那么这个`Large`区就为多大，所以一般情况下，`Large`区的容量要小于`Medium`区，并且需要注意：`Large`区的空间是不会被重新分配的（GC篇章详细分析）。

> PS：实际上，JDK11中的ZGC并不是因为要抛弃分代理念而不设计分代的堆空间的，因为实际上最开始分代理念被提出的本质原因是源于「大部分对象朝生夕死」这个概念的，而实际上大部分Java程序在运行时都符合这个现象，所以逻辑分代+物理不分代是堆空间最好的结构方案。但问题在于：ZGC为何不设计出分代的堆空间结构呢？其实本质原因是分代实现起来非常麻烦且复杂，所以就先实现出一个比较简单可用的单代版本，后续可能会优化改进（但实际上能不能改进成功还不好说，ZGC的研发团队负责人`Per`是从`JRockit`GC组过来的，R大在和`per`聊天时曾聊到过：`per`之前在`JRockit`GC器上尝试了四五次都以失败告终，ZGC上能不能成功还是得看未来了）。



Heap 堆：是 JVM 内存中最大的一块，由所有**线程共享**，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题。

堆空间大致可以分为**新生代**和**老年代**，再细致一点，可以分为**Eden空间**、F**rom Survivor**、**To Survivor**空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

堆中主要存放**对象实例**、**字符串常量池（String Table）**、**静态变量**、**TLAB** 。

* 对象实例：类初始化生成的对象，**基本数据类型的数组也是对象实例**，new 创建对象都使用堆内存。
* 字符串常量池：
  * 字符串常量池原本存放于方法区，JDK7 开始放置于堆中。
  * 字符串常量池**存储的是 String 对象的直接引用或者对象**，是一张 string table。
* 静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中。
* 线程分配缓冲区（Thread Local Allocation Buffer）：线程私有但不影响堆的共性，可以提升对象分配的效率。

设置堆内存指令：`-Xmx Size`

内存溢出：new 出对象，循环添加字符数据，当堆中没有内存空间可分配给实例，也无法再扩展时，就会抛出 OutOfMemoryError 异常。

> ❓  什么情况下会内存溢出？

堆内存诊断工具：（控制台命令）

1. **jps**：查看当前系统中有哪些 Java 进程。
2. **jmap**：查看堆内存占用情况 `jhsdb jmap --heap --pid 进程id` 。
3. **jconsole**：图形界面的，多功能的监测工具，可以连续监测。





#### 4.2.2 本地内存

运行时数据区中的本地内存主要可分为两块，一部分为元数据空间（原方法区），另一部分则为直接内存。在任何一个平台上运行一个进程，操作系统都会为其分配对应的内存，JVM也不例外，在启动时也会向操作系统申请资源分配（内存、CPU、线程数等）。但值得注意的是：元数据空间和直接内存这两块区域，并不处于OS为JVM分配的内存中，而是直接使用物理机的内存进行数据存放，但是**本地内存**还是会被JVM管理。



##### 4.2.2.1 元数据空间（Metaspace）

元数据空间则是1.8移除掉方法区（永久代）之后的产物，主要用于存放运行时常量池和类信息。

而之前方法区运行时常量池中的字符串常量池则被放置在了堆中，因为**在程序运行过程中会随着运行时间的增加，字符串常量池中的字符串会越来越多，所占空间会越来越大**，所以将其放在堆中的好处在于：**使得字符串常量池在GC机制的范围之内，字符串也会存在回收操作**。

同时除开字符串常量池被挪动到了堆内之外，类的静态变量的存储也被放在了堆中。对比如下：

![输入图片说明](https://foruda.gitee.com/images/1693797697446552109/eafc1639_8616658.png "JDK1.6/1.7/1.8变化")

> 方法区也就是所谓的永久代/持久代，方法区中主要存储了可以通过反射机制拿到的所有数据，如`Class`类信息、`Method`方法信息、`Filed`字段信息，**方法区需要多少的空间具体会取决于JVM运行时会加载多少类**，因为经过类加载后的`Class`文件会生成类的元数据，然后将其存储在这块区域。当然，当一个类被卸载时，该类数据占用的空间也会在FullGC发生时伴随一起释放。
>
> 方法区主要存储的数据：类的元数据、VM内部表、类的层级信息/方法信息/字段信息、方法的编译信息和字节码数据、静态变量、常量池以及符号引用。
>
> 在JDK1.7时，方法区的默认最大空间为64MB，也可以通过参数`-XX:MaxPermSize`调整。



**为什么JDK1.8时会移除方法区呢？**

其实在JDK1.7的时候就已经为1.8移除方法区在开展准备工作了，在1.7的时候已经将原本放在方法区的字符串常量池移动到了堆中，而在1.8的时候全面移除了方法区的存在，具体原因主要有三个：

1. 方法区不容易设置大小，给大了浪费空间，给小了容易OOM，比如`Tomcat`部署多个工程，加载大量jar包就容易导致方法区OOM。
2. 圾回收机制对于永久代的回收效率比较低，并且为GC带来了一些不必要的复杂度。
3. 为了更好的融合Sun HotSpot和BEA JRockit两款虚拟机，因为只有HotSpot中存在方法区的概念，其他的虚拟机中都不存在此概念，所以为了Oracle HotSpot更好的“前途”，所以干脆移除了方法区，从而达到Sun HotSpot和BEA JRockit完美融合的目的。






##### 4.2.2.2 直接内存

直接内存这块区域不是虚拟机的内存区域，在《Java虚拟机规范》中也没有定义，在创建时会直接向操作系统申请内存空间，属于直接使用物理内存的一块区域，也被称为“堆外空间”。

对比堆空间而言，访问直接内存的速度会超出堆内存，也就是读写性能优于Java堆，来源于Java的NIO库，**Java的NIO可以允许Java程序直接使用本地的直接内存存储数据缓冲**，因为如果把一些文件数据转为对象存储在堆中时，很容易导致堆空间负载过重而OOM。所以出于性能和稳定性两方面的考虑，一般对于一些读写频繁的场景或读取/写出大文件时的场景都可以使用直接内存进行操作。

> 如果程序中需要用到直接内存时可以通过`java.nio.ByteBuffer`来创建，调用`allocateDirect`方法申请即可，同时可以通过存在堆中的`DirectByteBuffer`操作直接内存。

直接内存的最大空间值可以通过`-XX:MaxDirectMemorySize`设置，如果不指定则默认与`-Xmx`参数设置的空间大小一致。直接内存属于比较昂贵的资源，因为需要直接向OS申请，所以分配成本较高，并且创建出来之后也不受JVM的直接控制，所以GC机制对于这块区域的内存空间难以管理，只有当发生`FullGC`时才会对于这块区域进行回收。

> 同时这块区域是也会出现OOM的，因为物理机的内存终归是有限的，受到硬件的限制，所以如果一直向操作系统申请直接内存使用，完事后JVM的GC机制又无法有效回收使用过的内存，可能在下一次`FullGC`到来之前就会将物理机分配的内存空间申请耗尽，从而引发OOM。

所以一般在使用直接内存的时候，不能将希望寄托给GC机制的全局GC来管理内存。





#### 方法区

方法区：是各个**线程共享**的内存区域，用于存储已被虚拟机加载的**类信息**、**常量**、**即时编译器编译后的代码**等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）。

![输入图片说明](https://foruda.gitee.com/images/1681442392140816006/bdc35a9e_8616658.png "屏幕截图")

方法区是一个 JVM 规范，**永久代与元空间都是其一种实现方式**。

方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)。

方法区的 GC：针对**常量池的回收**及对**类型的卸载**，比较难实现。

为了**避免方法区出现 OOM**，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，**静态变量和字符串常量池等放入堆中**。

类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表。

常量池表（Constant Pool Table）是 Class 文件的一部分，存储了**类在编译期间生成的字面量、符号引用**，JVM 为每个已加载的类维护一个常量池。

- 字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等。
- 符号引用：类、字段、方法、接口等的符号引用。

运行时常量池（（Runtime Constant Pool））是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

* 常量池（编译器生成的字面量和符号引用）中的数据会在类加载的加载阶段放入运行时常量池。
* 类在解析阶段将这些符号引用替换成直接引用。
* 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。


***









***





***



### 变量位置

变量的位置不取决于它是基本数据类型还是引用数据类型，而是取决于它的**声明位置。**

静态内部类和其他内部类：

* **一个 class 文件只能对应一个 public 类型的类**，这个类可以有内部类，但不会生成新的 class 文件。

* 静态内部类属于类本身，加载到方法区，其他内部类属于内部类的属性，加载到堆（待考证）。

类变量：

* **类变量**是用 `static` 修饰符修饰，定义在**方法外**的变量，随着 Java 进程产生和销毁。
* 在 Java8 之前把静态变量存放于方法区，在 Java8 时存放在**堆中**的**静态变量区**。


实例变量：

* 实例（成员）变量是定义在类中，没有 static 修饰的变量，随着类的实例产生和销毁，是类实例的一部分
* 在类初始化的时候，从**运行时常量池**取出**直接引用**或者**值**，**与初始化的对象一起放入堆中**。

局部变量：

* 局部变量是定义在类的方法中的变量。
* 在所在方法被调用时**放入虚拟机栈的栈帧**中，方法执行结束后从虚拟机栈中弹出。

> ❓ 类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？

* **类常量池**与**运行时常量池**都存储在**方法区**，而**字符串常量**池在 Jdk7 时就已经从方法区迁移到了 Java **堆**中。
* 在类编译过程中，会把**类元信息**放到**方法区**，类元信息的其中一部分便是类常量池，主要存放**字面量**和**符号引用**，而字面量的一部分便是文本字符。
* **在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池** 。
* 对于文本字符，会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池。

什么是字面量？什么是符号引用？

* 字面量：java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示

  ```java
  int a = 1;				//这个1便是字面量
  String b = "iloveu";	//iloveu便是字面量
  ```

* 符号引用：在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址。




## 5 OOM

OOM具体含义是指`OutOfMemoryError`内存溢出错误。在JVM的运行时数据区中，除开程序计数器之外，其他的区域都会存在内存溢出的风险。

### 5.1 堆OOM

Java堆空间是用于存储**对象实例和数组数据**的内存区域，同时JVM的GC机制也会重点对于这块区域进行内存管理。但是如果内存不足发生GC时，堆中的对象都还存活，此时又没有足够的内存分配新的对象实例，最终堆空间就会出现OOM

> `-XX:+HeapDumpOnOutOfMemoryError`：可以让虚拟机在出现内存溢出异常时Dump出内存堆运行时快照，可以使用`VisualVM`堆快照进行分析



#### 2.1.1、堆空间OOM的原因

1. 内存中加载**数据量过于庞大**导致OOM，如一次性从数据库中查询出几千万条数据导致创建出一个超大型的数据数组。

2. 集合对象中存在对象的引用，使得集合中的一些**失效对象无法被GC回收**。

3. 代码中存在**逻辑不正确的循环**导致在特定情况下产生了大量重复的对象实例。

4. 使用第三方依赖时，**第三方依赖中存在BUG**，导致运行时生成大量对象。

5. JVM启动时，使用参数为其**分配的堆空间过小**，导致程序正常运行的内存都不足够。

6. 程序中存在**无限递归调用**，导致一直生成对象OOM。

7. **系统流量超出原有的预估值**，导致大量请求进入系统，创建大量对象，内存过小OOM。

   ​

其实本质上来说，线上环境引发Java堆OOM的原因有很多，但归根到底就那几个：

1. 程序正常运行，**堆中存活对象过多无法回收**，新对象没有内存分配导致的。
2. **代码中存在不规范的语法**，因代码原因导致运行过程中出现OOM，如无限递归/死循环/用完后不释放等。
3. 运行过程中**出现了内存泄露**，泄露问题一点点将内存蚕食掉了，导致最终可用内存变得很小，从而诱发OOM。

#### 5.1.2、堆OOM问题排查

一般而言，线上环境出现问题后，总会分为固定的几个步骤，从发现问题出发，慢慢到后续的排查问题、定位问题、解决问题、尝试最优解、适当考虑拓展性，这是解决问题的一条完整链路。

如前面的堆空间OOM问题，从发生问题之后，首先应该通过相关的一些JVM工具，对日志进行`dump`分析，定位出可能发生该问题的几个可疑位置，然后对这些位置依次进行排查，最终定位到具体是由于什么原因导致的OOM，再“对症下药”，堆OOM问题解决方案一般有以下几种：

1. 如果确定是代码问题，则通过工具定位到具体的代码，然后对代码进行改正即可。
2. 如果确实是所分配的堆空间无法保障JVM的正常运行了，那么应该分配更大的堆空间。
3. 如果是因为内存泄露导致的OOM，那么则应该进一步定位内存泄露出现的原因，然后进行对应的解决。

#### 5.1.3、GC overhead limit exceeded

在Java程序执行过程中，如果当JVM花费了98%以上的时间在GC，但成功回收的内存不足2%，并且该动作重复五次时，就会抛出`java.lang.OutOfMemoryError:GC overhead limit exceeded`错误，这种情况就属于分配的空间不足以支撑系统的正常开销，导致程序耗尽了所有的内存资源，GC机制想回收也束手无策。这种情况下一般都可以先尝试加大堆内存解决。



### 5.2 栈OOM

关于Java栈的内存溢出主要可分为本地方法栈和虚拟机栈OOM，但在HotSpot中将两者合一了，所以在该虚拟机中只存在虚拟机栈OOM的问题，但虚拟机栈除开会出现OOM外，还会出现另一种内存问题：`SOF`，如下：

- `StackOverflowError`：当前线程请求的栈深度大于虚拟机栈所允许的深度时抛出该异常。
- `OutOfMemoryError`：如果扩展时无法申请到足够的内存空间会抛出`OOM`异常。

#### 5.2.1 栈SOF

关于Java栈的内存溢出主要可分为本地方法栈和虚拟机栈OOM，但在HotSpot中将两者合一了，所以在该虚拟机中只存在虚拟机栈OOM的问题，但虚拟机栈除开会出现OOM外，还会出现另一种内存问题：`SOF`，如下：

- `StackOverflowError`：当前线程请求的栈深度大于虚拟机栈所允许的深度时抛出该异常。
- `OutOfMemoryError`：如果扩展时无法申请到足够的内存空间会抛出`OOM`异常。

在运行过程中，一条线程在执行一个方法时，无论是栈帧太大还是虚拟机栈容量太小，当无法分配内存时都会抛出`SOF`问题。

栈OOM的条件为：**如果栈空间扩展时无法申请到足够的内存空间会抛出OOM异常。** 但是这个条件在HotSpot中几乎很难达到，因为虚拟机栈所需的空间大小，在编译期就已经确定了，在运行期间机会很少存在会发生Java栈动态扩容的情况



#### 5.2.2 栈OOM原因及解决方案

虚拟机栈这块区域出现OOM的原因大多数情况下就只存在两种，一种是**无限递归导致产生大量栈帧**引发的问题，另外一种则是**无限创建新线程导致耗尽了物理内存**抛出的问题。其实这两种并不算真正意义上的虚拟机栈OOM，前者被称为SOF问题，后者则是因为资源耗尽导致的。

- SOF问题：
  - 产生原因：一般是因为无限递归导致的。
  - 解决方案：优化代码，可以使用递归，但是不要产生无限递归。
- `Unable to create new native thread`问题：
  - 产生原因：
    1. 线程数超过了操作系统最大线程数`ulimit`的限制。
    2. 线程数超过了`kernel.pid_max`一个进程中规定的内核映射数。
    3. 申请创建线程时，物理机内存被耗尽，没有足够内存分配新线程。
  - 解决方案：
    - 升级硬件配置
    - 使用`-Xss`缩小Java栈的大小
    - 修改操作系统默认参数

### 5.3 元空间和运行时常量池OOM

元数据空间主要存储类名、访问修饰符、常量池、字段描述、方法描述等信息，对于测试元数据空间的内存溢出基本思路是：在运行时产生大量类字节码，从而使得元数据空间内存被耗尽，从而抛出OOM。

#### 5.3.1 元数据空间OOM的原因及解决方案

元数据空间溢出的原因主要存在如下几种：

1. 加载的类信息过多，导致OOM
2. JIT生成的热点代码过多，导致OOM
3. 运行时常量池溢出，导致OOM

> 对于这块区域的OOM，因为是位于**本地内存**的原因：
>
> 1. **由于cglib生成了大量的代理类**这种原因导致的OOM外
> 2. 因为分配的内存不足以支撑运行时产生的数据导致的，这种情况下一般通过对应的参数调大分配的空间即可
>
> 但如果是因为cglib代理导致的OOM，那么可以开启`-XX:+CMSClassUnloadingEnabled `和`-XX:+UseConcMarkSweepGC`参数，允许JVM卸载类，因为默认情况下，JVM是不会卸载类的，这些动态代理生成的类生命周期很短暂，加载使用一次后可能很长时间内不会再使用它们，此时就可以让JVM将这些类自动卸载掉。

### 5.4 直接内存OOM

直接内存的空间大小可以通过`-XX:MaxDirectMemorySize`参数指定

直接内存OOM主要存在两种原因，

1. 一种为**申请后没有合理释放**，在FullGC来临之前耗尽了分配的所有空间；
2. 第二种则是因为**申请的内存大小超出了直接内存的可用内存大小**。

这两种情况，**前者可以尽量保证自己在使用完直接内存后手动回收**，不要依赖JVM的GC机制管理内存，后者则可以**通过调大直接内存的空间大小，确保有足够的内存使用**。

### 5.5 Out of swap space

`Out of swap space`代表所有可用的**虚拟内存已被耗尽**，虚拟内存是由物理内存和交换空间两部分组成的，当运行时程序请求的虚拟内存溢出时就会抛出该错误。出现该问题的原因主要有两个，一个是地址空间不足，另一个则是物理内存已被耗尽，解决方案一般是只能提升硬件配置。

#### 5.6 Kill process or sacrifice child

`Kill process or sacrifice child`这种OOM的情况，属于Linux操作系统抛出的错误，当系统可用内存快耗尽时，内核的`Out of Memory Killer`组件会对所有进程进行打分，然后会尝试杀死一些评分低的进程，释放它们占用的内存空间来确保拥有足够的内存维护OS的运行。

一般来说，Java程序中是不必担心遇到这个问题的，因为“打分”这一操作，会基于活跃度进行，而Java程序部署之后，一般情况下都会处于持续运行的状态。

#### 5.7 Requested array size exceeds VM limit

JVM限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。因为数组这种数据结构，要求在分配时，物理内存必须连续，所以当分配一个巨型数组时，发现堆空间中已经没有一块这么大的连续空间，并且GC之后还是分配不下，那么就会抛出`Requested array size exceeds VM limit`错误。

如果你在程序中，遇到了这种问题，那么一般都是需要从业务上进行拆分，对于如此巨大的数组可以分为多次查询，将其分割为多个不同的小数组分配即可。

## 6 内存泄露

### 6.1 内存泄露

内存泄露是指程序**分配的内存**由于某些原因**未释放或无法释放**，造成系统内存的浪费。针对于Java而言，是指申请的内存空间没有被正确释放，存储在该区域的数据使用完后没有被回收，而指向这块区域的直接指针却不存在了，但还有其他引用可以关联到该区域，造成数据已经失效，引用链依旧保持，GC无法回收的情况出现，最终导致后续程序里这块内存被永远占用（不可达），内存空间就这么一点点被蚕食，最后导致程序运行缓慢、内存耗尽的问题出现。

在Java中典型的内存泄露案例是使用`ThreadLocal`。除此之外，在Java程序中大量的`static`成员、未正确关闭连接、不正确的`equals()`和`hashCode()`、引用了外部类的内部类、非正确的重写`finalize()`方法、常量字符串等原因都有可能导致Java应用发生内存泄露。

内存泄露从发生方式的角度来看，可以大致被分为四类：

1. 常发性内存泄漏：这种情况是指发生内存泄露的代码会被多次执行到，每次执行都会导致一块内存区域泄露。
2. 偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。
3. 一次性内存泄漏：发生内存泄漏的代码在程序执行过程中只会被执行一次，二次执行时却正常无误。
4. 隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。

> 相对来说，不管是那种泄露方式在Java中都比较难碰到，因为Java有完善的GC机制存在，所以发生内存泄露的几率很小很小，尤其是在目前的Java新版本中，发生几率几乎为零。不过在早期的JDK版本中发生内存泄露的几率还是蛮大的，因为早期Sun HotSpot中没有对method area进行有效回收，从而使得Java程序在执行过程中经常出现该问题。

在程序抛出OOM问题时，一般是先通过内存映像分析工具(如`Eclipse Memory Analyzer`)对`dump`出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。
如果是内存泄漏，可进一步通过工具（如`Jrockit`等工具）查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。



## 7 JVM中的对象

### 7.1 对象内存布局

一个 Java 对象内存中存储为三部分：**对象头**（Header）、**实例数据**（Instance Data）和**对齐填充** （Padding）。

#### 7.1.1 对象头

对象头主要由`MarkWord、KlassWord`和有可能存在的数组长度三部分组成。MarkWord主要是用于存储对象的信息以及锁信息，KlassWord则是存储指向元空间中类元数据的指针；如果当前对象是数组，那么也会在对象头中存储当前数组的长度

对象分为普通对象和数组对象：

- 普通对象：分为两部分

  - **Mark Word**：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等

    ```ruby
    hash(25) + age(4) + lock(3) = 32bit					#32位系统
    unused(25+1) + hash(31) + age(4) + lock(3) = 64bit	#64位系统
    ```

  - **Klass Word**：类型指针，**指向该对象的 Class 类对象的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 **Java 中的一个引用的大小**）

    ```ruby
    |-----------------------------------------------------|
    | 				  Object Header (64 bits) 			  |
    |---------------------------|-------------------------|
    | 	 Mark Word (32 bits)	|  Klass Word (32 bits)   |
    |---------------------------|-------------------------|
    ```

- 数组对象：如果对象是一个数组，那在对象头中还有一块数据用于记录数组长度（12 字节）

  ```ruby
  |-------------------------------------------------------------------------------|
  | 						  Object Header (96 bits) 							    |
  |-----------------------|-----------------------------|-------------------------|
  |  Mark Word(32bits)    | 	  Klass Word(32bits) 	  |   array length(32bits)  |
  |-----------------------|-----------------------------|-------------------------|
  ```

#### 7.1.2 实例数据

实例数据是指一个聚合量所有标量的总和，也就是是指当前对象属性成员数据以及父类属性成员数据

#### 7.1.3 对齐填充

对齐填充在一个对象中是可能存在，也有可能不存在的，因为在64bit的虚拟机中，《虚拟机规范》中规定了：为了方便内存的单元读取、寻址、分配，Java对象的总大小必须要为8的整数倍，所以当一个对象的对象头+实例数据大小不为8的整数倍时，此刻就会出现对齐填充部分，将对象大小补齐为8的整数倍。

#### 7.1.4 指针压缩

指针压缩属于JVM的一种优化思想，一方面可以节省很大的内存开支，第二方面也可以方便JVM跳跃寻址，在64bit的虚拟机中为了提升内存的利用率，所以出现了指针压缩这一技术，指针压缩的技术会将Java程序中的所有引用指针(类型指针、堆引用指针、栈帧内变量引用指针等)都会压缩一半，而在Java中一个指针的大小是占一个字宽单位的，在64bit的虚拟机中一个字宽的大小为64bit，所以也就意味着在64位的虚拟机中，指针会从原本的64bit压缩为32bit的大小，而指针压缩这一技术在JDK1.7之后是默认开启的。

指针压缩失效：指针压缩带来的好处是无可厚非，几乎能够为Java程序节省很大的内存空间，一般而言，如果不开启压缩的情况下对象内存需要14GB，在开启指针压缩之后几乎能够在10GB内存内分配下这些对象。但是压缩技术带来好处的同时，也存在非常大的弊端，因为指针通过压缩技术后被压缩到32bit，而Java中32bit的指针最大寻址为32GB，也就代表着如果你的堆内存为32G时出现了OOM问题，你此时将内存扩充到48GB时仍有可能会出现OOM，因为内存超出32GB后，32bit的指针无法寻址，所有压缩的指针将会失效，发生指针膨胀，所有指针将会从压缩后的32Bit大小回到压缩前的64Bit大小。

> 32bit的指针不是最大才支持4GB（2的32次方）内存嘛？为什么Java中32bit的指针支持寻址32GB呢？其实这跟前面所说的对齐填充存在巨大的联系。在前面提到过，64位的虚拟机中，对象大小必须要为8的整数倍，如果当一个对象总大小不足8的整数倍时会出现对齐填充补齐。
> 从这个结论可以得知：当内存`byte`为第二位时绝对不可能是一个对象的开始，只有当内存位置为8的整数倍才有可能是对象的开始位置，所以可以按`8byte`为一个位置来寻址，4GB的位置可以被当作`4*8=32GB`，最终可以寻址32GB



#### 7.1.5 对象实际大小

浅堆（Shallow Heap）：**对象本身占用的内存，不包括内部引用对象的大小**，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐

JDK7 中的 String：2个 int 值共占 8 字节，value 对象引用占用 4 字节，对象头 8 字节，对齐后占 24 字节，为 String 对象的浅堆大小，与 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节

```java
private final char value[];
private int hash;
private int hash32;
```

保留集（Retained Set）：对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括 A 本身），所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合

深堆（Retained Heap）：指对象的保留集中所有的对象的浅堆大小之和，一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间

对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小

下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，**A 的实际大小为 A、C、D 三者之和**，A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内

<img src="https://foruda.gitee.com/images/1685093175560712843/423e4650_8616658.png" style="zoom: 67%;" />

内存分析工具 MAT 提供了一种叫支配树的对象图，体现了对象实例间的支配关系

基本性质：

- 对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆
- 如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B
- 支配树的边与对象引用图的边不直接对应

左图表示对象引用图，右图表示左图所对应的支配树：

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-支配树.png)

比如：对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此对象 D 是对象 F 的直接支配者



参考文章：https://www.yuque.com/u21195183/jvm/nkq31c

#### 7.1.6 节约内存

- 尽量使用基本数据类型

- 满足容量前提下，尽量用小字段

- 尽量用数组，少用集合，数组中是可以使用基本类型的，但是集合中只能放包装类型，如果需要使用集合，推荐比较节约内存的集合工具：fastutil

  一个 ArrayList 集合，如果里面放了 10 个数字，占用多少内存：

  ```java
  private transient Object[] elementData;
  private int size;
  ```

  Mark Word 占 4byte，Klass Word 占 4byte，一个 int 字段占 4byte，elementData 数组占 12byte，数组中 10 个 Integer 对象占 10×16，所以整个集合空间大小为 184byte（深堆）

- 时间用 long/int 表示，不用 Date 或者 String



### 7.2 对象创建方法

类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类。

Java 对象创建方法：

1. 使用 **new 关键字创建对象**：由执行类实例创建表达式而引起的对象创建；

2. 使用 **Class 类的 newInstance** 方法（反射机制）；

3. 使用 **Constructor 类的 newInstance** 方法（反射机制）；

   使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法。

4. 使用 **Clone 方法**创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法；

5. 使用**（反）序列化机制**创建对象：当反序列化一个对象时，JVM 会创建一个**单独的对象**，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口。

从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的。但无论通过哪种方式进行创建对象，虚拟机都会将创建的过程分为三步：类加载检测、内存分配以及对象头设置。

### 7.3 对象创建过程

#### 7.3.1 类加载检测

当虚拟机遇到一条创建指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，同时并检查这个符号引用代表的类是否被加载解析初始化过。如果没有，在双亲委派模式下，使用当前类加载器以当前创建对象的全限定名作为`key`值进行查找对应的`.class`文件，如果没有找到文件，则抛出ClassNotFoundException异常，找到了则先完成[类加载过程](https://juejin.cn/post/7057538607828959263)，完成了类加载过程后，再开始为其对象分配内存。

#### 7.3.2 内存分配

当一个对象的类已经被加载后，会依据第一阶段分析的方式去计算出该对象所需的内存空间大小，计算出大小后会开始对象分配过程，而内存分配就是指在内存中划出一块与对象大小相等的区域出来，然后将对象放进去的过程。但需要额外注意的是：Java的对象并不是直接一开始就尝试在堆上进行分配的，分配过程如下：

![输入图片说明](https://foruda.gitee.com/images/1693880492277621934/ce56bff4_8616658.png "对象分配过程")

##### 7.3.2.1 栈上分配

栈上分配是属于C2编译器的激进优化，建立在逃逸分析的基础上，使用标量替换拆解聚合量，以基本量代替对象，然后最终做到将对象拆散分配在虚拟机栈的局部变量表中，从而减少对象实例的产生，减少堆内存的使用以及GC次数。

> 逃逸分析：逃逸分析是建立在方法为单位之上的，如果一个成员在方法体中产生，但是直至方法结束也没有走出方法体的作用域，那么该成员就可以被理解为未逃逸。反之，如果一个成员在方法最后被return出去了或在方法体的逻辑中被赋值给了外部成员，那么则代表着该成员逃逸了。
>
> 标量替换：建立在逃逸分析的基础上使用基本量标量代替对象这种聚合量，标量泛指不可再拆解的数据，**八大基本数据类型就是典型的标量**。

如果对象被分配在栈上，那么该对象就无需GC机制回收它，该对象会随着方法栈帧的销毁随之自动回收。但如果一个对象大小超过了栈可用空间（栈总大小-已使用空间），那么此时就不会尝试将对象进行栈上分配。

> 栈上分配因为是建立在逃逸分析之上的，所以能够被栈上分配的对象绝对是只在栈帧内有用的，也就代表栈上分配的对象不会有GC年龄，随着栈帧的入栈出栈动作而创建销毁。



##### 7.3.2.1 TLAB分配

TLAB全称叫做`Thread Local Allocation Buffer`，是指JVM在`Eden`区为每条线程划分的一块私有缓冲内存。大部分的Java对象是会被分配在堆上的，但也说到过堆是线程共享的，那么此时就会出现一个问题：当JVM运行时，如果出现两条线程选择了同一块内存区域分配对象时，不可避免的肯定会发生竞争，这样就导致了分配速度下降。

而在JVM中也存在类似的烦恼，在为对象分配内存时，往往会出现多条线程竞争同一块内存区域的“惨案”，虚拟机为了根治这个问题为每条线程专门分配一块内存区域，这块区域就被称为**TLAB区**，当一条线程尝试为一个对象分配内存时，如果开启了TLAB分配的情况下，那么会先尝试在TLAB区域进行分配。（程序启动时可以通过参数`-XX:UseTLAB`设置是否开启TLAB分配）。

而值得一提的是：TLAB并不是独立在堆空间之外的区域，而是JVM直接在`Eden`区为每条线程划分出来的。默认情况下，TLAB区域的大小只占整个`Eden`区的`1%`，不过也可以通过参数：`-XX:TLABWasteTargetPercent`设置TLAB区所占用`Eden`区的空间占比。

一般情况下，JVM会将TLAB作为内存分配的首选项（C2激进优化下的栈上分配除外），只有当TLAB区分配失败时才会开始尝试在堆上分配。

**TLAB分配过程**

当创建一个对象时，开启了激进优化的情况时，首先会尝试栈上分配，如果栈上分配失败，会进行TLAB分配，首先会比较对象所需空间大小和TLAB剩余可用空间大小，如果TLAB可以放下去，那么就直接将对象分配在TLAB区。如果TLAB区的可用空间分配不下该对象，则会先判断剩余空间是否大于规定的**最大空间浪费大小**，如果大于则直接在堆上进行分配，如果不大于则先使用空对象填充*内存间隙*，然后将当前TLAB退回堆空间，重新根据**期望值**申请一个新的TLAB区，再次进行分配。如下：
![输入图片说明](https://foruda.gitee.com/images/1693880977430658165/75de3111_8616658.png "TLAB分配过程")

> 在上面的TLAB分配过程分析中，提到了几个名词：最大空间浪费大小、内存间隙以及期望值，释义如下：
> 最大空间浪费：其意如名，是指JVM允许一个TLAB区最多剩余多少内存不使用，一般来说这个值是动态的。
> 内存间隙：当前 TLAB不够分配时，如果剩余空间小于最大空间浪费限制，那么这个 TLAB区会被退回Eden区，然后重新申请一个新的TLAB，而这个TLAB被退回到Eden区之后，该TLAB的剩余空间就会成为孔隙。如果不管这些孔隙，由于TLAB仅线程内知道哪些被分配了，在GC扫描发生时，又需要做额外的检查，那么会影响GC扫描效率。所以TLAB回归Eden的时候，会将剩余可用的空间用一个`dummy object`(空对象) 填充满。如果填充已经确认会被回收的对象，也就是`dummy object`，GC会直接标记之后跳过这块内存，增加GC扫描效率。
> 期望值：期望值这个概念在JVM中是惯用的思想，无论是JIT还是GC等，都以期望值作为激进优化的基础，这个期望是根据JVM运行期间的“历史数据”计算得出的，也就是每次输入采样值，根据历史采样值得出最新的期望值。



**TLAB中常用的期望值算法EMA - 指数移动平均数算法**

EMA（`Exponential Moving Average`）算法的核心在于设置合适的最小权重，最小权重越大，变化得越快，受历史数据影响越小。根据应用设置合适的最小权重，可以让你的期望更加理想。具体可以参考：[百度百科](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FEMA%2F12646151%3Ffr%3Daladdin)。

> 注意：当TLAB退回给堆空间时，那原本里面存储的对象需要挪动到新的TLAB区域吗？

答案是不需要的，因为TLAB区本身使用的就是Eden区的内存划出来的，所以直接将间隙内存填充好空对象之后退回给堆空间即可，原本的对象不需要挪动到新分配的TLAB区中，照样是可以通过原本的引用指针访问之前位置中的对象的，唯一需要改变的就是将线程的TLAB区指向改成新申请的内存区域。



##### 7.3.2.3 年老代分配

如果在TLAB区尝试分配失败后，对象会进行判定：是否满足年老代分配标准，如果满足了则直接在年老代空间中分配。可能有些小伙伴会疑惑：对象不是先尝试在新生代进行分配之后，再进入年老代分配吗？其实这是错误的概念，对象在初次分配时会先进行判定一次是否符合年老代分配标准，如果符合则直接进入年老代。



**年老代分配条件**

初次分配时，大对象直接进入年老代。
一般对象进入年老代的情况只有三种：**大对象、长期存活对象以及动态年龄判断符合条件的对象**，在JVM启动的时候你可以通过`-XX:PretenureSizeThreshold`参数指定大对象的阈值，如果对象在分配时超出这个大小，会直接进入年老代。

> 这样做的好处在于：可以避免一个大对象在两个`survivor`区域来回反复横跳。因为每次新生代GC时，都会将存活的对象从一个`survivor`区移动到另外一个`survivor`区，而一般来说，大对象绝对不属于朝生夕死的对象，所以就代表着：大对象被分配之后很大几率都会在两个`survivor`区来回移动，大对象的移动对于JVM来说是比较沉重的负担，内存分配、数据拷贝等都需要时间以及资源开销。同时因为大对象的迁移会存在耗时，所以也会导致GC时间变长。

所以对于大对象而言，直接进入年老代会比较合适，这也属于JVM的细节方面优化。

> 上述的这段是基于分代GC器而言的，实则不同的GC器对于大对象的判定标准也不一样，尤其是到了后面的不分代GC器，大对象则不会进入年老代，而是会有专门存储大对象的区域，如`G1、ShenandoahGC`中的`Humongous`区、`ZGC`中的`Large`区等。



##### 7.3.2.4 新生代分配

如果栈上分配、TLAB分配、年老代分配都未成功，此时就会来到Eden区尝试新生代分配。而在新生代分配时，会存在两种分配方式：

1. 指针碰撞：指针碰撞是Java在为对象分配堆内存时的一种内存分配方式，一般适用于Serial、ParNew等不会产生内存碎片、堆内存完整的的垃圾收集器。

   分配过程：堆中已用分配内存和为分配的空闲内存分别会处于不同的一侧，通过一个指针指向分界点区分，当JVM要为一个新的对象分配内存时，只需把指针往空闲的一端移动与对象大小相等的距离即可。

2. 空闲列表：与指针碰撞一样，空闲列表同样是Java在为新对象分配堆内存时的一种内存分配方式，一般适用于CMS等一些会产生内存碎片、堆内存不完整的垃圾收集器。

   分配过程：堆中的已用内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的空闲内存块信息，当创建新对象需要分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并同步更新列表上的记录，当GC收集器发生GC时，也会将已回收的内存更新到内存列表。

上述的两种内存分配方式，指针碰撞的方式更适用于内存整齐的堆空间，而空闲列表则更适合内存不完整的堆空间，一般来说，JVM会根据当前程序采用的GC器来决定究竟采用何种分配方式。

> 在Eden区分配内存时，因为是共享区域，必然会存在多条线程同时操作的可能，所以为了避免出现线程安全问题，在Eden区分配内存时需要进行同步处理，在HotSpot VM中采用的是线程CAS+失败换位重试的方式保证原子性。



##### 7.3.2.5 内存分配小结

至此，关于Java对象的内存分配阶段已阐述完毕，简单来说，如果当前JVM处于热机状态，C2编译器已经介入的情况下，首先会尝试将对象在栈上分配，如果栈上分配失败则会尝试TLAB分配，TLAB分配失败则会判定对象是否满足年老代分配标准，如果满足则直接将对象分配在年老代，反之则尝试将对象在新生代Eden区进行分配。

> JVM如果处于冷机状态，C2编译器还未工作的情况下，则TLAB分配作为对象分配的首选项。

#### 7.3.3 初始化内存

经过内存分配的步骤之后，当前创建的Java对象会在内存中被分配到一块区域，接着则会初始化分配到的这块空间，JVM会将分配到的内存空间（不包括对象头）都初始化为零值，这样做的好处在于：可以保证对象的实例字段在Java代码中不赋初始值就直接使用，程序可以访问到字段对应数据类型所对应的零值，避免不赋值直接访问导致的空指针异常。

> 如果对象是被分配在栈上，那所有数据都会被分配在栈帧中的局部变量表中。
> 如果对象是TLAB分配，那么初始化内存这步操作会被提前到内存分配的阶段进行。
>
> 当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从**隐藏变量**也会被分配空间（继承部分解释了为什么会隐藏）



#### 7.3.4 设置对象头

当初始化零值完成后，紧接着会对于对象的对象头进行设置。首先会将对象的原始哈希码、GC年龄、锁标志、锁信息组装成`MrakWord`放入对象头中，然后会将指向当前对象类元数据的类型指针`KlassWord`也加入对象头中，如果当前对象是数组对象，那么还会将编码时指定的数组长度`ArrayLength`放入对象中，最终当对象头中的所有数据全部组装完成后，会将该对象头放在对象分配的内存区域中存储。



#### 7.3.5 执行`<init>`函数

当上述步骤全部完成后，最后会执行`<init>`函数，也就是构造函数，主要是对属性进行显式赋值。从Java层面来说，这也是真正的按照开发者的意愿对一个对象进行初始化赋值，经过这个步骤之后才能够在真正意义上构建出一个可用对象。

执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化

- 实例变量初始化与实例代码块初始化：

  对实例变量直接赋值或者使用实例代码块赋值，**编译器会将其中的代码放到类的构造函数中去**，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前

- 构造函数初始化：

  **Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性**，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数



### 7.4 对象访问

在Java中对象都是通过`reference`访问的，`reference`主要分为两种访问方式，一种为句柄访问，另一种则为直接指针访问。JVM 是通过**栈帧中的对象引用**访问到其内部的对象实例。

#### 7.4.1 句柄访问

Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息

优点：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改

![输入图片说明](https://foruda.gitee.com/images/1693882100482310865/5b7d9e26_8616658.png "JVM-对象访问-句柄访问")



#### 7.4.2 直接访问

直接指针（HotSpot 采用）：Java 堆对象的布局必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的对象地址

优点：速度更快，**节省了一次指针定位的时间开销**

缺点：对象被移动时（如进行 GC 后的内存重新排列），对象的 reference 也需要同步更新

![输入图片说明](https://foruda.gitee.com/images/1693882210161868317/638f706b_8616658.png "JVM-对象访问-直接指针")

参考文章：https://www.cnblogs.com/afraidToForget/p/12584866.html



### 7.5 对象移动与晋升

在HotSpot中是通过直接指针方式访问对象的，而运行过程中，`reference`位于线程栈中，对象的实例数据则存储在堆中。当一条线程执行完成一个方法后，与该方法对应的栈帧会被销毁，而栈帧中的局部变量表也会随之销毁，此时局部变量表中的`reference`也会被回收。而此时堆中的对象就变成了没有指针引用的“垃圾”对象，如果在下一次GC发生前还是没有新的指针引用它，那么该对象则会被回收。

而那些在GC发生时，依旧还存在着引用的对象，那么则会将其从`Eden`区移入到`Survivor`区中，而移动之后，与之对应的`reference`中的指针也必须要改为最新的内存地址。

> 新生代中一共存在两个`Survivor`区：`S0/S1`，也被称为或`From/To`区，这两个区域在同一时刻，永远有一个是空的，当下次GC发生时，作为存活对象新的“避难所”。但`From/To`两个名词并不是一个区域固定的称呼，而是动态的，存放对象的`Survivor`区被称为`From`区，而空的`Survivor`区被称为`To`区。

当对象移动一次，那么对象头内`MrakWord`中的对象年龄则会`+1`（刚创建的对象年龄为0）。而大部分的分代GC器中，对于老年代的晋升标准默认为`15`岁（`CMS`为8岁），也就是当对象来回移动`16`次之后，这些依旧存活的对象会被转入年老代存储，可以通过参数`-XX:MaxTenuringThreshold`更改年龄阈值。

#### 7.5.1 动态对象年龄判定

一般情况下，正常对象是需要达到指定的年龄阈值才能进入年老代的，但为了能更好的适应不同程序的内存状况，JVM并不总是要求对象的年龄必须达到阈值才能晋升到年老代，如果在`Survivor`区中相同年龄的所有对象大小总和大于`Survivor`空间的一半，那么`Survivor`区中所有大于或等于该年龄的对象就可以直接进入年老代，无需等到满足阈值的标准后再晋升，这种晋升方式也被称为JVM的动态对象年龄判定。

#### 3.2.2、空间分配担保机制

分配担保是指年老代为新生代提供担保，可以通过`HandlePromotionFailure`参数关闭或开启（JDK1.6之后默认开启）。**当发生GC时，一个S区空间无法储存`Eden`区和另外一个S区的存活对象时，这些对象会被直接转移到年老代**，这个过程就是空间分配担保。

在进行`MinorGC`前，如果老年代的连续空间大于**新生代对象大小总和或历次晋升的平均大小**，则此次`MinorGC`是安全的，则进行`MinorGC`，否则进行`FullGC`。

> 分配担保的作用：假如大量对象在新生代发生GC后依旧存活（最极端情况为GC后新生代中所有对象全部存活），而`Survivor`空间是比较小的，这时就需要老年代进行分配担保，把`Survivor`无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行`FullGC`来让老年代腾出更多空间。



### 7.6  对象引用

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关，Java 提供了四种强度不同的引用类型

#### 7.6.1 强引用

被强引用关联的对象**不会被回收**，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收

- 强引用可以直接访问目标对象
- 虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象
- 强引用可能导致**内存泄漏**

```java
Object obj = new Object();//使用 new 一个新对象的方式来创建强引用
```

通过`new`指令创建的`Object`实例会被分配在堆中存储，而变量`obj`会被放在当前方法对应的栈帧内的局部变量表中存储，在运行时可以直接通过`obj`变量操作堆中的实例对象，那么`obj`就是该`Object`实例对象的强引用。



#### 7.6.2 软引用

被软引用（SoftReference）关联的对象只有在**内存不够**的情况下才会被回收，**仅（可能有强引用，一个对象可以被多个引用）**有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象

- 配合**引用队列来释放软引用自身**，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况
- 软引用通常用来实现**内存敏感的缓存**，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```



#### 7.6.3 弱引用

被弱引用（WeakReference）关联的对象**一定会被回收**，只能存活到**下一次垃圾回收**发生之前，不过因为GC线程的优先级比用户线程更低，所以一般不会立马发现弱引用类型对象，因此一般弱引用类型的对象也会有一段不短的存活周期。

- 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
- 配合引用队列来释放弱引用自身
- WeakHashMap 用来**存储图片信息**，可以在内存不足的时候及时回收，避免了 OOM

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```



#### 7.6.4 虚引用

虚引用（PhantomReference）也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个，不过在使用虚引用的时候是需要配合`ReferenceQueue`引用队列才能联合使用

- 一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象
- 为对象设置虚引用的唯一目的是在于**跟踪垃圾回收**过程，能在这个对象被**回收时**收到一个**系统通知**
- 必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

当GC机制准备回收一个对象时发现它还存在虚引用，那么GC机制就会在回收前，把虚引用加入到与之关联的引用队列中，程序可以通过判断队列中是否加入该虚引用，来判断被引用的对象是否将要GC回收，从而可以在finalize方法中采取一些对应的处理措施。

#### 7.6.5 终结器引用（finalization）

- 用以实现对象的finalize()方法，也可以称为终结器引用。
- 无需手动编码，其内部配合引用队列使用。
- 在GC时，总结其引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。




## 8 GC

### 8.1 对象存活判断

#### 8.1.1 引用计数法

引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）

优点：

- 回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收
- 在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误
- 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象

缺点：

- 每次对象被引用时，都需要去更新计数器，有一点时间开销

- 浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。

- **无法解决循环引用问题，会引发内存泄露**（最大的缺点）

  ​

  ```java
  public class Test {
      public Object instance = null;
      public static void main(String[] args) {
          Test a = new Test();// a = 1
          Test b = new Test();// b = 1
          a.instance = b;		// b = 2
          b.instance = a;		// a = 2
          a = null;			// a = 1
          b = null;			// b = 1
      }
  }
  ```

<img src="https://foruda.gitee.com/images/1685092461072162975/8967c1a2_8616658.png" style="zoom:67%;" />





#### 8.1.2 可达性分析

##### 8.1.2.1 工作原理

可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象，分析工作必须在一个保障**一致性的快照**中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因。

基本原理：

- 可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链

- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象

- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象

  <img src="https://foruda.gitee.com/images/1685092514660702245/5a3674eb_8616658.png" style="zoom: 50%;" />



##### 8.1.2.2 可作为GC Roots的对象

GC Roots 对象：

1. 虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等
2. 本地方法栈中引用的对象
3. 堆中类静态属性引用的对象
4. 方法区中的常量引用的对象
5. 字符串常量池（string Table）里的引用
6. 同步锁 synchronized 持有的对象

**GC Roots 是一组活跃的引用，不是对象**，放在 GC Roots Set 集合







#### 

#### 8.1.3 对象的finalization机制

所有的GC机制前提都是：要能够识别出要内存中需被回收的垃圾对象。因此需要对所有对象给出一个可触及性的定义，而在Java中对象可触及性分为三类：

1. 可触及的：存在于引用链上的对象则是可触及对象，也就是指通过根节点是可以找到的对象。
2. 可复活的：一旦当一个对象的所有引用被释放，那么它就会处于可复活状态，因为**在`finalize()`中可能复活该对象**。
3. 不可触及的：在`finalize()`执行后，对象会进入不可触及状态，从此该对象没有机会再次复活，只能等待被GC机制回收。

对于可触及类型和不可触及类型的对象则不再分析，因为比较容易理解，重点来看看可复活类型的对象。在Java语言中提供了对象终止`finaliztion`机制，**允许开发人员自己编写对象被销毁/回收之前的自定义处理逻辑**。

垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等

生存 OR 死亡：如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用，此对象需要被回收。但事实上这时候它们暂时处于缓刑阶段。



当垃圾回收器发现一个对象没有引用指向时，那么在GC之前，总会先调用这个对象的`finalize()`方法。但如果该对象所属的类没有重写`finalize()`方法或已经执行过一次该方法了，最终则不会再执行`finalize()`方法。

如果一个对象没了引用，但是重写了`finalize()`方法并且未被执行过，那么该对象会被插入到`F-Queue`队列中，该队列是JVM自动创建的一个队列，由低优先级的`Finalizer`线程执行其`finalize()`方法。
`finalize()`方法是一个对象实例最后的复活机会，因为GC机制会二次对`F-Queue`队列中的对象进行标记。如果一个对象执行`finalize()`方法过程中，与引用链上的任何一个对象建立了联系，那么该对象会被移出队列，然后标记为存活对象。


> 但需要值的注意是：
>
> ①执行过一次`finalize()`方法的对象再也没有机会进入到`F-Queue`队列中，当执行过一次之后`finalize()`方法不会再次被调用，对象会直接变成不可触及的状态。
> ②`finalize()`方法的执行具备不确定性，JVM只会保证对象的`finalize()`方法会调用，但不保证`finalize()`方法100%能执行完毕。比如此时，`Finalizer`线程正在执行一个对象`finalize()`方法，但是其内部的逻辑执行比较耗时，而此时堆内存严重不足（已用内存达到`98%`以上）时，GC会强制回收掉该队列中的对象。也就相当于`finalize()`方法本来是对象的最后抢救机会，结果抢救过程中因为某些意外因素，对象直接嗝屁了。





永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用，原因：

- finalize() 时可能会导致对象复活
- finalize() 方法的执行时间是没有保障的，完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收
- 一个糟糕的 finalize() 会严重影响 GC 的性能



> 可达性算法不可达的对象就一定会死亡，会被回收吗？
>
> 不一定。
>
> 在可达性算法中不可达的对象也不一定是非死不可的，这时候它们暂时处于“缓刑”阶段，要真正宣告它的死亡还需要经历**两次的标记阶段**。
>
> 第一次标记：
> 在对象可达性算法不可达时，进行第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象**没有重写finalize()方法**或者**该方法被虚拟机调用过**，虚拟机将这两种情况视为“没有必要去执行”。
>
> 如果该对象被判定为**有必要执行finalize()方法**，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行它。这里所谓的执行就是去触发该方法，但是并不会承诺等待它执行结束，这样做的原因是，如果对象在finalize()方法中执行缓慢，或者发生死循环，将会导致整个队列中的对象处于等待之中。
>
> 第二次标记：
> finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己——**只要重新与引用链上的一个对象重新建立关联即可**，譬如将自己（this关键字）赋值给某个类变量或者成员变量，那么在第二次标记的时候就会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么就会被真的回收了！





### 8.2 垃圾回收算法

GC算法一般在堆可用内存不足的情况下会被触发，通常来说，它们首先会先停止应用程序（也被称为`STW：StopTheWorld`），也就是指将JVM中的所有用户线程暂停，这样可以保持堆内存在该时间段内不会发生新的变化，能够在最大程度上保证结果的准确性。而目前JVM中主要存在三种GC算法：标记-清除算法（标-清算法）、复制算法以及标记-整理算法（标-整算法）

#### 8.2.1 标记清除

标记清除算法，是将垃圾回收分为两个阶段，分别是**标记和清除** 。

- **标记**：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，**标记的是引用的对象，不是垃圾** ；
- **清除**：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到**空闲列表**的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块；
- **分配阶段**：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，如果找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表。


- ​

<img src="https://foruda.gitee.com/images/1685091453294330212/326ee1ea_8616658.png" style="zoom: 67%;" />



算法缺点：

- 标记和清除过程效率都不高；

  标记-清除算法是最初的GC算法，因为在标记阶段需要停下所有用户线程，也就是发生`STW`，而标记的时候又需要遍历整个堆空间中的所有`GcRoots`，所以耗时比较长，对于客户端而言，可能会导致GC发生时，造成很长一段时间内无响应。

- 会产生大量不连续的内存碎片，导致无法给大对象分配内存，需要维护一个空闲链表。

  堆空间中的垃圾对象是会分散在内存的各个角落，所以一次GC之后，会造成大量的内存碎片，也就是通过标-清算法清理出来的内存是不连续的，为了解决这个问题，JVM就不得不再额外维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象或大对象时，连续的内存空间资源又会变得很匮乏。


------



#### 8.2.2 标记整理

标记整理（压缩）算法是在标记清除算法的基础之上，做了优化改进的算法。

算法过程：

1. **标记阶段：**标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记
2. **清理阶段：**在清理阶段，并不是简单的直接清理可回收对象，而是**将存活对象都向内存另一端移动**，然后清理边界以外的垃圾，从而**解决了碎片化**的问题

<img src="https://foruda.gitee.com/images/1685091557042577953/d5f98db5_8616658.png" style="zoom:67%;" />

优点：不会产生内存碎片

缺点：需要移动大量对象，处理效率比较低

因为标-整算法不仅仅要标记对象，同时还要移动存活对象，所以整个GC过程下来，它所需要耗费的时间资源开销必然是不小的

不过一般年老代空间都是采用标-整算法，因为一方面年老代GC次数方面远没有新生代频繁，同时，晋升年老代的对象一般来说体积不会很小，所以在晋升时需要足够的内存大小分配，如果采用标-清算法会导致大对象无法进行分配，如若采用复制算法则没有新的空间为年老代提供分配担保，所以标-整算法是三者中最适用于年老代`GC`的。



------

#### 8.2.3 复制算法

复制算法的核心就是，**将原有的内存空间一分为二，每次只用其中的一块**，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清理，交换两个内存的角色，完成垃圾的回收。

算法过程：利用根可达分析算法，判断该对象是否是可用对象（非垃圾对象），如果可用则移动到空闲survivor区间，当所有对象遍历完成后，清空当前区间，并标记为下一次垃圾回收的空闲survivor区间。

应用场景：如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之则不适合。

<img src="https://foruda.gitee.com/images/1685091348823991150/fe392e27_8616658.png" style="zoom: 67%;" />

算法优点：

- 没有标记和清除过程，实现简单，运行速度快；
- 复制过去以后保证空间的连续性，不会出现碎片问题；

算法缺点：

- 主要不足是**只使用了内存的一半；**
- 对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小。

现在的商业虚拟机都采用这种收集算法**回收新生代**，因为新生代 GC 频繁并且对象的存活率不高，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间。

#### 8.2.4 垃圾收集算法总结

如上三种GC算法则是JVM虚拟机的基础GC算法，综合对比来看：

- 收集速度：复制算法 > 标-清算法 > 标-整算法
- 内存整齐度：复制算法 = 标-整算法 > 标-清算法
- 内存利用率：标-整算法 > 标-清算法 > 复制算法

在GC算法中，速度快的需要用空间来换，空间利用率高且整齐度高的，则需要牺牲时间来换取，所以相对而言，在绝大部分算法中，**时间与空间不可兼得**。

在上述三种算法中，复制算法和标-整算法都是基于标-清算法进行优化的，所以在现代的高性能JVM中绝大多数虚拟机都采用复制或标-整算法进行垃圾收集工作。



### 8.3 分代收集策略

现代商用虚拟机中的GC机制一般都会采用“分代收集策略”，如JDK1.8及之前的`HotSpotVM`中，都会采用分代收集策略，也就是根据对象不同的生命周期将堆空间划分为不同的区域，然后在不同区域中采用不同的垃圾收集算法进行回收工作。

- 新生代：一般使用复制算法，因为在新生代中的对象几乎绝大部分都是朝生夕死的，**每次GC发生后只会有少量对象存活**，这种情况下采用复制算法无疑是个不错的选择，付出一定的内存空间开销以及少量存活对象的移动开销，换取内存的整齐度以及可观收集效率，这很明显是个“划得来的买卖”。
- 年老代：一般采用标记-整理算法或标记-清除算法，但绝大多数年老代GC器都会选择采用标-整算法，因为毕竟标-清算法会导致大量的内存碎片产生，在年老代对象分配时，内存不完整可能会导致大对象分配不下而持续触发GC。而标-整算法虽然效率较低，但胜在GC后内存足够整齐，再加上年老代的GC并没有新生代频繁，所以年老代空间采用标-整算法无疑也是个不错的选择。

> 注：为什么年老代不考虑复制算法呢？
> 一方面是因为年老代空间中的对象普遍存活率都比较高，第二方面是没有新的空间为年老代做分配担保，所以复制算法是明显并不适合年老代的



### 8.4 分区收集策略

在JDK1.8及之前的JVM中，堆中间一般会按照对象的生命周期长短划分为新生代、年老代两个空间，分别用于存储不同周期的对象。而在新版本的GC器，如`G1、ZGC`中，则摒弃了之前物理内存上分代的思想，在运行时并不会直接将堆空间切分为两块区域，而是将整个堆划分为连续且不同的小区间，每一个小区间都独立使用，独立回收，这种回收策略带来的好处是：可以控制一次回收多少个小区间。



### 8.5 GC类型

JVM在发生GC时，主要作用的区域有三个：新生代、年老代以及元数据空间，当然，程序运行期间，绝对多数GC都是在回收新生代。一般而言，GC可以分为四种类型，如下：

1. 新生代收集：只针对新生代的GC，当`Eden`区满了时触发，`Survivor`满了并不会触发。
2. 年老代收集：针对年老代空间的GC，不过目前只有`CMS`存在单独回收年老代的行为。
3. 混合收集：指收集范围覆盖整个新生代空间及部分年老代空间的GC，目前只有`G1`存在该行为。
4. 全面收集：覆盖新生代、年老代以及元数据空间的GC，会对于所有可发生GC的内存进行收集。

#### 8.5.1 新生代收集（MinorGC/YoungGC）

发生在新生代的GC也被称为`MinorGC`或`YoungGC`，在JVM中，发生次数最多的也就是新生代GC，毕竟新生代中的对象都是朝生夕死的，也是分配最为频繁的，所以新生代GC也是触发最频繁的。不过**新生代GC只有`Eden`区满了才会触发**，而`Survivor`区满了后是不会触发的。对于大部分Java程序而言，新生代GC造成的STW停顿几乎可以忽略不计，因为新生代GC只需要标记出垃圾对象即可，对于存活对象移动的工作量是比较小的。

#### 8.5.2 年老代收集（Major GC/Old GC）

当老年代满时会触发`MajorGC`，当然在有些地方也被称为`OldGC`，但一般而言，年老代GC触发时往往都会伴随新生代GC一起发生，只有CMS收集器会有单独收集年老代空间的行为，其他收集器均无此行为。

#### 8.5.3 混合收集（MixedGC）

混合收集`MixedGC`是指收集范围覆盖整个新生代空间及部分年老代空间的GC，但目前只有`G1`存在该行为，其他收集器均不支持，因为`G1`收集器是逻辑分代，物理分区的结构，所以可以针对于不同的分区进行单独的收集，在发生GC时，可以选取新生代分区+部分年老代分区进行回收。

#### 8.5.4 全面收集（FullGC）

全面收集也被称为`FullGC`，是所有GC类型中，耗时最长、停顿最久的GC，FullGC会对于所有可发生GC的区域进行全面回收，其中涵盖新生代、年老代以及元数据空间，而一般触发FullGC的原因有如下几种：

1. 调用`System.gc()`时，JVM在内存占用较多时会尝试发生`FullGC`，但并非100%触发。
2. 除`CMS`之外收集器，当年老代不足时也会触发`FullGC`。
3. 元数据空间内存不足时，也会触发`FullGC`。
4. 对象晋升时年老代空间无法承载晋升对象时也会触发`FullGC`。
5. 新生代空间分配担保机制触发时，也会先触发`FullGC`。



### 8.6 安全点与安全区

#### 8.6 .1 安全点(SafePoint)

无论是在GC中还是并发编程中，都会经常出现安全点这个概念，因为当我们需要阻塞停止一条线程时，都需要在安全点停止，简单说安全点就是指当线程运行到这类位置时，堆对象状态是确定一致的，线程停止后，JVM可以安全地进行操作，如GC、偏向锁撒销等。

而JVM中对于安全点的定义主要有如下几种：

1. 循环结束的末尾段
2. 方法调用之后
3. 抛出异常的位置
4. 方法返回之前

当JVM需要发生GC、偏向锁撤销等操作时，如何才能让所有线程到达安全点阻塞或停止？

1. 主动式中断(JVM采用的方式)：不中断线程，而是设置一个标志，而后让每条线程执行时主动轮询这个标志，当一个线程到达安全点后，发现中断标志为`true`时就自己中断挂起。
2. 抢断式中断：先中断所有线程，如果发现线程未执行到安全点则恢复线程让其运行到安全点位置。

#### 8.6.2 安全区域(SafeRegion)

当Java程序需要停下所有用户线程时，某些线程可能处于中断或者休眠状态，从而无法响应JVM的中断请求走到安全点位置挂起了，所以出现了安全区域的概念。

> 安全区域是指一条线程执行到一段代码时，该区域的代码不会改变堆中对象的引用。在这区域内JVM可以安全地进行操作。当线程进入到该区域时需要先标识自己进入了，这样GC线程则不会管这些已标识的线程，当线程要离开这个区域时需要先判断可达性分析是否完成，如果完成了则往下执行，如果没有则需要原地等待到GC线程发出安全离开信息为止。





## 9 GC分代收集器

JVM中的分代GC收集器，除开被划分为新生代和年老代外，也会根据其收集过程，分为单线程和多线程属性的收集器。其中`Serial、Serial Old（MSC）`属于单线程的收集器，而`ParNew、Parallel Scavenge、CMS、Parallel Old`则属于并发型的多线程收集器。

分代GC按照不同的区域划分：

- 新生代收集器：`Serial、ParNew、Parallel Scavenge`
- 年老代收集器：`CMS、Serial Old（MSC）、Parallel Old`

### 9.1  新生代收集器

#### 9.1.1 Serial

`Serial`是最原始的新生代收集器，同时它属于**单线程**的GC收集器，是**串行**垃圾收集器。在执行GC工作时，是以单线程运行的，并且该收集器在发生GC时，会产生**STW**，也就是会停止所有用户线程。但正由于会停止其他用户线程，所以在执行GC时并不会出现线程间的切换。因此，在单颗`CPU`的机器上，它的清理效率非常高。一般来说，采用`Client`模式运行的JVM，选取该款收集器作为内嵌GC是个不错的选择。

由于作用于**新生代**，对象大多数是朝生夕死，因此采用**复制算法**

**STW（Stop-The-World）**：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成





开启参数：`-XX:+UseSerialGC` 等价于新生代用 Serial GC 且老年代用 Serial old GC。

![](https://foruda.gitee.com/images/1685093051188379874/eef19911_8616658.png)

优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率；

缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用；



------



#### 9.1.2 ParNew

Par 是 Parallel 并行的缩写，New 是只能处理的是新生代 ；

`ParNew`收集器是基于`Serial`收集器的演进版，从严格意义上来看，它可以被称为`Serial`收集器的多线程版本，同样是作用于新生代区域的收集器。在整个实现上，**除开GC收集阶段会使用多条线程回收外**，其他实现几乎与`Serial`收集器大致相同。

对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有**ParNew GC 能与 CMS 收集器配合工作**

相关参数：

- `-XX：+UseParNewGC`：表示年轻代使用并行收集器，不影响老年代
- `-XX:ParallelGCThreads`：默认开启和 CPU 数量相同的线程数

![输入图片说明](https://foruda.gitee.com/images/1680681044575608088/156cb1b1_8616658.png "屏幕截图")

ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器

- 对于新生代，回收次数频繁，使用并行方式高效
- 对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）

------



#### 9.1.3 Parallel Scavenge 

`Parallel Scavenge`同样是一款作用于新生代的多线程GC收集器，但与`ParNew`收集器不同的是：`ParNew`通过控制GC线程数量来缩短程序暂停时间，更关心程序的**响应时间**，而`Parallel Scavenge`更关心的是**程序运行的吞吐量**，也就是更注重一段时间内，用户代码执行时长与程序执行总时长的占比。



Parallel Scavenge 收集器是应用于新生代的并行垃圾回收器，**采用复制算法**、并行回收和 Stop the World 机制，以**吞吐量优先** ；

Parallel Old 收集器：是一个应用于老年代的并行垃圾回收器，**采用标记-整理算法** ；

对比其他回收器：

- 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间
- Parallel 目标是达到一个可控制的吞吐量，被称为**吞吐量优先**收集器
- Parallel Scavenge 对比 ParNew 拥有**自适应调节策略**，可以通过一个开关参数打开 GC Ergonomics

应用场景：

- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验
- 高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互

停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降

在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，**Java8 默认是此垃圾收集器组合**

![输入图片说明](https://foruda.gitee.com/images/1680681073073012016/08c8b5e2_8616658.png "屏幕截图")

参数配置：

- `-XX：+UseParallelGC`：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务
- `-XX：+UseParalleloldcc`：手动指定老年代使用并行回收收集器执行内存回收任务
  - 上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的
- `-XX:+UseAdaptivesizepplicy`：设置 Parallel Scavenge 收集器具有**自适应调节策略**，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量
- `-XX:ParallelGcrhreads`：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
  - 在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量
  - 当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]
- `-XX:MaxGCPauseMillis`：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
  - 对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量
  - 为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数
- `-XX:GCTimeRatio`：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小
  - 取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1
  - 与 `-xx:MaxGCPauseMillis` 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例


------

### 9.2 老年代收集器

#### 9.2.1 Serial Old（MSC）

`Serial Old（MSC）`与`Serial`收集器相同，同样是一款单线程串行回收的收集器，但不同的是：`MSC`是一款作用于年老代空间的收集器，它采用**标记-整理**算法对年老代空间进行回收。同时，该款收集器也可作为`CMS`的备用收集器使用。

`Serial Old（MSC）`与新生代收集器`Serial`差距不大，回收过程也是采用单线程做串行收集，属于`Serial`的年老代版本。

- Serial old 是 Client 模式下默认的老年代的垃圾回收器
- Serial old 在 Server 模式下主要有两个用途：
  - 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用
  - 作为老年代 CMS 收集器的**后备垃圾回收方案**，在并发收集发生 Concurrent Mode Failure 时使用



#### 9.2.2 Parallel Old收集器

`Parallel Old`则是`Parallel Scavenge`收集器的年老代版本，同样采用多线程进行并行收集，其内部采用标记-整理算法。与新生代的`PS`收集器相同的是：`PO`同样追求的是**吞吐量优先**。

`PO`作为`PS`收集器的年老代版本，其特性与`PS`大致相同，所以该款收集器同样适用于**注重吞吐量或对CPU资源敏感**的系统。

#### 9.2.3 CMS

CMS 全称 Concurrent Mark Sweep，是一款**并发的、使用标记-清除**算法、针对老年代的垃圾回收器，其最大特点是**让垃圾收集线程与用户线程同时工作**，也就是不停止用户线程。

CMS 收集器的关注点是**尽可能缩短垃圾收集时用户线程的停顿时间**，停顿时间越短（**低延迟**）越适合与用户交互的程序，良好的响应速度能提升用户体验

分为以下四个流程：

1. 初始标记：使用 `STW` 出现短暂停顿，**仅标记一下 GC Roots 能直接关联到的对象**，速度很快
2. 并发标记：进行 GC Roots 开始遍历整个对象图，**找出所有的存活对象**，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行
3. 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）
4. 并发清除：在该阶段主要是对存活对象之外的垃圾对象进行清除，该阶段不需要停止用户线程，是并发执行的。

在整个收集过程中，除开初始标记与重新标记阶段，其他的收集动作都是与用户线程并发执行的。因此，CMS收集器在发生GC时，造成的程序暂停是非常短暂的，对于用户体验感而言，相对比之前的收集器而言是**最优者**。也正由于CMS收集器**并发收集、停顿延迟低**的特性，所以在有些地方也被称为**并发低停顿收集器**。



Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的**对象的地址改变**，影响用户线程继续执行

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿

![输入图片说明](https://foruda.gitee.com/images/1680681429767765658/1cec55ff_8616658.png "屏幕截图")

优点：并发收集、低延迟

缺点：

- 吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高

- CMS 收集器**无法处理浮动垃圾**，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生

  浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间

- 标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配

参数设置：

- `-XX：+UseConcMarkSweepGC`：手动指定使用 CMS 收集器执行内存回收任务

  开启该参数后会自动将 `-XX:+UseParNewGC` 打开，即：ParNew + CMS + Serial old的组合

- `-XX:CMSInitiatingoccupanyFraction`：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收

  - JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收
  - JDK6 及以上版本默认值为 92%

- `-XX:+UseCMSCompactAtFullCollection`：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长

- `-XX:CMSFullGCsBeforecompaction`：**设置在执行多少次 Full GC 后对内存空间进行压缩整理**

- `-XX:ParallelCMSThreads`：设置 CMS 的线程数量

  - CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数
  - 收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕

------

### 9.3 收集器组合方案

并不存在所谓的最好组合，你要选择那套组合作为Java程序的收集器，更多的需根据具体的业务场景来决定。

1. 程序**追求低延迟**，**用户交互度较为频繁**，那你可以采用`ParNew + CMS`组合（这也是淘宝早期的选择，但后面采用了自研JVM）。
2. 程序**追求高吞吐**，**后台计算工作较多**，那么`Parallel Scavenge + Parallel Old`这组`PS+PO`的收集器会更适合你。
3. **更多的情况下部署在单核或双核的机器时**，那么最经典的`Serial + Serial Old`组合绝对是你的最佳选择。

#### 9.3.1 为何PS收集器不能和CMS收集器搭配使用？

因为在HotSpot中，底层存在一个分代GC的框架，`Serial/SerialOld/ParNew/CMS`都是基于该框架实现的，而在该框架内的新生代收集器和年老代收集器是可以相互之间搭配使用的，这也是所谓的`mix-and-match`规则。但PS收集器在实现时，发现原本的分代GC框架并不适用，则最终采用了自己的特殊框架进行了实现，所以`PS`收集器并不在前面所说的那个分代GC框架中。因此，`PS`不能跟使用了那个框架的`CMS`搭配使用。



### 9.4 三色标记算法

三色标记算法是自CMS收集器后，应用比较广泛的一种并发标记算法，它可以让JVM在发生GC时，只发生短暂的`STW`即可实现存活对象标记的一种算法。JVM中的`CMS`以及后续的不分代收集器，之所以可以做到低延迟的根本原因便在于此处。

> 三色标记思想：在该算法中，将对象分为了黑、白、灰三种颜色，释义如下：
>
> - 黑：已经被标记完成，且依旧存活的对象。
> - 灰：当前对象已经被标记完成，但关联节点（属性成员）还未标记的对象。
> - 白：未曾标记过的对象，或不具备引用的对象（垃圾对象）。



#### 9.4.1 三色标记过程

1. 实现了三色标记算法的GC收集器，在启动时会分别创建：黑、白、灰三个集合，在最开始所有的对象都在白色集合中。
2. 在GC发生时，发生短暂的`STW`，将所有与`GcRoots`直接相连的对象转入灰色集合中。
3. 之后并发执行，对灰色集合中的对象进行遍历，根据可达性分析算法进行对象存活标记，当一个对象的所有成员全部被标记完成后，该对象则会被移入到黑色集合中。同时，也会将该对象中被标记的成员从白色集合移入灰色集合中。不断重复，直至灰色集合彻底没了对象为止。
4. 标记完成所有对象后，再次触发`STW`，通过`write-barrier`写屏障检测对象是否有变化，如果发生了改变则重新标记，纠正并发标记期间的“误标”。
5. 并发执行清除工作，将白色集合中的所有对象全部回收（因为根据`GCRoots`节点进行可达性分析后，所有的存活对象都会从白色集合移入到黑色集合中，所以依旧留在白色集合中的对象必然为垃圾对象，这些对象就是需要被回收的对象）。
6. 最终等待清除工作完成后，代表着整个GC过程结束，再把标记复位，将所有的对象再次放入白色集合中，等待迎接下次GC的到来。

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法过程.gif" style="zoom: 67%;" />



参考文章：https://juejin.cn/post/7075258758196101156#heading-13



------

#### 9.4.2 错标情况

采用三色标记算法的GC收集器为了追求低延迟，一般在标记完`GCRoots`直接关联的对象后，就会结束`STW`，转而采取**并发标记**的手段对其他对象进行标记。但因为并发标记是GC线程与用户线程一起工作的，所以很有可能导致出现如下情况：

> 被标记的黑色对象中，突然断开了对另一个对象的引用，导致另外一个原本已经被标记为黑色的对象突然变为了垃圾。

但是因为该对象已经被标记了，所以收集器不会对该对象进行再次标记，而等到清除工作发生时，因为当前这个对象在最初是被标记为了黑色，所以收集器也不会回收它。这种情况则被称为三色标记导致的“**错标/误标/多标**”，也被称为并发标记产生的浮动垃圾。

对于该问题而言并非什么大事，因为这次错标产生的浮动垃圾，在下次GC时依旧会被回收，正所谓“躲得过初一，躲不过十五”，是垃圾早晚都会被“干掉”，这点在JVM中是毋庸置疑的，因此这个问题不必太过留意。



**多标情况：**当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为**浮动垃圾**

- 针对并发标记开始后的**新对象**，通常的做法是直接全部当成黑色，也算浮动垃圾
- 浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除

<img src="https://foruda.gitee.com/images/1685092755386470375/2091e359_8616658.png" style="zoom: 50%;" />



#### 9.4.3 漏标情况

1. 一条用户线程在执行过程中，断开了一个未标记的白色对象连接，然后该对象又被一个已经标记成黑色的对象建立起了引用连接。
2. 一条用户线程在执行过程中，正好在GC线程标记时，将一个灰色对象与一个未标记的白色对象之间的引用连接断开了，然后当GC标记完成这个灰色对象，将其标记为黑色后，之前断开的白色对象又重新与之建立起了引用关系。

当出现这两种情况时，因为重新建立引用的白色对象“父节点”已经被标记黑色了，所以GC线程不会再次标记该对象以及其成员对象，所以这些白色对象会被一直停留在白色集合中。最终导致的结果就是这些依旧存在引用的存活对象会被“误判”为垃圾对象清除掉。而这种情况会直接影响到应用程序的正确性，是不可接受的。



<img src="https://foruda.gitee.com/images/1685092900613483554/b061fc16_8616658.png" style="zoom:50%;" />

引起漏标问题的原因的必要条件：

- 条件一：灰色对象断开了与白色对象的引用（直接引用或间接引用都可）。
- 条件二：已经标为黑色的对象重新与白色对象建立了引用关系。

只有当一个对象同时满足了如上两个条件时才可发生漏标问题。

代码角度解释漏标：

```java
Object G = objE.fieldG; // 读
objE.fieldG = null;  	// 写
objD.fieldG = G;     	// 写
```



为了解决漏标情况，破坏其中任意一个条件即可，可以**将对象 G 记录起来，然后作为灰色对象再进行遍历**，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）

> 所以**重新标记需要 STW**，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完

**解决方法：**添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：

- **写屏障 + 增量更新**：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描

  增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标

  缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间

- **写屏障 (Store Barrier) + SATB**：当原来成员变量的引用发生变化之前，记录下原来的引用对象

  保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了，并且原始快照中本来就应该是灰色对象），最后重新扫描该对象的引用关系

  SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标

- **读屏障 (Load Barrier)**：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用

以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：

- CMS：写屏障 + 增量更新
- G1：写屏障 + SATB
- ZGC：读屏障

------



### 10 分区收集器



### 10.1 G1

在G1之前，所有的收集器都是按部就班的执行“物理+逻辑分代”的收集原则，而在G1收集器中，开始正式将堆空间划分为“**物理分区不分代**”的内存结构，从此拉开了JVM分区回收的序幕。

 G1全称为`Garbage-First Garbage Collector`（**垃圾优先收集器**），该款收集器在JDK1.7时被引入Java，在1.7之后，我们可以通过参数`-XX:+UseG1GC`装配它。G1是一款专门**针对于拥有多核处理器和大内存的机器**的收集器，在满足了GC响应时间的延迟可控的情况下，也会尽可能提高的程序的吞吐量，官方推出该款收集器的目的在于：打算使用G1替换CMS收集器，并且让G1担当起全功能收集器的重任和期望，成为JVM中的第一款能够驾驭一切的**全功能垃圾收集器**。**应用于新生代和老年代**、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（>4 ~ 6G），在 JDK9 之后默认使用 G1。

G1收集器具备如下特性：

1. 与CMS收集器一样，能够与用户线程同时执行，完成并发收集。
2. GC过程会有整理内存的过程，不会产生内存碎片，并且整理空闲内存速度更快。
3. GC发生时，停顿时间可控，可以让程序更大程度上追求低延迟。
4. 追求低延迟的同时，尽可能会保证高吞吐量。
5. 对于堆的未使用内存可以返还给操作系统。

#### 10.1.1 内存结构

jDK1.9 之前堆空间的布局都是采用分代存储的方式，无论从逻辑上还是从物理内存上，都是分代的。但是到了Java9的时候，因为默认GC器改为了G1，所以堆中的内存区域被划为了一个个的`Region`区。

 每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。在运行时，每个分区都会被打上唯一的分区标识。

不过在G1收集器中，年轻代`Eden`区、幸存区`Survivor`、老年代`Old`区这些概念依旧还存在，但却成为了逻辑上的概念，这样做的好处在于：也可以复用之前分代框架的逻辑，同时也满足了Java对象**朝生夕死**的特性。

> 不过G1收集器虽然在逻辑上存在分代的概念，但不再是物理隔阂了，也就是指在物理内存上是不分代的，内存空间会被划分为一个个的`Region`区，这样做的好处在于：JVM不需要再为堆空间分配连续的内存，堆空间可以是不连续物理内存来组成`Region`的集合。
> 同时也带来了额外的好处：有的`Region`区内垃圾对象特别多，有的分区内垃圾对象很少，G1可以优先回收垃圾对象特别多的`Region`区，这样可以花费较少的时间来回收垃圾，这也就是G1名字的由来，即垃圾优先收集器。

![输入图片说明](https://foruda.gitee.com/images/1680682619994624200/ff27bb54_8616658.png "屏幕截图")



> 一般`Region`区的大小等于堆空间的总大小除以2048，比如目前的堆空间总大小为8GB，就是`8192MB/2048=4MB`，那么最终每个`Region`区的大小为`4MB`，当然也可以用参数`-XX:G1HeapRegionSize`强制指定每个`Region`区的大小，但是不推荐，毕竟默认的计算方式计算出的大小是最适合管理堆空间的。
> 对于这块的逻辑，在HotSpot源码的`/share/vm/gc_implementation/g1/heapRegion.cpp`文件中定义了具体实现，具体可以参考其内部的`HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size)`函数。

   默认新生代对堆内存的初始占比是5%，如果堆大小为8GB，那么年轻代占据`400MB`左右的内存，对应大概是100个`Region`区，可以通过`-XX:G1NewSizePercent`设置新生代初始占比。
在Java程序运行中，JVM会不停的给新生代增加更多的`Region`区，但是最多新生代的占比不会超过堆空间总大小的60%，可以通过`-XX:G1MaxNewSizePercent`调整（也不推荐，如果超过这个比例，年老代的空间会变的很小，容易触发全局GC）。新生代中的`Eden`区和`Survivor`区对应的`Region`区比例也跟之前一样，默认8:1:1，假设新生代现在有400个`Region`，那么整个新生代的占比则为`Eden=320,S0/From=40,S1/To=40`。

   G1中的年老代晋升条件和之前的无差，达到年龄阈值的对象会被转入年老代的`Region`区中，不同的是对于大对象的分配，在G1中不会让大对象进入年老代，在G1中由专门存放大对象的`Region`区叫做`Humongous`区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入`Humongous`区存储。

> 在G1中，判定一个对象是否为大对象的方式为：对象大小是否超过单个普通`Region`区的50%，如果超过则代表当前对象为大对象，那么该对象会被直接放入`Humongous`区。比如：目前是8GB的堆空间，每个`Region`区的大小为`4MB`，当一个对象大小超过`2MB`时则会被判定为属于大对象。如果程序运行过程中出现一个“巨型对象”，当一个`Humongous`区存不下时，可能会横跨多个`Region`区存储它。

   `Humongous`区存在的意义：可以避免一些“短命”的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的GC开销。

   当堆空间发生全局GC(`FullGC`)时，除开回收新生代和年老代之外，也会对`Humongous`区进行回收。

#### 10.1.2 G1 中的GC类型

G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发

- 当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程
- 标记完成马上开始混合回收过程

<img src="https://foruda.gitee.com/images/1680682667375407051/f7733a74_8616658.png" style="zoom: 50%;" />

顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收

##### 10.1.2.1 Young GC

G1对于整个堆空间所有的`Region`区不会在一开始就全部分配完，无论是新生代、幸存区以及年老代在最开始都是会有初始数量的，在程序运行过程中会根据需求不断增加每个分代区域的`Region`数量。

   所以`YoungGC`并非说`Eden`区放满了就会立马被触发，在G1中，当新生代区域被用完时，**G1首先会大概计算一下回收当前的新生代空间需要花费多少时间**，如果回收时间远远小于参数`-XX:MaxGCPauseMills`设定的值，那么不会触发`YoungGC`，而是会继续为新生代增加新的`Region`区用于存放新分配的对象实例。直至某次`Eden`区空间再次被放满并经过计算后，此次回收的耗时接近`-XX:MaxGCPauseMills`参数设定的值，那么才会触发`YoungGC`。

   G1收集器中的新生代收集，依旧保留了分代收集器的特性，当`YoungGC`被触发时，首先会将目标`Region`区中的存活对象移动至幸存区空间（被打着`Survivor-from`区标志的`Region`）。同时达到晋升年龄标准的对象也会被移入至年老代`Region`中存储。

> 值得注意的是：G1收集器在发生`YoungGC`时，复制移动对象时是采用的多线程并行复制，以此来换取更优异的GC性能。
> 用户如若未曾显式通过`-XX:MaxGCPauseMills`参数设定GC预期回收停顿时间值，那么G1默认为`200ms`。





**回收过程**：

1. 扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口
2. 更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系
   - dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet
   - 作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好
3. 处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收
4. 复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间
5. 处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作



**Concurrent Mark **：

- 初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC
- 并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（**实时回收**），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（**防止漏标**）
- 筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW

![输入图片说明](https://foruda.gitee.com/images/1680682705749398861/e6a5604a_8616658.png "屏幕截图")



##### 10.1.2.2 MixedGC

 `MixedGC`混合型GC，而并非是指`FullGC`。当整个堆中年老代的区域占有率达到参数`-XX:InitiatingHeapOccupancyPercent`设定的值后触发`MixedGC`，发生该类型GC后，会回收**所有新生代`Region`区、部分年老代`Region`区**（会根据期望的GC停顿时间选择合适的年老代`Region`区优先回收）以及大对象`Humongous`区。

>    正常情况下，G1垃圾收集时会先发生`MixedGC`，主要采用复制算法，在GC时先将要回收的`Region`区中存活的对象拷贝至别的`Region`区内，拷贝过程中，如果发现没有足够多的空闲`Region`区承载拷贝对象，此时就会触发一次`Full GC`。

注意：**是一部分老年代，而不是全部老年代**，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制



##### 10.1.2.3 Full GC

 当整个堆空间中的**空闲`Region`不足以支撑拷贝对象或由于元数据空间满了等原因触发**，在发生`FullGC`时，G1首先会停止系统所有用户线程，然后采用单线程进行标记、清理和压缩整理内存，以便于清理出足够多的空闲`Region`来供下一次`MixedGC`使用。但该过程是单线程串行收集的，因此这个过程非常耗时的(`ShenandoahGC`中采用了多线程并行收集)。

> 其实G1收集器中并没有FullGC，，G1中的FullGC是采用serial old FullGC。因为G1在设计时的初衷就是要避免发生FullGC，如果上述两种GC发生后还是无法使得程序恢复正常执行，最终就会触发SerialOld收集器的FullGC。

产生 Full GC 的原因：

- 晋升时没有足够的空间存放晋升的对象
- 并发处理过程完成之前空间耗尽，浮动垃圾

#### 10.1.3 G1 回收过程

G1收集器一般在发生GC时执行过程大致会分为四个步骤（主要指`MixedGC`）：

1. 初始标记（`InitialMark`）：先触发`STW`，然后使用**单条GC线程快速标记`GCRoots`直连的对象**。
2. 并发标记（`ConcurrentMarking`）：与CMS的并发标记过程一致，采用多条GC线程与用户线程共同执行，根据`Root`根节点标记所有对象。
3. 最终标记（`Remark`）：同CMS的重新标记阶段，主要是为了纠正并发标记阶段因用户操作导致的错标、误标、漏标对象。
4. 筛选回收（`Cleanup`）：先**对各个`Region`区的回收价值和成本进行排序**，找出「回收价值最大」的`Region`优先回收。

> G1收集器正是由于「筛选回收」阶段的存在，所以才得以冠名「垃圾优先收集器」。在该阶段中，对各个`Region`区排序后，G1会根据用户指定的期望停顿时间（即`-XX:MaxGCPauseMillis`参数设定的值）选择「价值最大且最符合用户预期」的`Region`区进行回收，举个例子：
> 假设此时年老代空间共有`800`个`Region`区，并且都满了，所以此刻会触发GC。但根据GC的预期停顿时间值，本次GC只能允许停顿`200ms`，而G1经过前面的成本计算后，大致可推断出：本次GC回收`600`个`Region`区恰好停顿时间可控制在`200ms`左右，那么最终就会以「回收`600`个`Region`区」为基准触发GC，这样则能尽量确保GC导致的停顿时间可以被控制在我们指定的范围之内。

   不过值得注意的是：筛**选回收阶段在G1收集器中是会停止所有用户线程后，采用多线程并行回收的**。但实际上这个过程中可以与用户线程一起执行做到并发收集的，但因为G1只回收一部分`Region`区，停顿时间是可控的，因此停止用户线程后回收效率会大幅度提高。同时，假设实现并发回收，则又需要考虑用户线程执行带来的一些问题，所以综合考虑，G1中回收阶段采用了发生`STW`方案完成（在后续的`ZGC、ShenandoahGC`收集器中实现了并发回收）

*不过注意：在内存较小的堆空间情况下，CMS的表现会优于G1收集器，平衡点在6~8GB左右。*

#### 10.1.4 G1中的三色标记漏标问题

CMS收集器拉开了并发收集的新序幕，而并发收集的核心在于**三色标记算法**，但三色标记又注定着会出现漏标问题，所以接下来探讨一下G1收集器中解决三色算法漏标问题的手段：**STAB + 写屏障**。

> 对象的读写屏障的具体实现位于HotSpot源码的：`hotspot/src/share/vm/oops/oop.inline.hpp`文件，其内部是通过内联方法实现（HotSpot虚拟机中写屏障的实现有好几个版本）

##### 10.1.4.1 STAB解决漏标问题

 STAB全称为`snapshot-at-the-beginning`，其存在的意义是为了维护G1收集器GC-并发收集的正确性。GC的正确性是保证存活的对象不被回收，简单点来说就是保证回收的都是垃圾。

> 如果是独占式收集，也就是发生STW后串行回收的方式，那GC时能够确保100%的正确性，但如若收集过程是与用户线程并发执行的，GC线程一边标记，用户线程一边执行，因而堆中的对象引用会存在变更，出现不稳定因素，最终导致标记的正确性无法得到保障。而为了解决该问题，在G1收集器中则引入了STAB机制。

   STAB机制中，会在GC开始标记前通过`RootTracing`生成的一张堆空间存活对象快照，在并发标记时，所有快照中当时存活的对象就会认为是存活的，标记过程中新分配的对象也会被标记为存活对象，不会被回收，G1通过这种方式则可确保新分配对象的GC正确性。不过在理解STAB具体操作前，先来看看`Region`区结构：

![输入图片说明](https://foruda.gitee.com/images/1694060328615178398/2a95b567_8616658.png "region结构")



五个指针释义如下：

- 两个`TAMS(top-at-mark-start)`指针，用于记录前后两次发生并发标记时的位置。
- `bottom`指针：当前`Region`区分配对象的起始位置。
- `top`指针：`Region`区目前已用空间的位置。
- `end`指针：当前`Region`区能够分配的最大位置。

具体过程参考：https://juejin.cn/post/7080030329922125854



G1 对比其他处理器的优点：

- 并发与并行：
  - 并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW
  - 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况
  - 其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会**调用应用程序线程加速垃圾回收**过程
- **分区算法**：
  - 从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，**新生代和老年代不再物理隔离**，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC
  - 将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收
  - **新的区域 Humongous**：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC
  - G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉
  - Region 结构图：



#### 10.1.5 跨代引用问题

G1中则实现了一种新的数据结构：`Remembered Set`，简称为`RSet`，在有些地方也被称为“双向卡表”。

   在每个`Region`区中都存在一个`RSet`，其中记录了其他`Region`中的对象引用当前`Region`中对象的关系，也就是记录着“**谁引用了我的对象**”，属于`points-into`结构。而之前的卡表则是属于`points-out`结构，记录着“**我引用了谁的对象**”，在卡表中存在多个卡页，每个卡页记录着一定范围（`512KB`）的堆。

> `RSet`也好，`CardTable`也罢，其实都是记忆集的一种具体实现，你也可以将`RSet`理解成一种`CardTable`的进阶实现方式。G1中的`RSet`本质上就是一个哈希表结构（`HashTable`），`Key`为其他引用当前区内对象的`Region`起始地址，`Value`则是一个集合，里面的元素为其他`Region`中每个引用当前区内对象的地址。
> 在虚拟机运行期间，`RSet`中的引用关系靠`post-write barrier`和`Concurrent refinement threads`来维护。

   

![输入图片说明](https://foruda.gitee.com/images/1680682645681025856/660b33d0_8616658.png "屏幕截图")

- 程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中
- 进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏

垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：

- 字长精度
- 对象精度
- 卡精度(卡表)

卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式

收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中

- CSet of Young Collection
- CSet of Mix Collection

当发生YGC时，扫描标记对象时，只需要选定目标新生代`Region`的`RSet`作为根集，这些`RSet`中记录了`Old → Young`的跨代引用，GC扫描时只需要扫描这些`RSet`即可，从而避免了扫描整个`Old`区。而当G1发生`MixedGC`时，`Old`类型的`Region`也有`RSet`记录着`Old → Old`的引用关系，而`Old → Young`的跨代引用可以从`Young`类型的`Region`中得到，这样在发生`MixedGC`时也不会出现整堆扫描的情况，所以引入`RSet`在很大程度上减少了大量的GC工作。

> *实际上G1中的RSet对内存的开销也并不小，当JVM中分区较多且运行时间较长的情况下，这块的内存开销可能会占用到20%以上。*



- 空间整合：

  - CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理
  - G1：整体来看是**基于标记 - 整理算法实现**的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片

- **可预测的停顿时间模型（软实时 soft real-time）**：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒

  - 由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制
  - G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个**优先列表**，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率


  - 相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多

G1 垃圾收集器的缺点：

- 相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高
- 从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间

应用场景：

- 面向服务端应用，针对具有大内存、多处理器的机器
- 需要低 GC 延迟，并具有大堆的应用程序提供解决方案


------



**相关参数**

- `-XX:+UseG1GC`：手动指定使用 G1 垃圾收集器执行内存回收任务
- `-XX:G1HeapRegionSize`：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000
- `-XX:MaxGCPauseMillis`：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms
- `-XX:+ParallelGcThread`：设置 STW 时 GC 线程数的值，最多设置为 8
- `-XX:ConcGCThreads`：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右
- `-XX:InitiatingHeapoccupancyPercent`：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45
- `-XX:+ClassUnloadingWithConcurrentMark`：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类
- `-XX:G1NewSizePercent`：新生代占用整个堆内存的最小百分比（默认5％） 
- `-XX:G1MaxNewSizePercent`：新生代占用整个堆内存的最大百分比（默认60％） 
- `-XX:G1ReservePercent=10`：保留内存区域，防止 to space（Survivor中的 to 区）溢出

------



** 调优 **

G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：

1. 开启 G1 垃圾收集器
2. 设置堆的最大内存
3. 设置最大的停顿时间（STW）

不断调优暂停时间指标：

- `XX:MaxGCPauseMillis=x` 可以设置启动应用程序暂停的时间，G1会根据这个参数选择 CSet 来满足响应时间的设置
- 设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成50ms就不太合理
- 暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC
- 对这个参数的调优是一个持续的过程，逐步调整到最佳状态

不要设置新生代和老年代的大小：

- 避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标
- 设置了新生代大小相当于放弃了 G1 的自动调优，我们只需要设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小

------



### ZGC

ZGC 收集器是一个可伸缩的、低延迟的垃圾收集器，基于 Region 内存布局的，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现**可并发的标记压缩算法**

- 在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了读屏障
- 染色指针：直接**将少量额外的信息存储在指针上的技术**，从 64 位的指针中拿高 4 位来标识对象此时的状态
  - 染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用
  - 可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize() 方法才能被访问到（Finalizable）
  - 可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作
  - 可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据
- 内存多重映射：多个虚拟地址指向同一个物理地址

可并发的标记压缩算法：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，**并更新引用**，不会像 G1 一样必须等待垃圾回收完成才能访问

ZGC 目标：

- 停顿时间不会超过 10ms
- 停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）
- 可支持几百 M，甚至几 T 的堆大小（最大支持4T）

ZGC 的工作过程可以分为 4 个阶段：

- 并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿
- 并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）
- 并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的**每个 Region 维护一个转发表**（Forward Table），记录从旧地址到新地址的转向关系
- 并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销

ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟

优点：高吞吐量、低延迟

缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾



参考文章：https://www.cnblogs.com/jimoer/p/13170249.html



------



### 总结

Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC  不同：

- 最小化地使用内存和并行开销，选 Serial GC
- 最大化应用程序的吞吐量，选 Parallel GC
- 最小化 GC 的中断或停顿时间，选 CMS GC

![输入图片说明](https://foruda.gitee.com/images/1685093127599899140/7fdd1b60_8616658.png "JVM-垃圾回收器总结")





### 对象创建

#### 生命周期

在 Java 中，对象的生命周期包括以下几个阶段：

1. 创建阶段 (Created)
2. 应用阶段 (In Use)：对象至少被一个强引用持有着；
3. 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用；
4. 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用；
5. 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法；
6. 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完finalize() 方法后仍然处于不可达状态时进入该阶段；
7. 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配；

参考文章：https://blog.csdn.net/sodino/article/details/38387049







#### 承上启下

1. 一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次

   JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值

2. 类的初始化过程与类的实例化过程的异同？

   类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）

3. 假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（**经典案例**）

   ```java
   public class StaticTest {
       public static void main(String[] args) {
           staticFunction();//调用静态方法，触发初始化
       }

       static StaticTest st = new StaticTest();

       static {   //静态代码块
           System.out.println("1");
       }

       {       // 实例代码块
           System.out.println("2");
       }

       StaticTest() {    // 实例构造器
           System.out.println("3");
           System.out.println("a=" + a + ",b=" + b);
       }

       public static void staticFunction() {   // 静态方法
           System.out.println("4");
       }

       int a = 110;    		// 实例变量
       static int b = 112;     // 静态变量
   }/* Output: 
           2
           3
           a=110,b=0
           1
           4
    *///:~
   ```

   `static StaticTest st = new StaticTest();`：

   - 实例实例化不一定要在类初始化结束之后才开始
   - 在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，**实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置**，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因

   代码等价于：

   ```java
   public class StaticTest {
       <clinit>(){
           a = 110;    // 实例变量
           System.out.println("2");	// 实例代码块
           System.out.println("3");	// 实例构造器中代码的执行
           System.out.println("a=" + a + ",b=" + b);  // 实例构造器中代码的执行
           类变量st被初始化
           System.out.println("1");	//静态代码块
           类变量b被初始化为112
       }
   }
   ```


***

## 内存管理

### 内存分配

#### 两种方式

不分配内存的对象无法进行其他操作，JVM 为对象分配内存的过程：

首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。

* 如果**内存规整**，使用**指针碰撞**（Bump The Pointer）。所有用过的内存在一边，空闲的内存在另外一边，中间有一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离。
* 如果**内存不规整**，虚拟机需要维护一个**空闲列表**（Free List）分配。已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。


***



#### TLAB

TLAB：Thread Local Allocation Buffer，为**每个线程**在**堆**内单独分配了一个**缓冲区**，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做**快速分配策略** 。

- 栈上分配使用的是栈来进行对象内存的分配。
- TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存。

堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

> ❓  堆空间都是共享的么？
>
>  不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占

<img src="https://foruda.gitee.com/images/1681697258813647236/ec1c1724_8616658.png" style="zoom:67%;" />

JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过**使用加锁机制确保数据操作的原子性**，从而直接在堆中分配内存。

栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存

参数设置：

* `-XX:UseTLAB`：设置是否开启 TLAB 空间。

* `-XX:TLABWasteTargetPercent`：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%。
* `-XX:TLABRefillWasteFraction`：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配。

<img src="https://foruda.gitee.com/images/1680663039323431352/63014be8_8616658.png" style="zoom:67%;" />



***



#### 逃逸分析

**即时编译**（Just-in-time Compilation，JIT）是一种通过在**运行时**将**字节码**翻译为**机器码**，从而改善性能的技术，在 HotSpot 实现中有多种选择：C1、C2 和 C1+C2，分别对应 Client、Server 和分层编译。

* C1 编译速度快，优化方式比较保守；C2 编译速度慢，优化方式比较激进。
* C1+C2 在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译。

**逃逸分析**并不是直接的优化手段，而是一个**代码分析方式**，通过动态分析对象的作用域，为优化手段（如，栈上分配、标量替换和同步消除等）提供依据，发生逃逸行为的情况有两种：**方法逃逸**和**线程逃逸**。

* 方法逃逸：当一个对象在方法中定义之后，`new`的对象实体被**方法外调用**就是发生了**逃逸分析**。对象作用域尽在当前方法中，就没有发生逃逸分析。
  * 全局逃逸：一个对象的作用范围逃出了当前方法或者当前线程，比如对象是一个静态变量、全局变量赋值、已经发生逃逸的对象、作为当前方法的返回值。
  * 参数逃逸：一个对象被作为方法参数传递或者被参数引用。
* 线程逃逸：如类变量或实例变量，可能被其它线程访问到。

如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配。

* **同步消除**

  线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的**同步锁**，通过 `-XX:+EliminateLocks` 可以开启同步消除 ( - 号关闭)。

* 标量替换

  * 标量替换：如果把一个对象拆散，将其成员变量恢复到基本类型来访问。
  * 标量 (scalar) ：不可分割的量，如基本数据类型和 reference 类型。
  * 聚合量 (Aggregate)：一个数据可以继续分解，对象一般是聚合量。
  * 如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替。
  * 参数设置：

    * `-XX:+EliminateAllocations`：开启标量替换
    * `-XX:+PrintEliminateAllocations`：查看标量替换情况

* 栈上分配

  JIT 编译器在编译期间根据逃逸分析的结果，如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需 GC。

  User 对象的作用域局限在方法 fn 中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会生成 User 对象，大大减轻 GC 的压力。

  ```java
  public class JVM {
      public static void main(String[] args) throws Exception {
          int sum = 0;
          int count = 1000000;
          //warm up
          for (int i = 0; i < count ; i++) {
              sum += fn(i);
          }
          System.out.println(sum);
          System.in.read();
      }
      private static int fn(int age) {
          User user = new User(age);
          int i = user.getAge();
          return i;
      }
  }

  class User {
      private final int age;

      public User(int age) {
          this.age = age;
      }

      public int getAge() {
          return age;
      }
  }
  ```




***



#### 分代思想

##### 分代介绍

Java8 时，堆被分为了两份：新生代和老年代（1:2），在 Java7 时，还存在一个永久代。

- 新生代使用：复制算法。
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法。

**Minor GC 和 Full GC**：

- Minor GC：回收新生代，新生代对象存活时间很短，所以 Minor GC 会频繁执行，执行的速度比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，所以 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

> ❓ Minor GC 和 Full GC 的触发条件？
>
> Eden区要满时触发YoungGC（Minor GC）。
>
> FullGC同时回收新生代、老年代和方法区，只会存在一个FullGC的线程进行执行（STW），其他线程全部挂起，触发条件：
>
> - `System.gc()` 或 `Runtime.getRuntime().gc()` 。
> - 老年代空间不足。
> - 空间分配担保
>
> [触发条件](#回收策略)
>
> 
>
> 

 Eden 和 Survivor 大小比例默认为 8:1:1 。

<img src="https://foruda.gitee.com/images/1681698787859309675/8997d795_8616658.png" style="zoom: 67%;" />





***



##### 分代分配

工作机制：

* **对象优先在 Eden 分配**：当创建一个对象的时候，对象会被分配在新生代的 Eden 区，当 Eden 区要满了时候，触发 YoungGC 。
* 当进行 YoungGC 后，此时在 Eden 区存活的对象被移动到 to 区，并且当前对象的年龄会加 1，清空 Eden 区。
* 当再一次触发 YoungGC 的时候，会把 Eden 区中存活下来的对象和 to 中的对象，移动到 from 区中，这些对象的年龄会加 1，清空 Eden 区和 to 区。
* To 区永远是空 Survivor 区，From 区是有数据的，每次 MinorGC 后两个区域互换。
* From 区和 To 区 也可以叫做 S0 区和 S1 区。

晋升到老年代：

* **长期存活的对象进入老年代**：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

  `-XX:MaxTenuringThreshold`：定义年龄的阈值，对象头中用 4 个 bit 存储，所以最大值是 15，默认也是 15 。

* **大对象直接进入老年代**：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象。

  `-XX:PretenureSizeThreshold`：大于此值的对象直接在老年代分配

* **动态对象年龄判定**：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。

空间分配担保：

* 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的
* 如果不成立，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC；如果小于或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。




***



### 回收策略

#### 触发条件

内存垃圾回收机制主要集中的区域就是线程共享区域：**堆和方法区**

**Minor GC** 触发条件非常简单，当 **Eden 空间满**时，就将触发一次 Minor GC

**FullGC** 同时回收新生代、老年代和方法区，只会存在一个 FullGC 的线程进行执行（**STW**），其他的线程全部会被**挂起**，有以下触发条件：

* 调用 System.gc()：

  * 在默认情况下，通过 System.gc() 或 Runtime.getRuntime().gc() 的调用，会显式触发 FullGC，同时对老年代和新生代进行回收，但是虚拟机不一定真正去执行，无法保证对垃圾收集器的调用
  * 不建议使用这种方式，应该让虚拟机管理内存。一般情况下，垃圾回收应该是自动进行的，无须手动触发；在一些特殊情况下，如正在编写一个性能基准，可以在运行之间调用 System.gc() 

* 老年代空间不足：

  * 为了避免引起的 Full GC，应当尽量不要创建过大的对象以及数组
  * 通过 -Xmn 参数调整新生代的大小，让对象尽量在新生代被回收掉不进入老年代，可以通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间

* 空间分配担保失败。

* JDK 1.7 及以前的永久代（方法区）空间不足。

* Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。


手动 GC 测试，VM参数：`-XX:+PrintGcDetails`

```java
public void localvarGC1() {
    byte[] buffer = new byte[10 * 1024 * 1024];//10MB
    System.gc();	//输出: 不会被回收, FullGC时被放入老年代
}

public void localvarGC2() {
    byte[] buffer = new byte[10 * 1024 * 1024];
    buffer = null;
    System.gc();	//输出: 正常被回收
}
 public void localvarGC3() {
     {
         byte[] buffer = new byte[10 * 1024 * 1024];
     }
     System.gc();	//输出: 不会被回收, FullGC时被放入老年代
 }

public void localvarGC4() {
    {
        byte[] buffer = new byte[10 * 1024 * 1024];
    }
    int value = 10;
    System.gc();	//输出: 正常被回收，slot复用，局部变量过了其作用域 buffer置空
}
```



***



#### 安全区域

**安全点** (Safepoint)：程序执行时并非在所有地方都能停顿下来开始 GC，只有在安全点才能停下。

- Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题。
- 大部分指令的执行时间都非常短，通常会根据是否具有让程序长时间执行的特征为标准，选择些执行时间较长的指令作为 Safe Point， 如方法调用、循环跳转和异常跳转等。

在 GC 发生时，让所有线程都在最近的安全点停顿下来的方法：

- **抢先式中断**：没有虚拟机采用，首先中断所有线程，如果有线程不在安全点，就恢复线程让线程运行到安全点。
- **主动式中断**：设置一个中断标志，各个线程运行到各个 Safe Point 时就轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

问题：Safepoint 保证程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但是当线程处于 Waiting 状态或 Blocked 状态，线程无法响应 JVM 的中断请求，运行到安全点去中断挂起，JVM 也不可能等待线程被唤醒，对于这种情况，需要安全区域来解决。

安全区域 (Safe Region)：指在一段代码片段中，**对象的引用关系不会发生变化**，在这个区域中的任何位置开始 GC 都是安全的。

运行流程：

- 当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程。

- 当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了则继续运行，否则线程必须等待 GC 完成，收到可以安全离开 SafeRegion 的信号。


***



### 垃圾判断

#### 垃圾介绍

垃圾：**如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾** 。

作用：释放没用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象。

垃圾收集主要是针对**堆**和**方法区**进行，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段，判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**



***



> 
>

***



1. - ​


***



#### 无用属性

##### 无用类

方法区主要回收的是无用的类

判定一个类是否是无用的类，需要同时满足下面 3 个条件：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 `ClassLoader` 已经被回收
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的**仅仅是可以**，而并不是和对象一样不使用了就会必然被回收



***



##### 废弃常量

在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该常量，说明常量 "abc" 是废弃常量，如果这时发生内存回收的话**而且有必要的话**（内存不够用），"abc" 就会被系统清理出常量池



***



##### 静态变量

类加载时（第一次访问），这个类中所有静态成员就会被加载到静态变量区，该区域的成员一旦创建，直到程序退出才会被回收

如果是静态引用类型的变量，静态变量区只存储一份对象的引用地址，真正的对象在堆内，如果要回收该对象可以设置引用为 null



参考文章：https://blog.csdn.net/zhengzhb/article/details/7331354



***







***



## 垃圾回收器

### 概述

垃圾收集器分类：

* 按**线程数**分（垃圾回收线程数），可以分为**串行**垃圾回收器和**并行**垃圾回收器
  * 除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行
* 按照**工作模式**分，可以分为**并发**式垃圾回收器和**独占**式垃圾回收器
  * 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间
  * 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束
* 按**碎片处理方式**分，可分为**压缩式**垃圾回收器和**非压缩**式垃圾回收器
  * 压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞
  * 非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表
* 按**工作的内存区间**分，又可分为**年轻代**垃圾回收器和**老年代**垃圾回收器

GC 性能指标：

- **吞吐量**：程序的运行时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：相对于应用程序的执行，收集操作发生的频率
- 内存占用：Java 堆区所占的内存大小
- 快速：一个对象从诞生到被回收所经历的时间

**垃圾收集器的组合关系**：

![输入图片说明](https://foruda.gitee.com/images/1680680743326551738/7fc4108e_8616658.png "屏幕截图")

新生代收集器：Serial、ParNew、Parallel Scavenge

老年代收集器：Serial old、Parallel old、CMS

整堆收集器：G1

* 红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器

查看默认的垃圾收回收器：

* `-XX:+PrintcommandLineFlags`：查看命令行相关参数（包含使用的垃圾收集器）

* 使用命令行指令：jinfo -flag 相关垃圾回收器参数  进程 ID


***





***



## 内存泄漏

内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。由于代码的实现不同就会出现很多种内存泄漏问题，让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏。

内存溢出（out of memory）指的是申请内存时，没有足够的内存可以使用。

内存泄漏和内存溢出的关系：内存泄漏的越来越多，最终会导致内存溢出。



***



### 静态集合

静态集合类的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。原因是**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

```java
public class MemoryLeak {
    static List list = new ArrayList();
    public void oomTest(){
        Object obj = new Object();//局部变量
        list.add(obj);
    }
}
```



***



### 单例模式

单例模式和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。



****



### 内部类

内部类持有外部类的情况，如果一个外部类的实例对象调用方法返回了一个内部类的实例对象，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象也不会被回收，造成内存泄漏。

ps：不太理解



***



### 连接相关

数据库连接、网络连接和 IO 连接等，当不再使用时，需要显式调用 close 方法来释放与连接，垃圾回收器才会回收对应的对象，否则将会造成大量的对象无法被回收，从而引起内存泄漏。



****



### 不合理域

变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏；如果没有及时地把对象设置为 null，也有可能导致内存泄漏的发生。

```java
public class UsingRandom {
    private String msg;
    public void receiveMsg(){
        msg = readFromNet();// 从网络中接受数据保存到 msg 中
        saveDB(msg);		// 把 msg 保存到数据库中
    }
}
```

通过 readFromNet 方法把接收消息保存在 msg 中，然后调用 saveDB 方法把内容保存到数据库中，此时 msg 已经可以被回收，但是 msg 的生命周期与对象的生命周期相同，造成 msg 不能回收，产生内存泄漏

解决：

* msg 变量可以放在 receiveMsg 方法内部，当方法使用完，msg 的生命周期也就结束，就可以被回收了；
* 在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。


****



### 改变哈希

当一个对象被存储进 HashSet 集合中以后，就**不能修改这个对象中的那些参与计算哈希值的字段**，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值不同，这种情况下使用该对象的当前引用作为的参数去 HashSet 集合中检索对象返回 false，导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏。



***



### 缓存泄露

内存泄漏的一个常见来源是缓存，一旦把对象引用放入到缓存中，就会很容易被遗忘；

使用 WeakHashMap 代表缓存，当除了自身有对 key 的引用外没有其他引用，map 会自动丢弃此值。





***



#### 案例分析

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) { //入栈
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() { //出栈
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

程序并没有明显错误，但 pop 函数存在内存泄漏问题，因为 pop 函数只是把栈顶索引下移一位，并没有把上一个出栈索引处的引用置空，导致**栈数组一直强引用着已经出栈的对象**

解决方法：

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;
    return result;
}
```





****





***





## 运行机制

### 执行过程

Java 文件编译执行的过程：

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java文件编译执行的过程.png)

- 类加载器：用于装载字节码文件（.class文件）
- 运行时数据区：用于分配存储空间
- 执行引擎：执行字节码文件或本地方法
- 垃圾回收器：用于对 JVM 中的垃圾内容进行回收


****



### 字节码

#### 跨平台性

Java 语言：跨平台的语言（write once ，run anywhere）

* 当 Java 源代码成功编译成字节码后，在不同的平台上面运行**无须再次编译**
* 让一个 Java 程序正确地运行在 JVM 中，Java 源码就必须要被编译为符合 JVM 规范的字节码

编译过程中的编译器：

* 前端编译器： Sun 的全量式编译器 javac、 Eclipse 的增量式编译器 ECJ，**把源代码编译为字节码文件 .class**

  * IntelliJ IDEA 使用 javac 编译器
  * Eclipse 中，当开发人员编写完代码后保存时，ECJ 编译器就会把未编译部分的源码逐行进行编译，而非每次都全量编译，因此 ECJ 的编译效率会比 javac 更加迅速和高效
  * 前端编译器并不会直接涉及编译优化等方面的技术，具体优化细节移交给 HotSpot 的 JIT 编译器负责

* 后端运行期编译器：HotSpot VM 的 C1、C2 编译器，也就是 JIT 编译器，Graal 编译器

  * JIT 编译器：执行引擎部分详解
  * Graal 编译器：JDK10 HotSpot 加入的一个全新的即时编译器，编译效果短短几年时间就追平了 C2

* 静态提前编译器：AOT  (Ahead Of Time Compiler）编译器，直接把源代码编译成本地机器代码

  * JDK 9 引入，是与即时编译相对立的一个概念，即时编译指的是在程序的运行过程中将字节码转换为机器码，AOT 是程序运行之前便将字节码转换为机器码

  * 优点：JVM 加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少 Java 应用第一次运行慢的现象
  * 缺点：
    * 破坏了 Java **一次编译，到处运行**，必须为每个不同硬件编译对应的发行包
    * 降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知




***



#### 语言发展

机器码：各种用二进制编码方式表示的指令，与 CPU 紧密相关，所以不同种类的 CPU 对应的机器指令不同

指令：指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令，例如 mov，inc 等，可读性稍好，但是不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同

指令集：不同的硬件平台支持的指令是有区别的，每个平台所支持的指令，称之为对应平台的指令集

- x86 指令集，对应的是 x86 架构的平台
- ARM 指令集，对应的是 ARM 架构的平台

汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址

* 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令
* 计算机只认识指令码，汇编语言编写的程序也必须翻译成机器指令码，计算机才能识别和执行

高级语言：为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言

字节码：是一种中间状态（中间码）的二进制代码，比机器码更抽象，需要直译器转译后才能成为机器码

* 字节码为了实现特定软件运行和软件环境，与硬件环境无关
* 通过编译器和虚拟机器实现，编译器将源码编译成字节码，虚拟机器将字节码转译为可以直接执行的指令

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-高级语言执行过程.png" style="zoom:50%;" />



***





## 类结构

### Class类文件结构

任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是类或接口不一定都定义在文件总，可以动态生成直接送入类加载其中。

Class文件是一组以8个字节为基础单位的**二进制流**，存储的是JVM字节码指令而不是机器码，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。

JVM 官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html

根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表” 。

- 无符号数属于**基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
- 表是由**多个无符号数或者其他表作为数据项**构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。

Class文件结构如下：

```java
ClassFile {
	u4 				magic; //魔数，识别类文件格式	4个字节					
    u2 				minor_version;	//副版本号(小版本)2个字节				
    u2 				major_version; //主版本号(小版本)2个字节						
    u2 				constant_pool_count;//常量池计数器2个字节
    cp_info			constant_pool[constant_pool_count-1];//常量池表n个字节
    u2	 			access_flags;//访问标识2个字节
    u2 				this_class;//类索引2个字节
    u2 				super_class;//父类索引2个字节
    u2 				interfaces_count;//接口计数2个字节
    u2 				interfaces[interfaces_count];//接口索引集合2个字节
    u2 				fields_count;//字段计数器2个字节
    field_info 		fields[fields_count];//字段表n个字节
    u2 				methods_count;//方法计数器2个字节
    method_info 	methods[methods_count];//方法表n个字节
    u2 				attributes_count;//属性计数器2个字节
    attribute_info 	attributes[attributes_count];//属性表n个字节
}
```



获取方式：

* HelloWorld.java 执行 `javac -parameters -d . HellowWorld.java`指令；
* 写入文件指令 `javap -v xxx.class >xxx.txt；`
* IDEA 插件 jclasslib 。


***



##### 魔数版本

魔数：每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number），是 Class 文件的标识符，用于确定这个文件是否能被虚拟机接受的 Class 文件。

* 魔数值固定为 0xCAFEBABE，不符合则会抛出错误

* 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动

版本：4 个 字节，第5和第6两个字节代表的是编译的副版本号 minor_version，而第7和第8 两个字节是编译的主版本号 major_version。不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，高版本的 Java 虚拟机可兼容由低版本编译器生成的 Class 文件，反之 JVM 会抛出异常 `java.lang.UnsupportedClassVersionError`

| 主版本（十进制） | 副版本（十进制） | 编译器版本 |
| -------- | -------- | ----- |
| 45       | 3        | 1.1   |
| 46       | 0        | 1.2   |
| 47       | 0        | 1.3   |
| 48       | 0        | 1.4   |
| 49       | 0        | 1.5   |
| 50       | 0        | 1.6   |
| 51       | 0        | 1.7   |
| 52       | 0        | 1.8   |
| 53       | 0        | 1.9   |
| 54       | 0        | 1.10  |
| 55       | 0        | 1.11  |

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类结构.png)



图片来源：https://www.bilibili.com/video/BV1PJ411n7xZ



***



##### 常量池

常量池可以比作Class文件里的资源仓库，常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池计数器（constant_pool_count），这个容量计数是从 1 而不是 0 开始，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”，这种情况可用索引值 0 来表示。

constant_pool 是一种表结构，以1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。

* 字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等；

* 符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符；

  * 全限定名：`com/test/Demo` 这个就是类的全限定名，仅仅是把包名的 `.` 替换成 `/`，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 `;` 表示全限定名结束；
  * 简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 `x` 的简单名称就是 `x` ；
  * 描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值；

| 标志符  | 含义                                       |
| ---- | ---------------------------------------- |
| B    | 基本数据类型 byte                              |
| C    | 基本数据类型 char                              |
| D    | 基本数据类型 double                            |
| F    | 基本数据类型 float                             |
| I    | 基本数据类型 int                               |
| J    | 基本数据类型 long                              |
| S    | 基本数据类型 short                             |
| Z    | 基本数据类型 boolean                           |
| V    | 代表 void 类型                               |
| L    | 对象类型，比如：`Ljava/lang/Object;`，不同方法间用`;`隔开 |
| [    | 数组类型，代表一维数组。比如：`double[][][] is [[[D`    |

常量类型和结构：

| 类型                               | 标志(或标识) | 描述          |
| -------------------------------- | ------- | ----------- |
| CONSTANT_utf8_info               | 1       | UTF-8编码的字符串 |
| CONSTANT_Integer_info            | 3       | 整型字面量       |
| CONSTANT_Float_info              | 4       | 浮点型字面量      |
| CONSTANT_Long_info               | 5       | 长整型字面量      |
| CONSTANT_Double_info             | 6       | 双精度浮点型字面量   |
| CONSTANT_Class_info              | 7       | 类或接口的符号引用   |
| CONSTANT_String_info             | 8       | 字符串类型字面量    |
| CONSTANT_Fieldref_info           | 9       | 字段的符号引用     |
| CONSTANT_Methodref_info          | 10      | 类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info | 11      | 接口中方法的符号引用  |
| CONSTANT_NameAndType_info        | 12      | 字段或方法的符号引用  |
| CONSTANT_MethodHandle_info       | 15      | 表示方法句柄      |
| CONSTANT_MethodType_info         | 16      | 标志方法类型      |
| CONSTANT_InvokeDynamic_info      | 18      | 表示一个动态方法调用点 |

18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer  。



****



##### 访问标识

访问标识（access_flag），又叫访问标志、访问标记，该标识用两个字节表示，用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public类型，是否定义为 abstract类型等。

* 类的访问权限通常为 ACC_ 开头的常量；
* 每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的，比如若是 public final 的类，则该标记为 `ACC_PUBLIC | ACC_FINAL` ；
* 使用 `ACC_SUPER` 可以让类更准确地定位到父类的方法，确定类或接口里面的invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记。

| 标志名称           | 标志值    | 含义                                       |
| -------------- | ------ | ---------------------------------------- |
| ACC_PUBLIC     | 0x0001 | 标志为 public 类型                            |
| ACC_FINAL      | 0x0010 | 标志被声明为 final，只有类可以设置                     |
| ACC_SUPER      | 0x0020 | 标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法 |
| ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                 |
| ACC_ABSTRACT   | 0x0400 | 是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |
| ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）           |
| ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                 |
| ACC_ENUM       | 0x4000 | 标志这是一个枚举                                 |



***



##### 索引集合

类索引、父类索引、接口索引集合。

* 类索引用于确定这个类的全限定名；

* 父类索引用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个，除了Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0；

* 接口索引集合就用来描述这个类实现了哪些接口：
  * interfaces_count 项的值表示当前类或接口的直接超接口数量；
  * interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中；

| 长度   | 含义                           |
| ---- | ---------------------------- |
| u2   | this_class                   |
| u2   | super_class                  |
| u2   | interfaces_count             |
| u2   | interfaces[interfaces_count] |



***



##### 字段表

字段 fields 用于描述接口或类中声明的变量。包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述。

fields_count（字段计数器），表示当前 class 文件 fields 表的成员个数，用两个字节来表示。

fields[]（字段表）：表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。

- 字段访问标识：

| 标志名称          | 标志值    | 含义             |
| ------------- | ------ | -------------- |
| ACC_PUBLIC    | 0x0001 | 字段是否为public    |
| ACC_PRIVATE   | 0x0002 | 字段是否为private   |
| ACC_PROTECTED | 0x0004 | 字段是否为protected |
| ACC_STATIC    | 0x0008 | 字段是否为static    |
| ACC_FINAL     | 0x0010 | 字段是否为final     |
| ACC_VOLATILE  | 0x0040 | 字段是否为volatile  |
| ACC_TRANSTENT | 0x0080 | 字段是否为transient |
| ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生  |
| ACC_ENUM      | 0x4000 | 字段是否为enum      |

* 字段名索引：根据该值查询常量池中的指定索引项即可

* 描述符索引：用来描述字段的数据类型、方法的参数列表和返回值

  | 字符          | 类型        | 含义                 |
  | ----------- | --------- | ------------------ |
  | B           | byte      | 有符号字节型树            |
  | C           | char      | Unicode字符，UTF-16编码 |
  | D           | double    | 双精度浮点数             |
  | F           | float     | 单精度浮点数             |
  | I           | int       | 整型数                |
  | J           | long      | 长整数                |
  | S           | short     | 有符号短整数             |
  | Z           | boolean   | 布尔值true/false      |
  | V           | void      | 代表void类型           |
  | L Classname | reference | 一个名为Classname的实例   |
  | [           | reference | 一个一维数组             |

* 属性表集合：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等

  ```java
  ConstantValue_attribute{
      u2 attribute_name_index;
      u4 attribute_length;
      u2 constantvalue_index;
  }
  ```

  对于常量属性而言，attribute_length 值恒为2


***



##### 方法表

方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，完整描述了每个方法的签名。

* 如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来；
* methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法；
* methods 表可能会出现由编译器自动添加的方法，比如初始化方法 <cinit> 和实例化方法 <init> 。

方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中的一个名为“Code”的属性里面。

**重载（Overload）**一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，**特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合**，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。

methods_count（方法计数器）：表示 class 文件 methods 表的成员个数，使用两个字节来表示。

methods[]（方法表）：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述。

* 方法表结构如下：

  | 类型             | 名称               | 含义    | 数量               |
  | -------------- | ---------------- | ----- | ---------------- |
  | u2             | access_flags     | 访问标志  | 1                |
  | u2             | name_index       | 字段名索引 | 1                |
  | u2             | descriptor_index | 描述符索引 | 1                |
  | u2             | attrubutes_count | 属性计数器 | 1                |
  | attribute_info | attributes       | 属性集合  | attributes_count |

* 方法表访问标志：

  | 标志名称          | 标志值    | 含义              |
  | ------------- | ------ | --------------- |
  | ACC_PUBLIC    | 0x0001 | 字段是否为 public    |
  | ACC_PRIVATE   | 0x0002 | 字段是否为 private   |
  | ACC_PROTECTED | 0x0004 | 字段是否为 protected |
  | ACC_STATIC    | 0x0008 | 字段是否为 static    |
  | ACC_FINAL     | 0x0010 | 字段是否为 final     |
  | ACC_VOLATILE  | 0x0040 | 字段是否为 volatile  |
  | ACC_TRANSTENT | 0x0080 | 字段是否为 transient |
  | ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生   |
  | ACC_ENUM      | 0x4000 | 字段是否为 enum      |


***



##### 属性表

属性表集合，指的是 Class 文件所携带的**辅助信息**，比如该 Class 文件的源文件的名称，以及任何带有 `RetentionPolicy.CLASS` 或者 `RetentionPolicy.RUNTIME` 的注解，这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试。字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息。

attributes_ count（属性计数器）：表示当前文件属性表的成员个数；

attributes[]（属性表）：属性表的每个项的值必须是 attribute_info 结构；

* 属性的通用格式：

  ```java
  ConstantValue_attribute{
      u2 attribute_name_index;	//属性名索引
      u4 attribute_length;		//属性长度
      u2 attribute_info;			//属性表
  }
  ```

* 属性类型：

  | 属性名称                                  | 使用位置      | 含义                                       |
  | ------------------------------------- | --------- | ---------------------------------------- |
  | Code                                  | 方法表       | Java 代码编译成的字节码指令                         |
  | ConstantValue                         | 字段表       | final 关键字定义的常量池                          |
  | Deprecated                            | 类、方法、字段表  | 被声明为 deprecated 的方法和字段                   |
  | Exceptions                            | 方法表       | 方法抛出的异常                                  |
  | EnclosingMethod                       | 类文件       | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |
  | InnerClass                            | 类文件       | 内部类列表                                    |
  | LineNumberTable                       | Code 属性   | Java 源码的行号与字节码指令的对应关系                    |
  | LocalVariableTable                    | Code 属性   | 方法的局部变量描述                                |
  | StackMapTable                         | Code 属性   | JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 |
  | Signature                             | 类，方法表，字段表 | 用于支持泛型情况下的方法签名                           |
  | SourceFile                            | 类文件       | 记录源文件名称                                  |
  | SourceDebugExtension                  | 类文件       | 用于存储额外的调试信息                              |
  | Syothetic                             | 类，方法表，字段表 | 标志方法或字段为编泽器自动生成的                         |
  | LocalVariableTypeTable                | 类         | 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加     |
  | RuntimeVisibleAnnotations             | 类，方法表，字段表 | 为动态注解提供支持                                |
  | RuntimelnvisibleAnnotations           | 类，方法表，字段表 | 用于指明哪些注解是运行时不可见的                         |
  | RuntimeVisibleParameterAnnotation     | 方法表       | 作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法 |
  | RuntirmelnvisibleParameterAnniotation | 方法表       | 作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数 |
  | AnnotationDefauit                     | 方法表       | 用于记录注解类元素的默认值                            |
  | BootstrapMethods                      | 类文件       | 用于保存 invokeddynanic 指令引用的引导方式限定符         |




****



***

## 类与类加载器



### 类加载

类加载方式：

- 隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象
  - 创建类对象、使用类的静态域、创建子类对象、使用子类的静态域
  - 在 JVM 启动时，通过三大类加载器加载 class
- 显式加载：
  - ClassLoader.loadClass(className)：只加载和连接，**不会进行初始化**
  - Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化

命名空间：

- 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成
- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类

基本特征：

- **可见性**，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的
- **单一性**，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载

------



- ​

------



#### 加载模型

- - ​


------



## 虚拟机字节码执行引擎

### 基本介绍

虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上，虚拟机的执行引擎是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系。

执行引擎：Java 虚拟机的核心组成部分之一，类加载主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，需要执行引擎将**字节码指令解释/编译为对应平台上的本地机器指令**，进行执行。

Java 是**半编译半解释型语言**，将解释执行与编译执行二者结合起来进行：

- 解释器：根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行
- 即时编译器（JIT : Just In Time Compiler）：虚拟机运行时将源代码直接编译成**和本地机器平台相关的机器码**后再执行，并存入 Code Cache，下次遇到相同的代码直接执行，效率高

------

### 运行时栈帧结构

Java虚拟机以方法作为最基本执行单元，栈帧（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

#### 执行方式

HotSpot VM 采用**解释器与即时编译器并存的架构**，解释器和即时编译器能够相互协作，去选择最合适的方式来权衡编译本地代码和直接解释执行代码的时间

HostSpot JVM 的默认执行方式：

- 当程序启动后，解释器可以马上发挥作用立即执行，省去编译器编译的时间（解释器存在的**必要性**）
- 随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率

HotSpot VM 可以通过 VM 参数设置程序执行方式：

- -Xint：完全采用解释器模式执行程序
- -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
- -Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-执行引擎工作流程.png)



------



#### 热点探测

热点代码：被 JIT 编译器编译的字节码，根据代码被调用执行的频率而定，一个被多次调用的方法或者一个循环次数较多的循环体都可以被称之为热点代码

热点探测：JIT 编译器在运行时会针热点代码做出深度优化，将其直接编译为对应平台的本地机器指令进行缓存，以提升程序执行性能

JIT 编译在默认情况是异步进行的，当触发某方法或某代码块的优化时，先将其放入编译队列，然后由编译线程进行编译，编译之后的代码放在 CodeCache 中，通过 `-XX:-BackgroundCompilation` 参数可以关闭异步编译

- **CodeCache** 用于缓存编译后的机器码、动态生成的代码和本地方法代码 JNI
- 如果 CodeCache 区域被占满，编译器被停用，字节码将不会编译为机器码，应用程序继续运行，但运行性能会降低很多

HotSpot VM 采用的热点探测方式是基于计数器的热点探测，为每一个方法都建立 2 个不同类型的计数器：方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter）

- 方法调用计数器：用于统计方法被调用的次数，默认阈值在 Client 模式 下是 1500 次，在 Server 模式下是 10000 次（需要进行激进的优化），超过这个阈值，就会触发 JIT 编译，阈值可以通过虚拟机参数 `-XX:CompileThreshold` 设置

  工作流程：当一个方法被调用时， 会先检查该方法是否存在被 JIT 编译过的版本，存在则使用编译后的本地代码来执行；如果不存在则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果超过阈值会向即时编译器**提交一个该方法的代码编译请求**

- 回边计数器：统计一个方法中循环体代码执行的次数，在字节码中控制流向后跳转的指令称为回边

  如果一个方法中的循环体需要执行多次，可以优化为为栈上替换，简称 OSR (On StackReplacement) 编译，**OSR 替换循环代码体的入口，C1、C2 替换的是方法调用的入口**，OSR 编译后会出现方法的整段代码被编译了，但是只有循环体部分才执行编译后的机器码，其他部分仍是解释执行

------



#### 分层编译

HotSpot VM 内嵌两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器

C1 编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度，C1 编译器的优化方法：

- 方法内联：**将调用的函数代码编译到调用点处**，这样可以减少栈帧的生成，减少参数传递以及跳转过程

  方法内联能够消除方法调用的固定开销，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。

  ```java
  private static int square(final int i) {
  	return i * i;
  }
  System.out.println(square(9));
  ```

  square 是热点方法，会进行内联，把方法内代码拷贝粘贴到调用者的位置：

  ```java
  System.out.println(9 * 9);
  ```

  还能够进行常量折叠（constant folding）的优化：

  ```java
  System.out.println(81);
  ```

- 冗余消除：根据运行时状况进行代码折叠或削除

- 内联缓存：是一种加快动态绑定的优化技术（方法调用部分详解）

C2 编译器进行耗时较长的优化以及激进优化，优化的代码执行效率更高，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因

C2 的优化主要是在全局层面，逃逸分析是优化的基础：标量替换、栈上分配、同步消除

VM 参数设置：

- -client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器
- -server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器
- `-server -XX:+TieredCompilation`：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启

分层编译策略 (Tiered Compilation)：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：

- 0 层，解释执行（Interpreter）

- 1 层，使用 C1 即时编译器编译执行（不带 profiling）

- 2 层，使用 C1 即时编译器编译执行（带基本的 profiling）

- 3 层，使用 C1 即时编译器编译执行（带完全的 profiling）

- 4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）

  说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等

参考文章：https://www.jianshu.com/p/20bd2e9b1f03



------



### 方法调用

方法调用并不等于方法执行，方法调用阶段唯一的任务就是**确定被调用方法的版本**，不是方法的具体运行过程。

#### 方法识别

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。

- **方法描述符是由方法的参数类型以及返回类型所构成**，Java 层面叫方法特征签名；
- 在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错；

JVM 根据名字和描述符来判断的，只要返回值不一样（方法描述符不一样），其它完全一样，在 JVM 中是允许的，但 Java 语言不允许。

```java
// 返回值类型不同，编译阶段直接报错
public static Integer invoke(Object... args) {
    return 1;
}
public static int invoke(Object... args) {
    return 2;
}
```



------



#### 调用机制

在 JVM 中，将符号引用转换为直接引用有两种机制：

- 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程称之为静态链接（类加载的解析阶段）
- 动态链接：被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接（初始化后的解析阶段）


- 对应方法的绑定（分配）机制：静态绑定和动态绑定，编译器已经区分了重载的方法（静态绑定和动态绑定），因此可以认为虚拟机中不存在重载

非虚方法：

- 非虚方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的
- 静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法
- 所有普通成员方法、实例方法、被重写的方法都是虚方法

动态类型语言和静态类型语言：

- 在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言

- 静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息

- **Java 是静态类型语言**（尽管 Lambda 表达式为其增加了动态特性），JS，Python 是动态类型语言

  ```java
  String s = "abc";   //Java
  info = "abc";       //Python
  ```

------



#### 调用指令

##### 五种指令

普通调用指令：

- invokestatic：调用静态方法
- invokespecial：调用私有方法、构造器，和父类的实例方法或构造器，以及所实现接口的默认方法
- invokevirtual：调用所有虚方法（虚方法分派）
- invokeinterface：调用接口方法

动态调用指令：

- invokedynamic：动态解析出需要调用的方法
  - Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令
  - Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式

指令对比：

- 普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法
- 动态调用指令支持用户确定方法
- invokestatic 和 invokespecial 指令调用的方法称为非虚方法，虚拟机能够直接识别具体的目标方法
- invokevirtual 和 invokeinterface 指令调用的方法称为虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法

指令说明：

- 如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法
- 普通成员方法是由 invokevirtual 调用，属于**动态绑定**，即支持多态

------



##### 符号引用

在编译过程中，虚拟机并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法，这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符

符号引用存储在方法区常量池中，根据目标方法是否为接口方法，分为接口符号引用和非接口符号引用：

```java
Constant pool:
...
  #16 = InterfaceMethodref #27.#29	// 接口
...
  #22 = Methodref          #1.#33	// 非接口
...
```

对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 C 中查找符合名字及描述符的方法
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果有多个符合条件的目标方法，则任意返回其中一个

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 I 中查找符合名字及描述符的方法
2. 如果没有找到，在 Object 类中的公有实例方法中搜索
3. 如果没有找到，则在 I 的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致

------



##### 执行流程

```java
public class Demo {
    public Demo() { }
    private void test1() { }
    private final void test2() { }

    public void test3() { }
    public static void test4() { }

    public static void main(String[] args) {
        Demo3_9 d = new Demo3_9();
        d.test1();
        d.test2();
        d.test3();
        d.test4();
        Demo.test4();
    }
}
```

几种不同的方法调用对应的字节码指令：

```java
0:  new             #2 // class cn/jvm/t3/bytecode/Demo
3:  dup
4:  invokespecial   #3 // Method "<init>":()V
7:  astore_1
8:  aload_1
9:  invokespecial   #4 // Method test1:()V
12: aload_1
13: invokespecial   #5 // Method test2:()V
16: aload_1
17: invokevirtual   #6 // Method test3:()V
20: aload_1
21: pop
22: invokestatic    #7 // Method test4:()V
25: invokestatic    #7 // Method test4:()V
28: return
```

- invokespecial 调用该对象的构造方法 <init>:()V 
- invokevirtual 调用对象的成员方法
- `d.test4()` 是通过**对象引用**调用一个静态方法，在调用 invokestatic 之前执行了 pop 指令，把对象引用从操作数栈弹掉
  - 不建议使用 `对象.静态方法()` 的方式调用静态方法，多了 aload 和 pop 指令
  - 成员方法与静态方法调用的区别是：执行方法前是否需要对象引用

------



#### 多态原理

##### 执行原理

Java 虚拟机中关于方法重写的判定基于方法描述符，如果子类定义了与父类中非私有、非静态方法同名的方法，只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写

理解多态：

- 多态有编译时多态和运行时多态，即静态绑定和动态绑定
- 前者是通过方法重载实现，后者是通过重写实现（子类覆盖父类方法，虚方法表）
- 虚方法：运行时动态绑定的方法，对比静态绑定的非虚方法调用来说，虚方法调用更加耗时

方法重写的本质：

1. 找到操作数栈的第一个元素**所执行的对象的实际类型**，记作 C
2. 如果在类型 C 中找到与描述符和名称都相符的方法，则进行访问**权限校验**（私有的），如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常
3. 找不到，就会按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程
4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常

------



##### 虚方法表

在虚拟机工作过程中会频繁使用到动态绑定，每次动态绑定的过程中都要重新在类的元数据中搜索合适目标，影响到执行效率。为了提高性能，JVM 采取了一种用**空间换取时间**的策略来实现动态绑定，在每个**类的方法区**建立一个虚方法表（virtual method table），实现使用索引表来代替查找，可以快速定位目标方法

- invokevirtual 所使用的虚方法表（virtual method table，vtable），执行流程
  1. 先通过栈帧中的对象引用找到对象，分析对象头，找到对象的实际 Class
  2. Class 结构中有 vtable，查表得到方法的具体地址，执行方法的字节码
- invokeinterface 所使用的接口方法表（interface method table，itable）

虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕

虚方法表的执行过程：

- 对于静态绑定的方法调用而言，实际引用是一个指向方法的指针
- 对于动态绑定的方法调用而言，实际引用是方法表的索引值，也就是方法的间接地址。Java 虚拟机获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法内存偏移量（指针）

为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表。每个类中都有一个虚方法表，本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法

方法表满足以下的特质：

- 其一，子类方法表中包含父类方法表中的**所有方法**，并且在方法表中的索引值与父类方法表种的索引值相同
- 其二，**非重写的方法指向父类的方法表项，与父类共享一个方法表项，重写的方法指向本身自己的实现**，这就是为什么多态情况下可以访问父类的方法。

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表.png" style="zoom: 80%;" />

Passenger 类的方法表包括两个方法，分别对应 0 号和 1 号。方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致，为了保持简洁，这里不考虑 Object 类中的其他方法。

虚方法表对性能的影响：

- 使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者、读取调用者的动态类型、读取该类型的方法表、读取方法表中某个索引值所对应的目标方法，但是相对于创建并初始化 Java 栈帧这操作的开销可以忽略不计
- 上述优化的效果看上去不错，但实际上**仅存在于解释执行**中，或者即时编译代码的最坏情况。因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）

```java
class Person {
    public String toString() {
        return "I'm a person.";
    }
    public void eat() {}
    public void speak() {}
}

class Boy extends Person {
    public String toString() {
        return "I'm a boy";
    }
    public void speak() {}
    public void fight() {}
}

class Girl extends Person {
    public String toString() {
        return "I'm a girl";
    }
    public void speak() {}
    public void sing() {}
}
```

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表指向.png)



参考文档：https://www.cnblogs.com/kaleidoscope/p/9790766.html



------



##### 内联缓存

内联缓存：是一种加快动态绑定的优化技术，能够缓存虚方法调用中**调用者的动态类型以及该类型所对应的目标方法**。在之后的执行过程中，如果碰到已缓存的类型，便会直接调用该类型所对应的目标方法；反之内联缓存则会退化至使用基于方法表的动态绑定

多态的三个术语：

- 单态 (monomorphic)：指的是仅有一种状态的情况
- 多态 (polymorphic)：指的是有限数量种状态的情况，二态（bimorphic）是多态的其中一种
- 超多态 (megamorphic)：指的是更多种状态的情况，通常用一个具体数值来区分多态和超多态，在这个数值之下，称之为多态，否则称之为超多态

对于内联缓存来说，有对应的单态内联缓存、多态内联缓存：

- 单态内联缓存：只缓存了一种动态类型以及所对应的目标方法，实现简单，比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。
- 多态内联缓存：缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法

为了节省内存空间，**Java 虚拟机只采用单态内联缓存**，没有命中的处理方法：

- 替换单态内联缓存中的纪录，类似于 CPU 中的数据缓存，对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存
- 劣化为超多态状态，这也是 Java 虚拟机的具体实现方式，这种状态实际上放弃了优化的机会，将直接访问方法表来动态绑定目标方法，但是与替换内联缓存纪录相比节省了写缓存的额外开销

虽然内联缓存附带内联二字，但是并没有内联目标方法



参考文章：https://time.geekbang.org/column/intro/100010301

***

## 编译指令

### javac

javac：编译命令，将 java 源文件编译成 class 字节码文件

`javac xx.java` 不会在生成对应的局部变量表等信息，使用 `javac -g xx.java` 可以生成所有相关信息



****



### javap

javap 反编译生成的字节码文件，根据 class 字节码文件，反解析出当前类对应的 code 区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息

用法：javap <options> <classes>

```sh
-help  --help  -?        输出此用法消息
-version                 版本信息
-public                  仅显示公共类和成员
-protected               显示受保护的/公共类和成员
-package                 显示程序包/受保护的/公共类和成员 (默认)
-p  -private             显示所有类和成员
						 #常用的以下三个
-v  -verbose             输出附加信息
-l                       输出行号和本地变量表
-c                       对代码进行反汇编	#反编译

-s                       输出内部类型签名
-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)
-constants               显示最终常量
-classpath <path>        指定查找用户类文件的位置
-cp <path>               指定查找用户类文件的位置
-bootclasspath <path>    覆盖引导类文件的位置
```



***



### 指令集  

##### 执行指令

Java 字节码属于 JVM 基本执行指令。由一个字节长度的代表某种操作的操作码（opcode）以及零至多个代表此操作所需参数的操作数（operand）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码（零地址指令）

由于限制了 Java 虚拟机操作码的长度为一个字节（0~255），所以指令集的操作码总数不可能超过 256 条

在 JVM 的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如 iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据

* i 代表对 int 类型的数据操作
* l 代表 long 
* s 代表 short
* b 代表 byte
* c 代表 char
* f 代表 float
* d 代表 double

大部分的指令都没有支持 byte、char、short、boolean 类型，编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend-）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据

在做值相关操作时:

- 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，也可能是对象的引用）被压入操作数栈
- 一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等等操作


***



##### 加载存储

加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递

局部变量压栈指令：将给定的局部变量表中的数据压入操作数栈

* xload、xload_n，x 表示取值数据类型，为 i、l、f、d、a， n 为 0 到 3
* 指令 xload_n 表示将第 n 个局部变量压入操作数栈，aload_n 表示将一个对象引用压栈
* 指令 xload n 通过指定参数的形式，把局部变量压入操作数栈，局部变量数量超过 4 个时使用这个命令

常量入栈指令：将常数压入操作数栈，根据数据类型和入栈内容的不同，又分为 const、push、ldc 指令

* push：包括 bipush 和 sipush，区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数
* ldc：如果以上指令不能满足需求，可以使用 ldc 指令，接收一个 8 位的参数，该参数指向常量池中的 int、 float 或者 String 的索引，将指定的内容压入堆栈。ldc_w 接收两个 8 位参数，能支持的索引范围更大，如果要压入的元素是 long 或 double 类型的，则使用 ldc2_w 指令
* aconst_null 将 null 对象引用压入栈，iconst_m1 将 int 类型常量 -1 压入栈，iconst_0 将 int 类型常量 0 压入栈

出栈装入局部变量表指令：将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值

* xstore、xstore_n，x 表示取值类型为 i、l、f、d、a， n 为 0 到 3
* xastore 表示存入数组，x 取值为 i、l、f、d、a、b、c、s

扩充局部变量表的访问索引的指令：wide



****



##### 算术指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈

没有直接支持 byte、 short、 char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理，数组类型也是转换成 int 数组

* 加法指令：iadd、ladd、fadd、dadd
* 减法指令：isub、lsub、fsub、dsub
* 乘法指令：imu、lmu、fmul、dmul
* 除法指令：idiv、ldiv、fdiv、ddiv
* 求余指令：irem、lrem、frem、drem（remainder 余数）
* 取反指令：ineg、lneg、fneg、dneg （negation 取反）
* 自增指令：iinc（直接**在局部变量 slot 上进行运算**，不用放入操作数栈）
* 位运算指令，又可分为：
  - 位移指令：ishl、ishr、 iushr、lshl、lshr、 lushr
  - 按位或指令：ior、lor
  - 按位与指令：iand、land
  - 按位异或指令：ixor、lxor

* 比较指令：dcmpg、dcmpl、 fcmpg、fcmpl、lcmp

运算模式：

* 向最接近数舍入模式，JVM 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示形式与该值一样接近，将优先选择最低有效位为零的
* 向零舍入模式：将浮点数转换为整数时，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果

NaN 值：当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义，将使用 NaN 值来表示

```java
double j = i / 0.0;
System.out.println(j);//无穷大，NaN: not a number
```

**分析 i++**：从字节码角度分析：a++ 和 ++a 的区别是先执行 iload 还是先执行 iinc

```java
 4 iload_1		//存入操作数栈
 5 iinc 1 by 1	//自增i++
 8 istore_3		//把操作数栈没有自增的数据的存入局部变量表
 9 iinc 2 by 1	//++i
12 iload_2		//加载到操作数栈
13 istore 4		//存入局部变量表，这个存入没有 _ 符号，_只能到3
```

```java
public class Demo {
    public static void main(String[] args) {
        int a = 10;
        int b = a++ + ++a + a--;
        System.out.println(a);	//11
        System.out.println(b);	//34
    }
}
```

判断结果：

```java
public class Demo {
    public static void main(String[] args) {
        int i = 0;
        int x = 0;
        while (i < 10) {
            x = x++;
            i++;
        }
        System.out.println(x); // 结果是 0
    }
}
```



***



##### 类型转换

类型转换指令可以将两种不同的数值类型进行相互转换，除了 boolean 之外的七种类型

宽化类型转换：

* JVM 支持以下数值的宽化类型转换（widening numeric conversion），小范围类型到大范围类型的安全转换
  * 从 int 类型到 long、float 或者 double 类型，对应的指令为 i2l、i2f、i2d
  * 从 long 类型到 float、 double 类型，对应的指令为 l2f、l2d
  * 从 float 类型到 double 类型，对应的指令为 f2d

* 精度损失问题
  * 宽化类型转换是不会因为超过目标类型最大值而丢失信息
  * 从 int 转换到 float 或者 long 类型转换到 double 时，将可能发生精度丢失

* 从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，JVM 把它们当作 int 处理

窄化类型转换：

* Java 虚拟机直接支持以下窄化类型转换：
  * 从 int 类型至 byte、 short 或者 char 类型，对应的指令有 i2b、i2c、i2s
  * 从 long 类型到 int 类型，对应的指令有 l2i
  * 从 float 类型到 int 或者 long 类型，对应的指令有:f2i、f2l
  * 从 double 类型到 int、long 或 float 者类型，对应的指令有 d2i、d2、d2f

* 精度损失问题：
  * 窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，转换过程可能会导致数值丢失精度
  * 将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）时，将遵循以下转换规则：
    - 如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0
    - 如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T 的表示范围之内，那转换结果就是 v，否则将根据 v 的符号，转换为 T 所能表示的最大或者最小正数


***



##### 创建访问

创建指令：

* 创建类实例指令：new，接收一个操作数指向常量池的索引，表示要创建的类型，执行完成后将对象的引用压入栈

  ```java
  0:  new             #2 // class com/jvm/bytecode/Demo
  3:  dup
  4:  invokespecial   #3 // Method "<init>":()V
  ```

  **dup 是复制操作数栈栈顶的内容**，需要两份引用原因：

  - 一个要配合 invokespecial 调用该对象的构造方法 <init>:()V （会消耗掉栈顶一个引用）
  - 一个要配合 astore_1 赋值给局部变量

* 创建数组的指令：newarray、anewarray、multianewarray

  * newarray：创建基本类型数组
  * anewarray：创建引用类型数组
  * multianewarray：创建多维数组

字段访问指令：对象创建后可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素

* 访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic
* 访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield

类型检查指令：检查类实例或数组类型的指令

* checkcast：用于检查类型强制转换是否可以进行，如果可以进行 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常

* instanceof：判断给定对象是否是某一个类的实例，会将判断结果压入操作数栈




****



##### 方法指令

方法调用指令：invokevirtual、 invokeinterface、invokespecial、invokestatic、invokedynamic

**方法调用章节详解**



***



##### 操作数栈

JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令

* pop、pop2：将一个或两个元素从栈顶弹出，并且直接废弃
* dup、dup2，dup_x1、dup2_x1，dup_x2、dup2_x2：复制栈顶一个或两个数值并重新压入栈顶

* swap：将栈最顶端的两个 slot 数值位置交换，JVM 没有提供交换两个 64 位数据类型数值的指令

* nop：一个非常特殊的指令，字节码为 0x00，和汇编语言中的 nop 一样，表示什么都不做，一般可用于调试、占位等


***



##### 控制转移


比较指令：比较栈顶两个元素的大小，并将比较结果入栈

* lcmp：比较两个 long 类型值
* fcmpl：比较两个 float 类型值（当遇到NaN时，返回-1）
* fcmpg：比较两个 float 类型值（当遇到NaN时，返回1）
* dcmpl：比较两个 double 类型值（当遇到NaN时，返回-1）
* dcmpg：比较两个 double 类型值（当遇到NaN时，返回1）

条件跳转指令：

| 指令        | 说明                                  |
| --------- | ----------------------------------- |
| ifeq      | equals，当栈顶int类型数值等于0时跳转             |
| ifne      | not equals，当栈顶in类型数值不等于0时跳转         |
| iflt      | lower than，当栈顶in类型数值小于0时跳转          |
| ifle      | lower or equals，当栈顶in类型数值小于等于0时跳转   |
| ifgt      | greater than，当栈顶int类型数组大于0时跳转       |
| ifge      | greater or equals，当栈顶in类型数值大于等于0时跳转 |
| ifnull    | 为 null 时跳转                          |
| ifnonnull | 不为 null 时跳转                         |

比较条件跳转指令：

| 指令        | 说明                              |
| --------- | ------------------------------- |
| if_icmpeq | 比较栈顶两 int 类型数值大小（下同），当前者等于后者时跳转 |
| if_icmpne | 当前者不等于后者时跳转                     |
| if_icmplt | 当前者小于后者时跳转                      |
| if_icmple | 当前者小于等于后者时跳转                    |
| if_icmpgt | 当前者大于后者时跳转                      |
| if_icmpge | 当前者大于等于后者时跳转                    |
| if_acmpeq | 当结果相等时跳转                        |
| if_acmpne | 当结果不相等时跳转                       |

多条件分支跳转指令：

* tableswitch：用于 switch 条件跳转，case 值连续
* lookupswitch：用于 switch 条件跳转，case 值不连续

无条件跳转指令：

* goto：用来进行跳转到指定行号的字节码

* goto_w：无条件跳转（宽索引）




***



##### 异常处理

###### 处理机制

抛出异常指令：athrow 指令

JVM 处理异常（catch 语句）不是由字节码指令来实现的，而是**采用异常表来完成**的

* 代码：

  ```java
  public static void main(String[] args) {    
      int i = 0;    
      try {    	
          i = 10;    
      } catch (Exception e) {   
          i = 20;   
      } finally {
          i = 30;
      }
  }
  ```

* 字节码：

  * 多出一个 **Exception table** 的结构，**[from, to) 是前闭后开的检测范围**，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号
  * 11 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置，因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用

  ```java
      0: 	iconst_0
      1: 	istore_1 	// 0 -> i	->赋值
      2: 	bipush 10 	// try 10 放入操作数栈顶
      4: 	istore_1 	// 10 -> i 将操作数栈顶数据弹出，存入局部变量表的 slot1
      5: 	bipush 30 	// 【finally】 
      7: 	istore_1 	// 30 -> i 
      8: 	goto 27 	// return -----------------------------------
      11: astore_2 	// catch Exceptin -> e ----------------------
      12: bipush 20 	// 
      14: istore_1 	// 20 -> i 
      15: bipush 30 	// 【finally】 
      17: istore_1 	// 30 -> i 
      18: goto 27 	// return -----------------------------------
      21: astore_3 	// catch any -> slot 3 ----------------------
      22: bipush 30 	// 【finally】
      24: istore_1 	// 30 -> i 
      25: aload_3 	// 将局部变量表的slot 3数据弹出，放入操作数栈栈顶
      26: athrow 		// throw 抛出异常
      27: return
  Exception table:
  	// 任何阶段出现任务异常都会执行 finally
  	from   to 	target 	type
  		2	5 		11 	Class java/lang/Exception
  		2 	5 		21 	any // 剩余的异常类型，比如 Error
  		11 15 		21 	any // 剩余的异常类型，比如 Error
  LineNumberTable: ...
  LocalVariableTable:
  	Start Length Slot Name Signature
  	12 		3 		2 	e 	Ljava/lang/Exception;
  	0 		28 		0 args 	[Ljava/lang/String;
  	2 		26 		1 	i 	I
  ```


***



###### finally

finally 中的代码被**复制了 3 份**，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程（上节案例）

* 代码：

  ```java
  public static int test() {
      try {
      	return 10;
      } finally {
      	return 20;
      }
  }
  ```

* 字节码：

  ```java
      0: bipush 10 	// 10 放入栈顶
      2: istore_0 	// 10 -> slot 0 【从栈顶移除了】
      3: bipush 20 	// 20 放入栈顶
      5: ireturn 		// 返回栈顶 int(20)
      6: astore_1 	// catch any 存入局部变量表的 slot1
      7: bipush 20 	// 20 放入栈顶
      9: ireturn 		// 返回栈顶 int(20)
  Exception table:
  	from   to 	target 	type
  		0	3		6 	any      
  ```


***



###### return

* 吞异常

  ```java
  public static int test() {
      try {
      	return 10;
      } finally {
      	return 20;
      }
  }
  ```

  ```java
      0: bipush 10 	// 10 放入栈顶
      2: istore_0 	// 10 -> slot 0 【从栈顶移除了】
      3: bipush 20 	// 20 放入栈顶
      5: ireturn 		// 返回栈顶 int(20)
      6: astore_1 	// catch any  存入局部变量表的 slot1
      7: bipush 20 	// 20 放入栈顶
      9: ireturn 		// 返回栈顶 int(20)
  Exception table:
  	from   to 	target 	type
  		0	3		6 	any      
  ```

  * 由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果以 finally 的为准
  * 字节码中没有 **athrow** ，表明如果在 finally 中出现了 return，会**吞掉异常**

* 不吞异常

  ```java
  public class Demo {
      public static void main(String[] args) {
      	int result = test();
      	System.out.println(result);//10
  	}
  	public static int test() {
          int i = 10;
          try {
              return i;//返回10
          } finally {
              i = 20;
          }
     	}
  }
  ```

  ```java
      0: 	bipush 10 	// 10 放入栈顶
      2: 	istore_0 	// 10 赋值给i，放入slot 0
      3: 	iload_0 	// i(10)加载至操作数栈
      4: 	istore_1 	// 10 -> slot 1，【暂存至 slot 1，目的是为了固定返回值】
      5: 	bipush 20 	// 20 放入栈顶
      7: 	istore_0 	// 20 slot 0
      8: 	iload_1 	// slot 1(10) 载入 slot 1 暂存的值
      9: 	ireturn 	// 返回栈顶的 int(10)
      10: astore_2	// catch any -> slot 2 存入局部变量表的 slot2
      11: bipush 20
      13: istore_0
      14: aload_2
      15: athrow		// 不会吞掉异常
  Exception table:
  	from   to 	target 	type
  	  3	   5		10 	any  
  ```


***



##### 同步控制

方法级的同步：是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法

方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义

* montiorenter：进入并获取对象监视器，即为栈顶对象加锁
* monitorexit：释放并退出对象监视器，即为栈顶对象解锁

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码指令同步控制.png" style="zoom: 33%;" />





***



#### 执行流程

原始 Java 代码：

```java
public class Demo {	
    public static void main(String[] args) {        
        int a = 10;        
        int b = Short.MAX_VALUE + 1;        
        int c = a + b;        
        System.out.println(c);	
    }
}
```

javap -v Demo.class：省略

* 常量池载入运行时常量池

* 方法区字节码载入方法区

* main 线程开始运行，分配栈帧内存：（操作数栈stack=2，局部变量表locals=4）

* **执行引擎**开始执行字节码

  `bipush 10`：将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令

  * sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）
  * ldc 将一个 int 压入操作数栈
  * ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）
  * 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池

  `istore_1`：将操作数栈顶数据弹出，存入局部变量表的 slot 1

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程1.png)

  `ldc #3`：从常量池加载 #3 数据到操作数栈
  Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算完成

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程2.png)

  `istore_2`：将操作数栈顶数据弹出，存入局部变量表的 slot 2

  `iload_1`：将局部变量表的 slot 1 数据弹出，放入操作数栈栈顶

  `iload_2`：将局部变量表的 slot 2 数据弹出，放入操作数栈栈顶

  `iadd`：执行相加操作

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程3.png)

  `istore_3`：将操作数栈顶数据弹出，存入局部变量表的 slot 3

  `getstatic #4`：获取静态字段

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程4.png)

  `iload_3`：

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程5.png)

  `invokevirtual #5`：

  * 找到常量池 #5 项
  * 定位到方法区 java/io/PrintStream.println:(I)V 方法
  * **生成新的栈帧**（分配 locals、stack等）
  * 传递参数，执行新栈帧中的字节码
  * 执行完毕，弹出栈帧
  * 清除 main 操作数栈内容

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程6.png)

  return：完成 main 方法调用，弹出 main 栈帧，程序结束




***







***



### 代码优化

#### 语法糖

语法糖：指 Java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担



#### 构造器

```java
public class Candy1 {
}
```

```java
public class Candy1 {
    // 这个无参构造是编译器帮助我们加上的
    public Candy1() {
        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."
        <init>":()V
    }
}
```



***



#### 拆装箱

```java
Integer x = 1;
int y = x;
```

这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段2：

```java
Integer x = Integer.valueOf(1);
int y = x.intValue();
```

JDK5 以后编译阶段自动转换成上述片段



***



#### 泛型擦除

泛型也是在 JDK 5 开始加入的特性，但 Java 在编译泛型代码后会执行**泛型擦除**的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都**当做了 Object 类型**来处理：

```java
List<Integer> list = new ArrayList<>();
list.add(10); // 实际调用的是 List.add(Object e)
Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);
```

编译器真正生成的字节码中，还要额外做一个类型转换的操作：

```java
// 需要将 Object 转为 Integer
Integer x = (Integer)list.get(0);
```

如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：

```java
// 需要将 Object 转为 Integer, 并执行拆箱操作
int x = ((Integer)list.get(0)).intValue();
```



***



#### 可变参数

```java
public class Candy4 {
    public static void foo(String... args) {
        String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
    	foo("hello", "world");
    }
}
```

可变参数 `String... args` 其实是 `String[] args` ， Java 编译器会在编译期间将上述代码变换为：

```java
public static void main(String[] args) {
	foo(new String[]{"hello", "world"});
}
```

注意：如果调用了 `foo()` 则等价代码为 `foo(new String[]{})` ，创建了一个空的数组，而不会传递 null 进去



****



#### foreach

数组的循环：

```java
int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖
for (int e : array) {
	System.out.println(e);
}
```

编译后为循环取数：

```java
for(int i = 0; i < array.length; ++i) {
	int e = array[i];
	System.out.println(e);
}
```

集合的循环：

```java
List<Integer> list = Arrays.asList(1,2,3,4,5);
for (Integer i : list) {
	System.out.println(i);
}
```

编译后转换为对迭代器的调用：

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Iterator iter = list.iterator();
while(iter.hasNext()) {
    Integer e = (Integer)iter.next();
    System.out.println(e);
}
```

注意：foreach 循环写法，能够配合数组以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器



***



#### switch

##### 字符串

switch 可以作用于字符串和枚举类：

```java
switch (str) {
    case "hello": {
        System.out.println("h");
        break;
    }
    case "world": {
        System.out.println("w");
        break;
    }
}
```

注意：**switch 配合 String 和枚举使用时，变量不能为 null**

会被编译器转换为：

```java
byte x = -1;
switch(str.hashCode()) {
    case 99162322: // hello 的 hashCode
        if (str.equals("hello")) {
        	x = 0;
        }
    	break;
    case 113318802: // world 的 hashCode
        if (str.equals("world")) {
        	x = 1;
        }
}
switch(x) {
    case 0:
    	System.out.println("h");
    	break;
    case 1:
    	System.out.println("w");
        break;
}
```

总结：

* 执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较
* hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突


***



##### 枚举

switch 枚举的例子，原始代码：

```java
enum Sex {
	MALE, FEMALE
}
public class Candy7 {
    public static void foo(Sex sex) {
        switch (sex) {
            case MALE:
                System.out.println("男"); 
                break;
            case FEMALE:
                System.out.println("女"); 
                break;
        }
	}
}
```

编译转换后的代码：

```java
/**
* 定义一个合成类（仅 jvm 使用，对我们不可见）
* 用来映射枚举的 ordinal 与数组元素的关系
* 枚举的 ordinal 表示枚举对象的序号，从 0 开始
* 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1
*/
static class $MAP {
    // 数组大小即为枚举元素个数，里面存储 case 用来对比的数字
    static int[] map = new int[2];
    static {
    	map[Sex.MALE.ordinal()] = 1;
    	map[Sex.FEMALE.ordinal()] = 2;
	}
}
public static void foo(Sex sex) {
    int x = $MAP.map[sex.ordinal()];
    switch (x) {
        case 1:
        	System.out.println("男");
        	break;
        case 2:
        	System.out.println("女");
        	break;
    }
}
```



***



#### 枚举类

JDK 7 新增了枚举类：

```java
enum Sex {
	MALE, FEMALE
}
```

编译转换后：

```java
public final class Sex extends Enum<Sex> {
    public static final Sex MALE;
    public static final Sex FEMALE;
    private static final Sex[] $VALUES;
    static {
        MALE = new Sex("MALE", 0);
        FEMALE = new Sex("FEMALE", 1);
        $VALUES = new Sex[]{MALE, FEMALE};
    }
    private Sex(String name, int ordinal) {
    	super(name, ordinal);
    }
    public static Sex[] values() {
    	return $VALUES.clone();
    }
    public static Sex valueOf(String name) {
    	return Enum.valueOf(Sex.class, name);
    }
}
```





***



#### try-w-r

JDK 7 开始新增了对需要关闭的资源处理的特殊语法 `try-with-resources`，格式：

```java
try(资源变量 = 创建资源对象){
} catch( ) {
}
```

其中资源对象需要实现 **AutoCloseable** 接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources可以不用写 finally 语句块，编译器会帮助生成关闭资源代码：

```java
try(InputStream is = new FileInputStream("d:\\1.txt")) {
	System.out.println(is);
} catch (IOException e) {
	e.printStackTrace();
}
```

转换成：

`addSuppressed(Throwable e)`：添加被压制异常，是为了防止异常信息的丢失（**fianlly 中如果抛出了异常**）

```java
try {
    InputStream is = new FileInputStream("d:\\1.txt");
    Throwable t = null;
    try {
    	System.out.println(is);
    } catch (Throwable e1) {
    	// t 是我们代码出现的异常
    	t = e1;
    	throw e1;
    } finally {
        // 判断了资源不为空
        if (is != null) {
            // 如果我们代码有异常
            if (t != null) {
                try {
                	is.close();
                } catch (Throwable e2) {
                    // 如果 close 出现异常，作为被压制异常添加
                    t.addSuppressed(e2);
                }
            } else {
                // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                is.close();
            }
		}
	}
} catch (IOException e) {
    e.printStackTrace();
}
```