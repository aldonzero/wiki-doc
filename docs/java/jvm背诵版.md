## JVM

### JVM内存模型

JVM的内存模型主要有方法区、堆、栈、程序计数器本地方法栈等。

- Java 虚拟机栈：Java Virtual Machine Stacks，**每个线程**运行时所需要的内存，每个方法都会在虚拟机栈中创建一个栈帧 stack frame（**一个方法一个栈帧**）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
- 本地方法栈是为虚拟机执行本地方法时提供服务的。
- 程序计数器内部保存字节码的行号，用于记录正在执行的字节码指令地址（如果正在执行的是本地方法（Native）则为空）。
- Heap 堆：是 JVM 内存中最大的一块，由所有**线程共享**，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题。堆中主要存放**对象实例**、**字符串常量池（String Table）**、**静态变量**、**TLAB** 。
- 方法区：是各个**线程共享**的内存区域，用于存储已被虚拟机加载的**类信息**、**常量**、**即时编译器编译后的代码**等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）。

### 类加载机制（类生命周期）

在JVM中，类加载主要包括加载、链接（准备、验证、解析）、初始化、使用、卸载几个阶段。其中，

- 准备阶段主要是通过类的全限名称，获取该类的二进制字节码，加载到内存中，并将表示该类的静态存储结构转换为运行时存储结构，在方法区中生成一个类模板对象在，堆中生成一个Class对象，作为程序访问方法区中类型数据的外部接口；
- 连接阶段主要是检验class文件是否符合JVM规范，确保文件不会对JVM造成危害；
- 初始化阶段根据程序初始化类变量和其他资源。

### 什么是双亲委派？好处？

如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

双亲委派机制的优点：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性。

双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但**顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类**（可见性）。

### OOM是什么？如何排查？

OOM就是内存空间用完了，垃圾回收器也没有垃圾对象回收释放空间。

除了程序计数器外，其他内存区域都有OOM的风险。

- 栈一般会发生`StackOverflowException`，如，32位的Windows系统单进程限制2G，无限制创建进程会发生栈的OOM；
- Java8常量池移到堆中，溢出会发生`java.lang.OutOfMemoryError:Java heap space`，设置最大元空间大小参数无效；
- 堆内存溢出，也会发生`java.lang.OutOfMemoryError:Java heap space`，是GC之后无法在堆内存空间中申请内存创建对象；
- 方法区OOM，经常会动态生成大量的类、jsp等；
- 直接内存OOM，涉及到`-XX:MaxDirectMemorySize`参数和`Unsafe`对象对内存的申请。

排查OOM的方法：

- 配置参数`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof`，当OOM时会自动dump堆内存信息到指定目录；
- `jstat`查看监控的JVM内存和GC情况，先观察大概出现在什么区域；
- 使用MAT工具加入dump文件，分析大对象占用情况，比如HashMap做缓存未清理，时间长了就会内存溢出，可以改为弱引用。

### 如何判断一个对象是否存活？

判断对象是否存活的方式一般有两种：引用计数法和可达性分析算法。

- 引用计数法：对每个对象保存一个整形的引用计数器，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用，无法解决循环引用问题，会引发内存泄漏）。
- 可达性分析：以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象，内存中的存活对象都会被根对象集合直接或间接连接着；如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。

### 可达性算法不可达的对象就一定会死亡，会被回收吗？

不一定。

在可达性算法中不可达的对象也不一定是非死不可的，这时候它们暂时处于“缓刑”阶段，要真正宣告它的死亡还需要经历**两次的标记阶段**。

第一次标记：
在对象可达性算法不可达时，进行第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象**没有重写finalize()方法**或者**该方法被虚拟机调用过**，虚拟机将这两种情况视为“没有必要去执行”。

如果该对象被判定为**有必要执行finalize()方法**，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行它。这里所谓的执行就是去触发该方法，但是并不会承诺等待它执行结束，这样做的原因是，如果对象在finalize()方法中执行缓慢，或者发生死循环，将会导致整个队列中的对象处于等待之中。

第二次标记：
finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己——**只要重新与引用链上的一个对象重新建立关联即可**，譬如将自己（this关键字）赋值给某个类变量或者成员变量，那么在第二次标记的时候就会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么就会被真的回收了！

### 强引用、软引用、弱引用、虚引用是什么？有什么区别？

- 强引用：被强引用关联的对象**不会被回收**，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收；使用new关键字创建的对象都是强引用。
- 软引用：被软引用关联的对象只有在**内存不够**的情况下才会被回收；使用`SoftReference`来标记软引用。
- 弱引用：被弱引用关联的对象**一定会被回收**，只能存活到**下一次垃圾回收**发生之前；使用`WeakReference`来标记弱引用。
- 虚引用：是所有引用类型中最弱的一个，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象，为对象设置虚引用的唯一目的是在于**跟踪垃圾回收**过程，能在这个对象被**回收时**收到一个**系统通知** ；使用`PhantomReference`来标记虚引用。

### 垃圾回收算法有哪些？

基本的垃圾收集算法有三种：标记-清除、标记-整理和复制算法。

- 标记-清除算法：
  - 标记阶段：从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，**标记的是引用的对象，不是垃圾** ；
  - 清除阶段：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到**空闲列表**的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块；
- 标记-整理（压缩）：标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是**将存活对象都向内存另一端移动**，然后清理边界以外的垃圾，从而**解决了碎片化**的问题。
- 复制算法：**将原有的内存空间一分为二，每次只用其中的一块**，利用根可达分析算法，判断该对象是否是可用对象（非垃圾对象），如果可用则移动到空闲survivor区间，当所有对象遍历完成后，清空当前区间，并标记为下一次垃圾回收的空闲survivor区间。

### 有哪几种垃圾回收器，各自的优缺点是什么？

垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；

- Serial:单线程的收集器，收集垃圾时，必须stop the world，使用标记-复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。
- ParNew:Serial收集器的多线程版本，也需要stop the world，标记-复制算法。
- Parallel Scavenge:新生代收集器，使用标记-复制算法，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；
- Serial Old:Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
- Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；
- G1:标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；
- CMS：

### Minor GC 和 Full GC有什么不同？

Minor GC：回收新生代，新生代对象存活时间很短，所以Minor GC会频繁执行，执行的速度比较快；当Eden区要满时执行YoungGC（即Minor GC）。

Full GC：回收老年代和新生代，老年代对象存活时间长，所以Full GC很少执行，执行速度会比Minor GC慢得多；当老年代空间不足或空间分配担保时会触发Full GC。

### 什么时空间担保机制？

当Eden区满时会触发Young GC，当Young GC后Eden区中存活的对象会移动到survivor区，而如果survivor区放不下了，就必须转移到老年代中，但这时如果老年代也放不下这些对象，就需要老年代空间担保机制来保证对象能进入老年代。

1. 在YoungGC之前，会判断老年代可用空间是否大于新生代存活对象的大小，如果大于则可以直接进行Young GC；如果小于则检查是否允许空间担保；
2. 检查`-XX:HandlePromotionFilure`是否允许担保失败，如果不允许，则直接Full GC；如果允许则判断老年代可用空间是否大于历次晋升到老年代对象的平均大小，如果是则尝试Young GC；如果不是则直接Full GC；
3. 担保后的Young GC的结果可能是：
   - Young GC后存活的对象小于survivor区间，则直接将存活对象移动到survivor区间；
   - 存活对象大于survivor区间，小于老年代可用空间，则存活对象晋升到老年代；
   - 如过存活对象大于老年代可用空间，则触发Full GC同时进行一次Young GC;
4. 如果Full GC后空间仍然不够，则OOM内存溢出。

### 如何优化 JVM 频繁 minor GC

### JVM 内存是如何对应到操作系统内存的？

### JVM怎么去调优？了解哪些参数和指令？

- `jps`: JVM Porcess Status Tool，显示指定系统内所有的HotSpot虚拟机进程;

- `jstat`：JVM statistic monitoring，用于监视虚拟机运行时状态信息的指令，可以显示虚拟机进程的类装载、内存、垃圾收集、JIT编译等运行数据；

- `jmap`：JVM Memory Map，用于生成heap dump文件，如果不使用这个命令，还可以使用`-XX:+HeapDumpOnOutOfMemoryError`参数让虚拟机在出现OOM时自动生成dump文件。

  jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前的使用率、当前使用的哪种收集器等。

- `jhat`：JVM Heap Analysis Tool，与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的Http/HTML服务器，生成dump的分析结果后可以在浏览器中查看，因为jhat分析是一个非常耗时并且耗费硬件资源的过程，因此一般把生成的dump文件复制到本地或者其他机器上进行分析。

- `jstack`：用于生成Java虚拟机当前时刻线程的快照。jstack查看各个线程的调用堆栈，可以知道没有响应的线程在等待什么资源。如果Java程序崩溃生成core文件，jstack工具可以用来获得core文件的Java stack和native stack信息，从而知道Java程序是如何崩溃的和在程序何处发生问题。

### Java逃逸分析机制

### class文件内容

