## JVM

### JVM内存模型

JVM内存结构又叫**运行时数据区**，其中包括线程共享的区域：**方法区（常量池）**、**堆**，以及线程私有的区域：**虚拟机栈**、**本地方法栈**、**程序计数器**。

### 方法区

jdk1.8之后，方法区变成了**元空间**，放在直接内存中，存储**CodeCache（即时编译代码）**、**运行时常量池**、**class文件本身（类元信息、属性方法、常量等）**；**静态变量**和**字符串常量池**放在堆中。

### 程序计数器

Program Counter Register 程序计数器，当前线程所执行的字节码的行号指示器，通过改变改变计数器的值来选取下一条要执行的字节码指令。

**两个作用：**

1. **字节码解释**器通过改变程序计数器来**依次读取指令**，从而实现代码的**流程控制**，如：**顺序执行**、**选择**、**循环**、**异常处理**。
2. 在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

### 虚拟机栈

Java 虚拟机栈：是**每个线程**运行时所需要的内存，每个方法被执行时，都会在虚拟机栈中创建一个**栈帧** （**一个方法一个栈帧**）用于存储**局部变量表**、**操作数栈**、**动态连接**、**方法出口**等信息。

Java 虚拟机规范允许 **Java 栈的大小是动态的或者是固定不变的**，但是**栈帧过多导致栈内存溢出** （超过了栈的容量），会抛出 **OutOfMemoryError** 异常；当**线程请求的栈深度**超过最大值，会抛出 **StackOverflowError** 异常。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务**。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

### 堆

JVM 内存中最大的一块，由所有**线程共享**，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题。

堆中主要存放**对象实例**、**字符串常量池（String Table）**、**静态变量**、**TLAB** ，几乎所有的对象实例以及数组都在这里分配内存。

堆空间大致可以分为**新生代**和**老年代**，再细致一点，可以分为**Eden空间**、F**rom Survivor**、**To Survivor**空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

### 为什么要将永久代 (PermGen) 的实现从方法区替换为元空间 (MetaSpace) 呢?

因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

因为永久代有一个 **JVM 本身设置固定大小上限**，无法进行调整，而元空间使用的是**直接内存**，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。

你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 设置元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

###  JVM 的类的成员变量放在哪？

jdk1.8的成员变量放堆里，包括**基础变量**、**引用指向的对象**、**静态变量**、**常量**。

jdk1.7之前方法区会存储静态变量和常量。

### 运行时常量池

**运行时常量池**是方法区的一部分，用于存放**编译期生成**的各种**字面量**和**符号引用**。
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

字面量包括：**文本字符串**、**被声明为final的常量值**、**基本数据类型的值**等

符号引用：**类和结构的完全限定名**、**字段名称和描述符**、**方法名称和描述符**。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是**这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

### Minor GC 和 Full GC、Full GC 的触发条件

● Minor GC：回收新生代，**因为新生代对象存活时间很短，因此 Minor GC 会频繁执行**，执行的速度一般也会比较快。
 ● Full GC：回收**老年代和新生代**，**老年代对象存活时间长，因此 Full GC 很少执行**，执行速度会比 Minor GC 慢很多

### 调用 System.gc()

只是**建议**虚拟机执行 Full GC，但是**虚拟机不一定真正去执行**。**不建议**使用这种方式，而是让虚拟机管理内存。

### 老年代空间不足

老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。
为了避免以上原因引起的 Full GC，应当**尽量不要创建过大的对象以及数组**。除此之外，可以**通过-Xmn 虚拟机参数调大新生代的大小**，让对象尽量在新生代被回收掉，不进入老年代。还可以**通过-XX:MaxTenuringThreshold 调大对象进入老年代的年龄**，让对象在新生代多存活一段时间。

### 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果**担保失败会执行一次 Full GC**

#### JDK1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 **Class 的信息**、**常量**、**静态变量**等数据。
当系统中要加载的**类、反射的类和调用**的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出java.lang.OutOfMemoryError。
为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### Concurrent mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中**浮动垃圾**过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

### 对象优先在 Eden 区分配

大多数情况下，对象在新生代 Eden 上分配，**当 Eden 空间不够时，发起 Minor GC**。
首先新对象建立会放到 Eden 区里边，在第一次 GC 的时候会把 Eden 区里边的存活对象复制到 From Survivor 里边，这时 To Survivor 区是空的，然后清空 Eden 区里边的”朝生熄灭”对象，接着 From Survivor 区和 To Survivor 区进行轮转，有新对象进来是进到 Eden 区里边，满了以后进行 Minor GC，
**Eden 区里边还存活着的对象就放到 To Survivor 区里边，而 From Survivor 区还存存活着的对象年龄+1 进入到老年代或者复制到 To Survivor 区**。依次循环，这样轮转做的好处是：避免清空掉无用的对象后，在内存区域中生成**不连续的内存空间**。

### 2.3 大对象直接进入老年代

大对象是指**需要大量连续内存空间的对象**，最典型的大对象是那种**很长的字符串**以及**数组**。
**经常出现大对象**会提前**触发垃圾收集**以获取**足够的连续空间**分配给大对象。
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，**避免在 Eden 和 Survivor 之间的大量内存复制**。



### 2.4 长期存活对象进入老年代

**为对象定义年龄计数器**，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，**增加到一定年龄则移动到老年代中**。-XX:MaxTenuringThreshold 用来定义年龄的阈值。



### 2.5 动态对象的年龄判定

虚拟机**并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代**，如果在Survivor 中相同年龄所有对象大小的总和**大于 Survivor 空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老年代。



### 2.6 空间分配担保（Minor GC 的安全与否）

在发生 Minor GC 之前，虚拟机先检查**老年代最大可用的连续空间**是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话，虚拟机会查看 **HandlePromotionFailure** 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于**历次晋升到老年代对象的平均大小**，如果大于，将尝试着进行一次 Minor GC；

如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

### 类加载机制（类生命周期）

在JVM中，类加载主要包括加载、链接（准备、验证、解析）、初始化、使用、卸载几个阶段。其中，

- 准备阶段主要是通过类的全限名称，获取该类的二进制字节码，加载到内存中，并将表示该类的静态存储结构转换为运行时存储结构，在方法区中生成一个类模板对象在，堆中生成一个Class对象，作为程序访问方法区中类型数据的外部接口；
- 连接阶段主要是检验class文件是否符合JVM规范，确保文件不会对JVM造成危害；
- 初始化阶段根据程序初始化类变量和其他资源。

### 什么是双亲委派？好处？

如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

双亲委派机制的优点：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性。

双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但**顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类**（可见性）。

### 4.1 虚拟机垃圾收集算法（4 种）

#### 4.1.1 标记-清除算法

在**标记阶段**，会对可回收对象进行标记；

在清除阶段，对标记的对象进行清除，**并取消标记**。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，则合并这两个分块。

回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后对新对象进行分配时只需要遍历这个空闲链表，就可以找到分块。

**缺点：**标记和清除过程效率不高；会产生大量**内存碎片**，导致无法给大对象分配内存空间。



#### 4.1.2 复制算法

将内存划分为大小相等的两块，每次**只使用其中一块**，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再**把使用过的内存空间进行一次清理**。

**主要缺点：**只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是**一块较大的 Eden 空间和两块较小的 Survivor 空间**，**每次使用 Eden 和其中一块 Survivor**。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 **Eden 和 Survivor 大小比例默认为 8:1**，保证了内存的利用率达到 90%。**如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。**



#### 4.1.3 标记-整理算法

标记阶段：标记可回收对象；整理阶段：**让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。**
优点：不会产生内存碎片
不足：**需要移动大量对象**，处理效率比较低。

#### 4.1.4 分代收集算法

现在的商业虚拟机采用分代收集算法，它**根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。**
一般将堆分为新生代和老年代。
新生代使用：**复制算法**
老年代使用：**标记-清除 或者 标记-整理算法**



### 4.2 判断一个对象是否可被回收

#### 4.2.1 引用计数法（仅做了解）对吞吐量要求很高的系统

为对象添加一个**引用计数器**，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
在两个对象出现**循环引用**的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

#### 4.2.2 可达性分析算法

**以 GC Roots 为起始点**进行搜索，可达的对象都是存活的，不可达的对象可被回收

Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：
● **虚拟机栈中局部变量表中引用**的对象 --> 方法里边的局部变量
● **本地方法栈中 JNI 引用**的对象
● **方法区中类静态属性引用**的对象 --> 类的静态变量
● **方法区中常量引用**的对象 --> 类的常量
总的来说：**类的静态变量，常量，方法里边的局部变量所指向的对象**可作为 GC Roots。成员变量所指向的对象不可作为 GCRoots。

**为什么成员变量不能作为 GCRoots？**
因为成员变量的生命周期随着对象的消失而消失，是不可达的，所以能够被回收。



### 4.2.3 方法区回收

### 4.2.4 finalize()

### 4.3 引用类型

#### 4.3.1 强引用

**被强引用关联**的对象不会被回收。
使用 **new 一个新对象**的方式来创建强引用。

#### 4.3.2 软引用 SoftReference

被软引用关联的对象**只有在内存不够**的情况下才会被回收。

#### 4.3.3 弱引用 WeakReference

被弱引用关联的对象**一定会被回收**，也就是说它**只能存活到下一次垃圾回收发生之前**。

#### 4.3.4 虚引用 PhantomReference

又称为幽灵引用或者幻影引用，**一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象**。

为一个对象设置虚引用的唯一目的是能**在这个对象被回收时收到一个系统通知。**

**垃圾收集器（7 个，主要说出是单线程/多线程，串行/并行，用途，配合哪个收集器使用）**

#### 5.6 CMS 收集器

CMS（Concurrent Mark Sweep），Mark Sweep 指的是**标记 - 清除算法**。
主要分为以下四个流程：

- 初始标记：使用 **STW** 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快(**单线程串行**)
- 并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行（**单线程串行**）
- 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）（**多线程串行**）
- 并发清除：清除标记为可以回收对象，**不需要移动存活对象**，所以这个阶段可以与用户线程同时并发的（**单线程并发**）

> 并发标记是单线程串行？
>
> 并发清除是单线程并发？
>
> 线程上下文切换需要时间，而初始标记只是标记GC Roots的直接关联对象，时间很短；而重新标记是对标记产生变动的对象标记更新，需要的时间比初始标记长，因此上下文切换时间是可以接受的

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 G1 收集器的筛选回收最好是停顿的并且是并发回收。

具有以下缺点：
● 吞吐量低：**低停顿**时间是以牺牲吞吐量为代价的，导致 **CPU 利用率不够高**。
● **无法处理浮动垃圾**，可能出现 Concurrent Mode Failure。浮动垃圾是指**并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收**。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 不能像其它收集器那样等待老年代快满的时候再回收。**如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。**



### 5.7 G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在**多 CPU 和大内存**的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 **G1 可以直接对新生代和老年代一起回收**。

原理：G1 把堆划分成**多个大小相等的独立区域（Region）**，**新生代和老年代不再物理隔离**，使得每个小区域可以**单独进行垃圾回收**。通过记录以往每个区域垃圾回收时间以及回收所获得的空间，将其存储在一个优先列表，每次根据允许的收集时间，**优先回收价值最大的区域。**

另外每个区域都有一个 **Remembered Set**，用来**记录该区域对象的引用对象所在的区域**。通过使用Remembered Set，在做可达性分析的时候就可以**避免全堆扫描**。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
● 初始标记 与 CMS 收集器一样
● 并发标记 与 CMS 收集器一样
● 最终标记：和 CMS 收集器的重新标记差不多，最终标记的区别在于虚拟机**将在并发标记时标记变化的对象记录在线程的 Remembered Set Logs** 里面，然后把 Remembered Set Logs 的数据合并到Remembered Set 中。这阶段需要停顿线程（stop the world），但是可多线程执行最终标记。（**防止漏标**）
● 筛选回收：首先对各个区域中的**回收价值和成本**进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要STW。

**特点：**

● 空间整合（不出现内存碎片）：是基于**“复制”算法**实现的，这意味着运行期间**不会产生内存空间碎片**。
● **可预测的停顿：能让用户明确指定在一定时间内，消耗在 GC 上的时间最多不得超过多少**
**秒。**

G1 的三个 GC 的概念：

- YoungGC：就是你的 Eden 区满了之后可能会触发的，但是会先去计算一下回收这个 Eden 区的时间，**如果远远小于先前设定的期望停顿时间**，说明我现在的 **Eden 区其实太小了**，垃圾并不多，不需要触发 youngGC，会新增一些 Eden 区。直到计算回收时间大于等于 200ms 的时候才会去真的触发 YoungGC
- MixGC 和 CMS 的 FullGC 类似：**老年代所占比例大于等于设定的比例了**，就会触发MixGC，会回收所有的年轻代和部分的老年代。为什么是部分呢。因为要根据你最大的停顿时间，计算回收效益比，决定回收那些区域。
- FullGC：整个程序停止，底层就单线程去回收进行标记清楚和整理。什么时候触发呢，就是在MixGC 的时候，在进行复制算法的时候，没有更多的空间供你复制的时候，就会触发 FULL GC

G1 的优缺点：由于细节逻辑很多，底层代码实现非常复杂，在一些内存暂用不大的时候，效率并不高。

### 5.8ZGC 垃圾回收器

支持内存大小提高到 4TB，未来一二十年都够用，这么大的内存还可以达到 STW 的时间达到 10ms，吞吐量降低 15%。

## 类加载过程

### 6.1 加载

加载是类加载的其中一个阶段，注意不要混淆。加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。（The fully qualified name of the class Object, which is defined in the package java.lang, is "java.lang.Object".）

- 通过类的全限定名称获取定义该类的二进制字节流（**二进制字节码**）；
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构（**Java 类模型**）；
- 将字节码文件加载到内存后，在**方法区中生成一个类模板对象**，在**堆**中生成一个**代表该类的 Class 对象**，作为该类在方法区中的各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础；
- 从网络中获取，最典型的应用是 Applet；
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类；
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码；

### 6.2 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
验证阶段会完成以下 4 个阶段的动作（从 class 文件的外到内记忆：文件->元信息（有关类）->方法里边的字节码指令->符号引用）：

- **文件格式**验证：例如：魔数是否正确（魔数的唯一作用是：标记该文件是 Class 文件或确认该文件是否为一个能被虚拟机接受的 Class 文件。）
- 元数据验证：例如：这个类是否继承了不能继承的类
- 字节码验证：通过对字节码流分析，判断是否可以被正确的执行，例如：保证跳转指令不会跳到方法体以外的字节码指令上。注意前面加上指令是为了方便记忆。
- 符号引用验证：例如：通过符号引用中的字符串描述的全限定名是否能找到对应的类



### 6.3 准备

准备阶段为**类变量分配内存并设置初始值**，使用的是**方法区的内存**，jdk1.6。jdk1.7 以后使用的是堆的内存。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，**实例化不是类加载的一个过程**，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

类变量分配空间都在准备阶段完成：

- 如果 static 变量是 **final 的基本类型以及字符串常量**，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化；
- 如果 static 变量是 **final引用类型**，赋值在初始化阶段完成。

#### 6.4 解析

将常量池中类、接口、字段、方法的**符号引用替换为直接引用**（内存地址）的过程；

- 符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和**方法描述符**（因为类还没有加载完，很多方法是找不到的）；
- 直接引用：直接**指向目标的指针、相对偏移量或一个间接定位到目标的句柄**，如果有了直接引用，那说明引用的目标必定已经存在于内存之中；

#### 6.5 初始化

**初始化阶段才真正开始执行类中定义的 Java 程序代码**，在**准备阶段**，类变量已经赋过一次系统要求的**默认初始值**；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行  `<clinit>` 。

 `<clinit>()`：类构造器，由编译器自动收集类中**所有类变量的赋值动作和静态语句块**中的语句合并产生的，初始化阶段会先执行`<clint>()`方法，会为静态类变量显示赋值并执行静态代码块。



### 6.6 如何实现自定义的类加载器

自定义类加载器，继承 java.lang.ClassLoader，**重写 findClass() 方法**，这个方法首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。

java.lang.ClassLoader 的 **loadClass()实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它***，但是需要**重写 findClass() 方法** 。



#### 6.7 类与类加载器

对于任意一个类，都必须有加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名空间。即比较两个类是否是同一个类（“相等”），必须是由同一个类加载器加载的前提下才有意义。

类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象

从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分；
- 自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范**将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器**，使用 Java 语言实现，独立于虚拟机。

从 Java 开发人员的角度看：

- 启动类加载器（Bootstrap ClassLoader）：
  - 处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类
  - 类加载器负责加载在 `JAVA_HOME/jre/lib` 或 `sun.boot.class.path` 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中
  - 仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载
  - 启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替
- 扩展类加载器（Extension ClassLoader）：
  - 由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null
  - 将 `JAVA_HOME/jre/lib/ext` 或者被 `java.ext.dir` 系统变量所指定路径中的所有类库加载到内存中
  - 开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载
- 应用程序类加载器（Application ClassLoader）：
  - 由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension
  - 负责加载环境变量 classpath 或系统属性 `java.class.path` 指定路径下的类库
  - 这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器
  - 可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器
- 自定义类加载器：由开发人员自定义的类加载器，上级是 Application



### 6.8 双亲委派模型

双亲委派模型（Parents Delegation Model）体现了**类加载器之间的层次关系**，该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过**组合关系**（Composition）来实现，而不是继承关系（Inheritance）。

工作过程：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

双亲委派机制的优点：Java中的类随着它的类加载器一起具备了**一种带有优先级的层次关系，从而使得基础类得到统一**，可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性。

### OOM是什么？如何排查？

OOM就是内存空间用完了，垃圾回收器也没有垃圾对象回收释放空间。

除了程序计数器外，其他内存区域都有OOM的风险。

- 栈一般会发生`StackOverflowException`，如，32位的Windows系统单进程限制2G，无限制创建进程会发生栈的OOM；
- Java8常量池移到堆中，溢出会发生`java.lang.OutOfMemoryError:Java heap space`，设置最大元空间大小参数无效；
- 堆内存溢出，也会发生`java.lang.OutOfMemoryError:Java heap space`，是GC之后无法在堆内存空间中申请内存创建对象；
- 方法区OOM，经常会动态生成大量的类、jsp等；
- 直接内存OOM，涉及到`-XX:MaxDirectMemorySize`参数和`Unsafe`对象对内存的申请。

排查OOM的方法：

- 配置参数`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof`，当OOM时会自动dump堆内存信息到指定目录；
- `jstat`查看监控的JVM内存和GC情况，先观察大概出现在什么区域；
- 使用MAT工具加入dump文件，分析大对象占用情况，比如HashMap做缓存未清理，时间长了就会内存溢出，可以改为弱引用。

### 如何判断一个对象是否存活？

判断对象是否存活的方式一般有两种：引用计数法和可达性分析算法。

- 引用计数法：对每个对象保存一个整形的引用计数器，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用，无法解决循环引用问题，会引发内存泄漏）。
- 可达性分析：以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象，内存中的存活对象都会被根对象集合直接或间接连接着；如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。

### 可达性算法不可达的对象就一定会死亡，会被回收吗？

不一定。

在可达性算法中不可达的对象也不一定是非死不可的，这时候它们暂时处于“缓刑”阶段，要真正宣告它的死亡还需要经历**两次的标记阶段**。

第一次标记：
在对象可达性算法不可达时，进行第一次标记，并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象**没有重写finalize()方法**或者**该方法被虚拟机调用过**，虚拟机将这两种情况视为“没有必要去执行”。

如果该对象被判定为**有必要执行finalize()方法**，那么这个对象会被放置到一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去执行它。这里所谓的执行就是去触发该方法，但是并不会承诺等待它执行结束，这样做的原因是，如果对象在finalize()方法中执行缓慢，或者发生死循环，将会导致整个队列中的对象处于等待之中。

第二次标记：
finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己——**只要重新与引用链上的一个对象重新建立关联即可**，譬如将自己（this关键字）赋值给某个类变量或者成员变量，那么在第二次标记的时候就会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么就会被真的回收了！

### 强引用、软引用、弱引用、虚引用是什么？有什么区别？

- 强引用：被强引用关联的对象**不会被回收**，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收；使用new关键字创建的对象都是强引用。
- 软引用：被软引用关联的对象只有在**内存不够**的情况下才会被回收；使用`SoftReference`来标记软引用。
- 弱引用：被弱引用关联的对象**一定会被回收**，只能存活到**下一次垃圾回收**发生之前；使用`WeakReference`来标记弱引用。
- 虚引用：是所有引用类型中最弱的一个，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象，为对象设置虚引用的唯一目的是在于**跟踪垃圾回收**过程，能在这个对象被**回收时**收到一个**系统通知** ；使用`PhantomReference`来标记虚引用。

### 垃圾回收算法有哪些？

基本的垃圾收集算法有三种：标记-清除、标记-整理和复制算法。

- 标记-清除算法：
  - 标记阶段：从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，**标记的是引用的对象，不是垃圾** ；
  - 清除阶段：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到**空闲列表**的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块；
- 标记-整理（压缩）：标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是**将存活对象都向内存另一端移动**，然后清理边界以外的垃圾，从而**解决了碎片化**的问题。
- 复制算法：**将原有的内存空间一分为二，每次只用其中的一块**，利用根可达分析算法，判断该对象是否是可用对象（非垃圾对象），如果可用则移动到空闲survivor区间，当所有对象遍历完成后，清空当前区间，并标记为下一次垃圾回收的空闲survivor区间。

### 有哪几种垃圾回收器，各自的优缺点是什么？

垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；

- Serial:单线程的收集器，收集垃圾时，必须stop the world，使用标记-复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。
- ParNew:Serial收集器的多线程版本，也需要stop the world，标记-复制算法。
- Parallel Scavenge:新生代收集器，使用标记-复制算法，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；
- Serial Old:Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
- Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；
- G1:标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；
- CMS：

### Minor GC 和 Full GC有什么不同？

Minor GC：回收新生代，新生代对象存活时间很短，所以Minor GC会频繁执行，执行的速度比较快；当Eden区要满时执行YoungGC（即Minor GC）。

Full GC：回收老年代和新生代，老年代对象存活时间长，所以Full GC很少执行，执行速度会比Minor GC慢得多；当老年代空间不足或空间分配担保时会触发Full GC。

### 什么时空间担保机制？

当Eden区满时会触发Young GC，当Young GC后Eden区中存活的对象会移动到survivor区，而如果survivor区放不下了，就必须转移到老年代中，但这时如果老年代也放不下这些对象，就需要老年代空间担保机制来保证对象能进入老年代。

1. 在YoungGC之前，会判断老年代可用空间是否大于新生代存活对象的大小，如果大于则可以直接进行Young GC；如果小于则检查是否允许空间担保；
2. 检查`-XX:HandlePromotionFilure`是否允许担保失败，如果不允许，则直接Full GC；如果允许则判断老年代可用空间是否大于历次晋升到老年代对象的平均大小，如果是则尝试Young GC；如果不是则直接Full GC；
3. 担保后的Young GC的结果可能是：
   - Young GC后存活的对象小于survivor区间，则直接将存活对象移动到survivor区间；
   - 存活对象大于survivor区间，小于老年代可用空间，则存活对象晋升到老年代；
   - 如过存活对象大于老年代可用空间，则触发Full GC同时进行一次Young GC;
4. 如果Full GC后空间仍然不够，则OOM内存溢出。

### 如何优化 JVM 频繁 minor GC

### JVM 内存是如何对应到操作系统内存的？

### JVM怎么去调优？了解哪些参数和指令？

- `jps`: JVM Porcess Status Tool，显示指定系统内所有的HotSpot虚拟机进程;

- `jstat`：JVM statistic monitoring，用于监视虚拟机运行时状态信息的指令，可以显示虚拟机进程的类装载、内存、垃圾收集、JIT编译等运行数据；

- `jmap`：JVM Memory Map，用于生成heap dump文件，如果不使用这个命令，还可以使用`-XX:+HeapDumpOnOutOfMemoryError`参数让虚拟机在出现OOM时自动生成dump文件。

  jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前的使用率、当前使用的哪种收集器等。

- `jhat`：JVM Heap Analysis Tool，与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的Http/HTML服务器，生成dump的分析结果后可以在浏览器中查看，因为jhat分析是一个非常耗时并且耗费硬件资源的过程，因此一般把生成的dump文件复制到本地或者其他机器上进行分析。

- `jstack`：用于生成Java虚拟机当前时刻线程的快照。jstack查看各个线程的调用堆栈，可以知道没有响应的线程在等待什么资源。如果Java程序崩溃生成core文件，jstack工具可以用来获得core文件的Java stack和native stack信息，从而知道Java程序是如何崩溃的和在程序何处发生问题。

### Java逃逸分析机制

### class文件内容

