1. ## 线程

### 1.1 线程状态转换（流转）

线程状态有：new、Runnable、Waiting、Timed Waiting、Blocked、Terminated。

### 1.2 创建线程的 3 种方式 

1. 实现Runnable接口
2. 实现Callable接口
3. 继承Thread类
4. 线程池

实现 Runnable 和 Callable 接口的类**只能当做一个可以在线程中运行的任务**，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说**任务是通过线程驱动从而执行的**。

### 1.3 基础线程机制（线程池，守护线程，sleep()，yield()）

**Daemon**
**守护线程**是程序运行时在后台提供服务的线程。
**当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程**（与普通线程的最大区别，普通线程要手动控制结束）。

使用 `setDaemon()` 方法将一个线程设置为守护线程

## 2 线程池

### 2.1 什么是线程池？

线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作。

线程池的核心思想：**线程复用**，同一个线程可以被重复使用，来处理多个任务

池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销。



### 2.1 使用线程池好处？

1. **降低资源消耗**，通过重复利用已创建的线程**降低线程创建和销毁造成的消耗**。
2. **提高响应速度**，当任务到达时，如果有线程可以直接用，不需要等待线程的创建就可以立即执行。
3. **提高线程的可管理性**，线程是稀缺资源，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

### 2.3 Executor

Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。

### 2.3.1 Executor框架结构

1. 任务（Runnable、Callable）

   执行任务需要实现的 Runnable 接口 或 Callable 接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。

2. 任务的执行(Executor)

   ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。

3. 异步计算的结果(Future)

   Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。

   当 我 们 把 Runnable 接 口 或 Callable 接 口 的 实 现 类 提 交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）。

#### 2.3.2 几种线程池管理器

- newCachedThreadPool
- newFixedThreadPool
- newScheduledThreadPool
- newSingleThreadExecutor

#### 2.3.3 线程池的执行流程

1. 创建线程池，这时没有创建线程（**懒惰**），等待提交过来的任务请求，调用 execute 方法才会创建线程
2. 当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：
   - 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务
   - 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列
   - 如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程**立刻运行这个任务**，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行
   - 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和**拒绝策略**来执行
3. 当一个线程完成任务时，会从队列中取下一个任务来执行
4. 当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小



#### 2.3.4 Runnable vs Callable

Runnable接口**不会返回结果或抛出异常**；但Callable接口可以



#### 2.3.5 execute() vs submit()

excute()方法用于**提交不需要返回值的任务**，所以无法判断任务是否被线程池成功执行。

submit()方法用于**提交需要返回值的任务**，线程池会返回一个Future类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，**get()方法会阻塞当前线程直到任务完成**，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。



#### 2.3.6 shutdown() vs shutdownNow()

shutdown（）：关闭线程池，线程池的状态变为 **SHUTDOWN**。**线程池不再接受新任务了，但是队列里的任务得执行完毕**。
shutdownNow（）：关闭线程池，线程的状态变为 **STOP**。**线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List**。



#### 2.3.7 isTerminated() vs isShutdown()

isShutDown 当调用 shutdown() 方法后返回为 true。
isTerminated 当调用 shutdown() 方法后，并且**所有提交的任务完成后返回为 true**。



#### 2.3.8 线程池大小的确定

-  **CPU 密集型任务(N+1)**： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
-  **I/O 密集型任务(2N)**： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

## 3 互斥同步

### 3.1 synchronized

可以同步**整个类**，同步**方法**，同步**代码快**，同步**静态方法**

### 3.2 ReentrantLock

创建一个ReentrantLock对象，然后调用lock();

释放锁：unlock()