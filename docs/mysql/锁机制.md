## 锁机制

### 基本介绍

锁机制：数据库系统使用锁是为了支持对共享资源进行 **并发访问** ，提供数据的 **完整性** 和 **一致性** 。

利用 MVCC 性质进行读取的操作叫**一致性读**，读取数据前加锁的操作叫**锁定读**

锁的分类：

- 按操作分类：
  - 共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据。 ps：共享锁主要是防止在读数据时，其他事务对数据进行修改。
  - 排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入。
- 按粒度分类：
  - 行级锁：会锁定当前操作行，开销大，加锁慢；**会出现死锁**；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB。
  - 表级锁：会锁定整个表，开销小，加锁快；**不会出现死锁**；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM。
  - 页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，**会出现死锁**，并发性能一般。
- 按使用方式分类：
  - 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。
  - 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据。

- 意向锁
    - 意向共享锁 (IS Lock)，事务想要获得一个表中某几行的共享锁
    - 意向排他锁 (IX Lock)，事务想要获得一个表中某几行的排他锁。

查看当前请求锁信息：
```sh
show engine innodb status/G;
```

### 一致性的非锁定读操作

一致性的非锁定行读(consistent nonlocking read)是指InnoDB存储引擎通过行多版本控制 (multi versioning)的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE、UPDATE操作，这时读取操作不会因此而会等待行上锁的释放，相反InnoDB存储引擎会去读取行的一个快照数据。
快照数据是指该行之前版本的数据，该实现是通过Undo段来实现。而Undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销此外，读取快照数据是不需要上锁的，因为没有必要对历史的数据进行修改。

对于快照数据的定义却不相同。
- 在ReadCommitted事务隔离级别下，对于快照数据非一致性读总是读取被锁定行的 **最新一份** 快照数据。
- 在Repeatable事务隔离级别下和Repeatable Read事务隔离级别下，对于快照数据非一致性读总是读取 **事务开始** 时的行数据版本。

> InnoDB存储引擎的SELECT操作使用一致性非锁定读。而MySQL的默认隔离级别是'REPEATABLE-READ'。

### 内存结构

对一条记录加锁的本质就是**在内存中**创建一个锁结构与之关联，结构包括

* 事务信息：锁对应的事务信息，**一个锁属于一个事务**
* 索引信息：对于行级锁，需要记录加锁的记录属于哪个索引
* 表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特
* type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分
  * lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类
  * lock_type：代表表级锁还是行级锁
  * rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting = true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程

一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：

* 在同一个事务中的加锁操作
* 被加锁的记录在同一个页面中
* 加锁的类型是一样的
* 加锁的状态是一样的

### Server

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)

MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，**当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁**，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全

说明：DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务

MDL 锁的特性：

* MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）

* MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁

* MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁

FLUSH TABLES WITH READ LOCK 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：

1. 上全局读锁（lock_global_read_lock）
2. 清理表缓存（close_cached_tables）
3. 上全局 COMMIT 锁（make_global_read_lock_block_commit）

该命令主要用于备份工具做**一致性备份**，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大

### 加锁操作

- SELECT...FOR UPDATE 

    对读取的行记录加一个X锁。其他事务想在这些行上加任何锁都会被阻塞。

- SELECT...LOCK IN SHARE MODE 
    
    对读取的行记录加一个S锁。其他事务可以向被锁定的记录加S锁，但是对于加X锁，则会被阻塞。

