## 基础

***

###  MySQL 语句执行过程？

***

1. 客户端经历三次握手和MySQL的连接器进行TCP连接，连接建立后，连接器验证用户名和密码，连接器会获取用户的权限保存，后续用户的操作都会基于此权限进行逻辑判断。

2. 查询缓存，MySQL服务收到客户端的SQL语句会解析出第一个字段，查看是什么类型的的语句。

   - 如果是select语句，MySQL会先去（Query Cache）里查找缓存数据，看看之前有没有执行过这一命令。查询缓存是以k-v形式保存在内存中的，key为SQL查询语句，value为SQL语句查询的结果。

   - 如果查询的语句命中缓存，那么会直接返回value给客户端。如果查询的语句没有命中查询缓存，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

     > 对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了
     >
     > ​
     >
     > 这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。

3. 解析SQL

   - 词法分析，MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。
   - 语法分析，根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

4. 执行SQL

   - prepare 阶段，也就是预处理阶段；**预处理器**检查SQL语句中的表或字段是否存在；将`select *` 中的 `*`符号，扩展为表上的所有列。

   - optimize 阶段，也就是优化阶段；**优化器**主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

   - execute 阶段，也就是执行阶段；**执行器**和存储引擎交互，交互是以记录为单位的。

     - 主键索引查询

     - 全表扫描

     - 索引下推

       > 索引下推能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
       >
       > 回表查询前先对二级索引进行进行判断，如果条件不成立则跳过该二级索引；如果成立则执行回表查询，将查询的记录返回给Server层。

### 存储结构

***

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，保存t_order 的**表结构** 。
- t_order.ibd，保存 t_order 的**表数据** 。

#### 表空间

表空间由**段**（segment）、**区**（extent）、**页**（page）、行（row）组成。

1. 表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。
   - 索引段：存放 B + 树的非叶子节点的区的集合；
   - 数据段：存放 B + 树的叶子节点的区的集合；
   - 回滚段：存放的是回滚数据的区的集合， MVCC 利用了回滚段实现了多版本查询数据。
2. 在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就**使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**。
3. 页是 InnoDB 存储引擎磁盘管理的最小单元，**InnoDB 的数据是按「页」为单位来读写的**，以页为单位，将其整体读入内存。
4. 数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

![输入图片说明](https://foruda.gitee.com/images/1681717602585779093/a4762aa8_8616658.png "屏幕截图")

#### InnoDB行格式

InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。

##### COMPACT 

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

1. 记录的额外信息
   - 变长字段长度列表：变长字段在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。
   - NULL 值列表：表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。用整数字节的位表示（1字节8位），如果1字节不够表示，则再创建1字节。
   - 记录头信息
     - delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
     - next_record：下一条记录的位置。记录与记录之间是通过链表组织的。
     - record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。

![输入图片说明](https://foruda.gitee.com/images/1681718123242119817/951957a4_8616658.png "屏幕截图")

> MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

## 索引

***

**索引**是帮助存储引擎快速获取数据的一种**数据结构** 。

### 索引分类

***

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

#### 按数据结构分类

从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。

主键索引和二级索引默认使用的是B+树索引。

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放**的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

> B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**

##### 为什么选择B+Tree 作为索引结构？

- Hash虽然能快速查询，但是不支持范围查询。
- 二叉树，再某些情况下会退化成链表，在这种情况相当于全表扫描；二叉树的层级比较深，磁盘I/O次数比较多。
- 平衡二叉树，虽然解决了退化成链表的的问题，但是仍然存在层级较深的问题，如果每个节点存放一页，磁盘I/O效率问题还是没有解决，导致搜索效率不足；并且查询效率不足。
- 多路平衡查找树（Balance Tree），B Tree 能够很好的利用操作系统和磁盘的交互特性，相对平衡二叉树IO次数降低了很多。
- B+ Tree，B+ Tree是B Tree的变种，每个非叶子节点只存储索引关键字，数据存储在叶子节点中，这样B+ Tree相对于B Tree的非叶子节点可以存储更多的关键字，降低层级，减少磁盘IO次数，提高效率，保证性能的稳定性。

### 按字段特性分类

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。

#### 主键索引

主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。



#### 唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

#### 普通索引

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

#### 前缀索引

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

### 按字段的个数分

从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

#### 联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

##### 联合索引失效

- 不遵循**最左匹配原则**

- 范围查询的字段可以用到联合索引，但范围查询字段后面的字段无法使用联合索引。

  > 联合索引`(a, b)`
  >
  > `where a > 1 and b = 2` , a可以用到联合索引，b无法用到联合索引，因为在二级索引记录中，a是有序的而b是无序的。
  >
  > `where a >= 1 and b = 2` ，a和b都可以用到联合索引，因为在a=1的范围中，b是有序的。
  >
  > `WHERE a BETWEEN 2 AND 8 AND b = 2` ，a和b都用到了联合索引。
  >
  > `WHERE alike 'j%' and b= 22 `，a和b都用到了联合索引，对于符合 a= j 的二级索引记录的范围里，b字段的值是「有序」的

### 索引失效

1. 索引字段左模糊匹配`%xx `，索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。

   > 如果`%xx `的查询字段`select x,id`是覆盖索引或主键，那么是对二级索引树全扫描，因为针对二级索引树存储的字段更少，全扫描就能查询到结果。
   >
   > 如果`%xx `的查询字段`select a,b`包含非索引字段，那么直接全表扫描。

2. 索引使用函数，如，`length(name)`，索引保存的关键字是索引字段的原始值，而不是函数计算后的值。

   > MySQL 8.0后可以针对函数计算后的值建立一个索引。
   >
   > `alter table t_user add key idx_name_length ((length(name)));`

3. 对索引表达式计算，如，`id + 1 = 10` ,和2中的原因相似，索引保存的字段是原始值，只能把索引字段的值取出来，然后一次进行表达式的计算来进行条件判断，因此采用的是全表扫描的方式。

4. 对隐式索引类型的转换，如索引字段`phone -varchar(30)` ,类型自动转换会使用函数，函数会使索引失效。

   > MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。
   >
   > `select * from t_user where phone = 1300000001;`
   >
   > 相当于
   >
   > `select * from t_user where CAST(phone AS signed int) = 1300000001;`

5. 索引非最左匹配，联合索引`(a,b,c)`在创建的时候，是先针对前一个字段排序后再对后面字段排序，即，先对`字段a`排序后，`字段b`在`字段a`排序的基础上再进行排序，`字段c`同样如此。

   > 因为MySQL中有查询优化器，所以Where 子句的顺序并不重要。
   >
   > MySQL5.6之后，当索引截断时会走索引下推，当查询条件`where a = 1 and c = 3`时，`字段a`会走索引，会再存储引擎中筛选出符合条件`c = 3`的数据后再返回给Server层，过滤掉大量不符合条件的数据，减少回表的次数。

6. where 字句中的or

   - 如果or前是条件列，or后是非索引列，索引会失效。因为or的含义是前后条件有一个成立即可，因此只有一个列是条件列是没有意义的。
   - 如果or前后都是索引列，那么会针对两个条件列分别扫描，将结果合并。

### 统计计数

1. `count(主键 id)`：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来返回给 Server 层，Server 判断 id 不为空就按行累加。
2.  `count(1)`：InnoDB 引擎遍历整张表但不取值，Server 层对于返回的每一行，放一个数字 1 进去，判断不为空就按行累加。
3. `count(字段)`：如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加.
4.  `count(*)`：不取值，按行累加。

> `count(字段) < count(主键id) < count(1) ≈ count(*)`，所以建议尽量使用 count(*)

#### count()优化

1. 如果业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值，使用`explain select count(*) from t_order;`
2. 如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中,当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。

## 锁机制

***

> 锁机制：数据库为了保证`数据的一致性`，在共享的资源被`并发访问`时变得安全有序所设计的一种规则
>
> 利用 MVCC 性质进行读取的操作叫`一致性读`，读取数据前加锁的操作叫`锁定读`



### 锁的分类

***

- **按操作分类：**
  - 共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据。

  - 排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入。

    > ps：共享锁主要是防止在读数据时，其他事务对数据进行修改。

- **按粒度分类：**
  - 行级锁：会锁定当前操作行，开销大，加锁慢；`会出现死锁`；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB。
  - 表级锁：会锁定整个表，开销小，加锁快；`不会出现死锁`；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM。
  - 页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，`会出现死锁`，并发性能一般。

- **按使用方式分类：**
  - 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。
  - 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据。

- **意向锁：**

  - 意向共享锁 (IS Lock)：事务想要获得一个表中某几行的共享锁
  - 意向排他锁 (IX Lock)：事务想要获得一个表中某几行的排他锁。

查看当前请求锁信息：

```bash
show engine innodb status/G;
```



### MVCC

***

一致性的非锁定行读(consistent nonlocking read)是指InnoDB存储引擎通过行多版本控制 (multi versioning)的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE、UPDATE操作，这时读取操作不会因此而会等待行上锁的释放，相反InnoDB存储引擎会去读取行的一个快照数据。 快照数据是指该行之前版本的数据，该实现是通过Undo段来实现。而Undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销此外，读取快照数据是不需要上锁的，因为没有必要对历史的数据进行修改。

对于快照数据的定义却不相同。

- 在ReadCommitted事务隔离级别下，对于快照数据非一致性读总是读取被锁定行的 **最新一份** 快照数据。
- 在Repeatable事务隔离级别下和Repeatable Read事务隔离级别下，对于快照数据非一致性读总是读取 **事务开始** 时的行数据版本。

> InnoDB存储引擎的SELECT操作使用一致性非锁定读。而MySQL的默认隔离级别是'REPEATABLE-READ'。

### 内存结构

***

对一条记录加锁的本质就是**在内存中**创建一个锁结构与之关联，结构包括

* 事务信息：锁对应的事务信息，`一个锁属于一个事务`

  > ❓ 一个锁属于一个事务，那么多个事务对共享锁的加锁流程是怎样的？多个事务同时拥有同一锁吗？

* 索引信息：对于行级锁，需要记录加锁的记录属于哪个索引

* 表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特

* type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分
  * lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类
  * lock_type：代表表级锁还是行级锁
  * rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting = true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程

一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：

* 在同一个事务中的加锁操作
* 被加锁的记录在同一个页面中
* 加锁的类型是一样的
* 加锁的状态是一样的

### Server

***

MySQL 里面`表级别`的锁有两种：

- 表锁
- 元数据锁（meta data lock，MDL)

MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，**当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁**，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全

> DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务

MDL 锁的特性：

* MDL 锁不需要显式使用，在访问一个表的时候会被`自动加上`，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）

* MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁

* MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁

`FLUSH TABLES WITH READ LOCK` 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：

1. 上全局读锁（lock_global_read_lock）
2. 清理表缓存（close_cached_tables）
3. 上全局 COMMIT 锁（make_global_read_lock_block_commit）

该命令主要用于备份工具做**一致性备份**，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大

### 加锁操作

- SELECT...FOR UPDATE

  对读取的行记录加一个X锁。其他事务想在这些行上加任何锁都会被阻塞。

- SELECT...LOCK IN SHARE MODE

  对读取的行记录加一个S锁。其他事务可以向被锁定的记录加S锁，但是对于加X锁，则会被阻塞。

### 锁问题

***

通过锁可以实现事务隔离性要求，使得事务并发工作，但也存在问题。

#### 1、丢失更新

以下情况可能会出现丢失更新：

(1) 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1

(2) 事务T2也查询该行数据，并将取得的数据显示给终端用户User2

(3) User1修改这行记录，更新数据库并提交

(4) User2修改这行记录，更新数据库并提交

![输入图片说明](https://foruda.gitee.com/images/1681286331052856236/364dd2f7_8616658.png "屏幕截图")

> mysql 默认的隔离级别是'REPEATABLE-READ'，在同一个事务中的查询结果是相同的。
>
> ps：个人认为是业务逻辑上判断存在问题，因为用`update`更新时，同一个数据只有一个事务能更新，其余事务会进行等待，超时会报`Lock wait timeout exceeded; try restarting transaction`。

**解决方案：**在读取数据的时候也加上排他锁

#### 2、脏读

脏读指的就是在不同的事务下，可以读到另外事务未提交的数据，简单来说，就是可以读到脏数据，`读未提交`。违反了数据库的隔离性。

> `脏数据`和`脏页`有所不同。
>
> 脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘，即数据库实例内存中的页和磁盘的页中的数据是不一致的，当然在刷新到磁盘之前，日志都已经被写人了重做日志文件中。
>
> 脏数据，是指在缓冲池中被修改的数据，并且还没有被提交 (commit)。

#### 3、不可重复读

不可重复读，在同一事务中多次读取同一数据的结果不同，由于在第一个事务在多次读取数据的间隙，其他事务对数据进行了修改，造成第一个事务多次读取的数据不一致。违反了数据库事务一致性的要求。

InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。在Next-KeyLock算法下，对于索引的扫描，不仅仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围 (gap)。因此对于这个范围内的插人都是不允许的。

### 阻塞

***

在InnoDB存储引擎的源代码中，用`Mutex数据结构`来实现锁。在访问资源前需要用mutex_enter函数进行申请，在资源访问或修改完毕后立即执行mutex_exit函数。当一个资源已被一个事务占有时，另一个事务执行mutex_enter函数会发生等待，这就是阻塞。阻塞并不是一件坏事，阻塞是为了保证事务可以并发并且正常运行。

默认情况下InnoDB存储引擎不会回滚超时引发的错误异常

### 死锁

***

InnoDB存储引擎有一个后台的锁监控线程，该线程负责查看可能的死锁问题，并自动告知用户。发现死锁后，InnoDB存储引擎会马上回滚一个事务。

### 锁升级

***

数据库可以把一个表的行锁升级为一个页锁，或者将页锁升级为表锁。

锁升级带来的一个问题却是，因为锁粒度的降低而导致并发性能的降低。

InnoDB存储引擎不存在锁升级的问题。在InnoDB存储引擎中，1个锁的开销与1000000个锁是一样的，都没有开销。



## 事务

***

事务用来保证数据库的完整性，可以将多个操作看作一个完整的操作，具有四个特性（ACID）。

- 原子性

  原子性是指整个数据库事务是不可分割的工作单位，要么全部成功，要么全部失败。

- 一致性

  一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

- 隔离性

  一个事务的影响在该事务提交前对其他事务都不可见一一这通过锁来实现。

- 持久性

  事务一旦提交，其结果就是永久性的。即使发生岩机等故障，数据库也能将数据恢复。

### 事务的实现

***

原子性、一致性、持久性通过数据库的redo和undo来完成。

#### redo

在InnoDB存储引擎中，事务日志通过`重做 (redo) 日志文件`和InoDB存储引擎的`日志缓冲(InnoDB Log Buffer)` 来实现。

- 当开始一个事务时，会记录该事务的一个LSN (LogSequence Number，日志序列号)。
- 当事务执行时，会往InnoDB存储引擎的日志缓冲里插入事务日志。
- 当事务提交时，必须将InnoDB存储引擎的日志缓冲写人磁盘(默认的实现即innodb_flush_log_at_trx_commit=1)。

在InnoDB存储引擎中`在写数据前，需要先写日志`。这种方式称为预写日志方式(Write-Ahead Logging，WAL)。

InnoDB存储引擎通过`预写日志(Write-Ahead Logging，WAL)`的方式来保证事务的完整性，即`在写数据前，需要先写日志`。这意味着磁盘上存储的数据页和内存缓冲池中的页是不同步的，对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写人磁盘，因此是一种异步的方式。

#### undo

对数据库进行修改时，不但会产生redo，而且还会产生一定量的undo。

执行的事务或语句由于某种原因失败了，或者用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。与redo不同的是，redo存放在重做日志文件中，undo存放在数据库内部的一个特殊段(segment)中，这称为undo段(undo segment)，undo段位于共享表空间内。

### 事务的隔离级别

***

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

InnoDB存储引擎默认的支持隔离级别是`REPEATABLE READ`，是与标SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用`Next-Key Lock锁`的算法，因此**避免幻读**的产生。所以说，InnoDB存储引擎在默认REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。

### 分布式事务

***

InnoDB存储引擎支持XA事务，通过XA事务可以来支持分布式事务的实现。分布式事指的是允许多个独立的事务资源 (transactionalresources)参与一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中所有参与的事务要么都提交、要么都回滚，这对于事务原有的ACID要求又有了提高。另外,在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIABLE。

分布式事务由一个或者多个**资源管理器** (Resource Managers)、一个**事务管理器**（Transaction Manager）以及一个**应用程序**(Application Program)组成。

- 资源管理器:提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
- 事务管理器:协调参与全局事务中的各个事务。需要和参与全局事务中的所有资源管理器进行通信。
- 应用程序:定义事务的边界，指定全局事务中的操作。

分布式事务使用两段式提交(two-phase commit)的方式。

（1）在第一个阶段，所有参与全局事务的节点都开始准备 (PREPARE)，告诉事务管理器它们准备好提交了。

（2）第二个阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。

如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。