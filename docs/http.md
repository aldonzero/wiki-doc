HTTP是一种在应用层传输的超文本传输协议，客户端向服务器发送HTTP请求，服务器则向客户端返回HTTP响应。通常使用80端口，HTTP协议是无状态协议，这意味着服务器不会保存客户端的任何信息，每个请求都是独立的。

### 结构

状态行、消息报头、空行和响应正文。

- 请求行：由客户端发送给服务器的第一行，用于描述请求的方法、URI和协议版本。例如：GET /index.html HTTP/1.1。
- 请求头部：由客户端发送给服务器的一组属性-值对，用于传递请求相关的元数据，例如User-Agent、Accept、Content-Type等。
- 请求正文：可选的请求主体，用于在客户端向服务器传递额外的数据，例如POST请求中的表单数据、文件上传等。

### 状态码及解释

- 1xx：信息 - 未使用，但保留供将来使用 
- 2xx：成功 - 已成功接收、理解和接受操作。
- 3xx：重定向 - 必须采取进一步操作才能完成请求 
- 4xx：客户端错误 - 请求包含错误的语法或无法完成 
- 5xx：服务器错误 - 服务器无法满足明显有效的请求

常用状态码：

```bash
| "200"   ; OK
| "201"   ; Created
| "202"   ; Accepted
| "204"   ; No Content
| "301"   ; Moved Permanently
| "302"   ; Moved Temporarily
| "304"   ; Not Modified
| "400"   ; Bad Request
| "401"   ; Unauthorized
| "403"   ; Forbidden
| "404"   ; Not Found
| "500"   ; Internal Server Error
| "501"   ; Not Implemented
| "502"   ; Bad Gateway
| "503"   ; Service Unavailable
```

HTTP状态代码是可扩展的，但上述代码是当前实践中唯一普遍认可的代码。

### 方法定义

#### GET

 `GET` 方法请求指定的资源。使用 `GET` 的请求应该只用于获取数据。安全、幂等、可缓存。

#### HEAD

`HEAD`方法和`GET`方法类似，都是用于从服务器请求资源，但是`HEAD`方法不返回正文题，只返回响应头部信息，如状态码、响应头字段等。通常用于查询服务器资源数据，如文件大小、类型、最后修改时间等。

#### POST

`POST`方法通常是将数据发送给服务器，并将处理结果返回。非安全、非幂等、一般不可缓存。

### HTTP Cookie

服务器收到 HTTP 请求后，服务器可以在响应标头里面添加一个或多个 [`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie) 选项。浏览器收到响应后通常会保存下 Cookie，并将其放在 HTTP [`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie) 标头内，向同一服务器发出请求时一起发送。可以指定一个过期日期或者时间段之后，不能发送 cookie。你也可以对指定的域和路径设置额外的限制，以限制 cookie 发送的位置。

### http的发展过程

- HTTP/1.0：最初的HTTP协议版本，它使用明文传输数据，并且每个请求/响应需要打开和关闭一个新的连接。这种方式效率低下，且存在安全风险。
- HTTP/1.1：在HTTP/1.0基础上，引入了持久连接（keep-alive），即多个请求和响应可以共用一个连接。这样可以提高效率并减少连接建立的开销。
- HTTP/2.0：它使用二进制协议，支持多路复用、服务器推送和头部压缩等特性，从而进一步提高了性能。
- HTTPS：https在传输层和应用层之间添加了SSL/TLS(安全套接层/传输层安全)协议的加密和认证机制。客户端通过证书验证服务器的身份，并且在建立连接时使用TLS握手协议来协商加密算法和密钥，从而确保通信的保密性和完整性。
- HTTP/3：是基于QUIC（快速UDP互联网连接）协议的HTTP协议版本。QUIC是一个基于UDP的协议，可以减少延迟和阻塞等问题，因此HTTP/3在性能方面有了很大的提升。它使用TLS 1.3进行加密，同时支持多路复用和流量控制等特性。

## https握手过程

1. 客户端发送一个ClientHello消息，其中包含支持的TLS协议版本、加密算法、压缩算法等信息。还包括一个随机数，该随机数用于生成后续的密钥。此时客户端进入HELLO_SENT状态，等待服务器响应状态。
2. 服务器收到ClientHello消息后，发送一个ServerHello消息，其中包含使用的TLS协议版本、加密算法、压缩算法等信息。还包括一个随机数，该随机数用于生成后续的密钥。HELLO_RECEIVED状态，表示收到客户端ClientHello消息后的状态。
3. 服务器发送一个Certificate消息，其中包含服务器证书。证书用于验证服务器的身份和公钥。如果使用了双向认证，则客户端也会发送一个Certificate消息，其中包含客户端证书。
4. 服务器发送一个ServerKeyExchange消息，该消息仅在某些情况下发送。例如，在Diffie-Hellman密钥交换期间，服务器需要向客户端发送其公共参数，以便客户端可以计算共享密钥。
5. 服务器发送一个ServerHelloDone消息，表示服务器已经完成握手阶段的所有消息。
6. 客户端接收服务器发送的消息，并验证服务器的证书。如果证书有效，则使用服务器的公钥加密一个随机数，并将其发送给服务器。
7. 客户端发送一个ClientKeyExchange消息，该消息包含使用服务器公钥加密的随机数。服务器使用其私钥解密该随机数，并使用该随机数生成共享密钥。
8. 客户端发送一个ChangeCipherSpec消息，该消息通知服务器从现在开始使用协商的加密算法进行通信。
9. 客户端发送一个Finished消息，其中包含使用共享密钥计算出的摘要。服务器也会发送一个Finished消息，客户端接收并验证服务器发送的摘要。
10. TLS握手完成后，双方使用协商的加密算法和密钥进行通信。

## 加密于安全

### 对称加密

对称加密使用相同的密钥来加密和解密数据。这意味着，加密方和解密方都知道相同的密钥。对称加密算法通常具有较高的加密速度，但需要确保密钥的安全性，因为如果密钥泄露，数据就会暴露。

常见的对称加密算法包括AES（高级加密标准）、DES（数据加密标准）和3DES（Triple DES）等。

### 非对称加密—公开密钥加密

非对称加密使用一对密钥，一个是公钥，一个是私钥。公钥可以向任何人公开，用于加密数据，而私钥只有密钥所有者才能访问，用于解密数据。非对称加密算法通常比对称加密算法更安全，因为即使公钥泄露，也不会影响数据的保密性。

常见的非对称加密算法包括RSA（Rivest–Shamir–Adleman）、DSA（数字签名算法）和ECC（椭圆曲线加密）等。

总的来说，对称加密速度快但要求密钥安全，非对称加密更安全但速度较慢。在实际应用中，通常会使用两者结合的方式，即使用非对称加密算法来协商对称加密的密钥，然后使用对称加密算法进行加密和解密。这样可以同时保证安全性和效率。

